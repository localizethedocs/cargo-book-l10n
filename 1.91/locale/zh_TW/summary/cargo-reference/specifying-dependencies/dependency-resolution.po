msgid ""
msgstr ""
"Project-Id-Version: The Cargo Book\n"
"POT-Creation-Date: 2026-01-24T08:38:21Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/reference/resolver.md:1
msgid "Dependency Resolution"
msgstr ""

#: src/reference/resolver.md:3
msgid ""
"One of Cargo's primary tasks is to determine the versions of dependencies to "
"use based on the version requirements specified in each package. This "
"process is called \"dependency resolution\" and is performed by the "
"\"resolver\". The result of the resolution is stored in the `Cargo.lock` "
"file which \"locks\" the dependencies to specific versions, and keeps them "
"fixed over time. The [`cargo tree`](../commands/cargo-tree.md) command can "
"be used to visualize the result of the resolver."
msgstr ""

#: src/reference/resolver.md:15
msgid "Constraints and Heuristics"
msgstr ""

#: src/reference/resolver.md:17
msgid ""
"In many cases there is no single \"best\" dependency resolution. The "
"resolver operates under various constraints and heuristics to find a "
"generally applicable resolution. To understand how these interact, it is "
"helpful to have a coarse understanding of how dependency resolution works."
msgstr ""

#: src/reference/resolver.md:21
msgid "This pseudo-code approximates what Cargo's resolver does:"
msgstr ""

#: src/reference/resolver.md:31
msgid "// Done\n"
msgstr ""

#: src/reference/resolver.md:55
msgid "// No valid solution found, backtrack and `pick_next_version`\n"
msgstr ""

#: src/reference/resolver.md:60
msgid "Key steps:"
msgstr ""

#: src/reference/resolver.md:61
msgid ""
"Walking dependencies (`pick_next_dep`): The order dependencies are walked "
"can affect how related version requirements for the same dependency get "
"resolved, see unifying versions, and how much the resolver backtracks, "
"affecting resolver performance,"
msgstr ""

#: src/reference/resolver.md:65
msgid ""
"Unifying versions (`try_unify_version`, `needs_version_unification`): Cargo "
"reuses versions where possible to reduce build times and allow types from "
"common dependencies to be passed between APIs. If multiple versions would "
"have been unified if it wasn't for conflicts in their [dependency "
"specifications](specifying-dependencies.md), Cargo will backtrack, erroring "
"if no solution is found, rather than selecting multiple versions. A "
"[dependency specification](specifying-dependencies.md) or Cargo may decide "
"that a version is undesirable, preferring to backtrack or error rather than "
"use it."
msgstr ""

#: src/reference/resolver.md:70
msgid ""
"Preferring versions (`pick_next_version`): Cargo may decide that it should "
"prefer a specific version, falling back to the next version when "
"backtracking."
msgstr ""

#: src/reference/resolver.md:74
msgid "Version numbers"
msgstr ""

#: src/reference/resolver.md:76
msgid "Generally, Cargo prefers the highest version currently available."
msgstr ""

#: src/reference/resolver.md:78 src/reference/resolver.md:93
msgid "For example, if you had a package in the resolve graph with:"
msgstr ""

#: src/reference/resolver.md:79
msgid ""
"```toml\n"
"[dependencies]\n"
"bitflags = \"*\"\n"
"```"
msgstr ""

#: src/reference/resolver.md:83
msgid ""
"If at the time the `Cargo.lock` file is generated, the greatest version of "
"`bitflags` is `1.2.1`, then the package will use `1.2.1`."
msgstr ""

#: src/reference/resolver.md:86
msgid ""
"For an example of a possible exception, see [Rust version](#rust-version)."
msgstr ""

#: src/reference/resolver.md:88
msgid "Version requirements"
msgstr ""

#: src/reference/resolver.md:90
msgid ""
"Package specify what versions they support, rejecting all others, through "
"[version requirements](specifying-dependencies.md#version-requirement-"
"syntax)."
msgstr ""

#: src/reference/resolver.md:94
msgid ""
"```toml\n"
"[dependencies]\n"
"bitflags = \"1.0\"  # meaning `>=1.0.0,<2.0.0`\n"
"```"
msgstr ""

#: src/reference/resolver.md:98
msgid ""
"If at the time the `Cargo.lock` file is generated, the greatest version of "
"`bitflags` is `1.2.1`, then the package will use `1.2.1` because it is the "
"greatest within the compatibility range. If `2.0.0` is published, it will "
"still use `1.2.1` because `2.0.0` is considered incompatible."
msgstr ""

#: src/reference/resolver.md:105
msgid "SemVer compatibility"
msgstr ""

#: src/reference/resolver.md:107
msgid ""
"Cargo assumes packages follow [SemVer](https://semver.org/) and will unify "
"dependency versions if they are [SemVer](https://semver.org/) compatible "
"according to the [Caret version requirements](specifying-dependencies."
"md#default-requirements). If two compatible versions cannot be unified "
"because of conflicting version requirements, Cargo will error."
msgstr ""

#: src/reference/resolver.md:112
msgid ""
"See the [SemVer Compatibility](semver.md) chapter for guidance on what is "
"considered a \"compatible\" change."
msgstr ""

#: src/reference/resolver.md:115
msgid "Examples:"
msgstr ""

#: src/reference/resolver.md:117
msgid ""
"The following two packages will have their dependencies on `bitflags` "
"unified because any version picked will be compatible with each other."
msgstr ""

#: src/reference/resolver.md:118
msgid ""
"```toml\n"
"# Package A\n"
"[dependencies]\n"
"bitflags = \"1.0\"  # meaning `>=1.0.0,<2.0.0`\n"
"\n"
"# Package B\n"
"[dependencies]\n"
"bitflags = \"1.1\"  # meaning `>=1.1.0,<2.0.0`\n"
"```"
msgstr ""

#: src/reference/resolver.md:128
msgid ""
"The following packages will error because the version requirements conflict, "
"selecting two distinct compatible versions."
msgstr ""

#: src/reference/resolver.md:129
msgid ""
"```toml\n"
"# Package A\n"
"[dependencies]\n"
"log = \"=0.4.11\"\n"
"\n"
"# Package B\n"
"[dependencies]\n"
"log = \"=0.4.8\"\n"
"```"
msgstr ""

#: src/reference/resolver.md:139
msgid ""
"The following two packages will not have their dependencies on `rand` "
"unified because only incompatible versions are available for each. Instead, "
"two different versions (e.g. 0.6.5 and 0.7.3) will be resolved and built. "
"This can lead to potential problems, see the [Version-incompatibility "
"hazards](#version-incompatibility-hazards) section for more details."
msgstr ""

#: src/reference/resolver.md:142
msgid ""
"```toml\n"
"# Package A\n"
"[dependencies]\n"
"rand = \"0.7\"  # meaning `>=0.7.0,<0.8.0`\n"
"\n"
"# Package B\n"
"[dependencies]\n"
"rand = \"0.6\"  # meaning `>=0.6.0,<0.7.0`\n"
"```"
msgstr ""

#: src/reference/resolver.md:152
msgid ""
"Generally, the following two packages will not have their dependencies "
"unified because incompatible versions are available that satisfy the version "
"requirements: Instead, two different versions (e.g. 0.6.5 and 0.7.3) will be "
"resolved and built. The application of other constraints or heuristics may "
"cause these to be unified, picking one version (e.g. 0.6.5)."
msgstr ""

#: src/reference/resolver.md:156
msgid ""
"```toml\n"
"# Package A\n"
"[dependencies]\n"
"rand = \">=0.6,<0.8.0\"\n"
"\n"
"# Package B\n"
"[dependencies]\n"
"rand = \"0.6\"  # meaning `>=0.6.0,<0.7.0`\n"
"```"
msgstr ""

#: src/reference/resolver.md:171
msgid "Version-incompatibility hazards"
msgstr ""

#: src/reference/resolver.md:173
msgid ""
"When multiple versions of a crate appear in the resolve graph, this can "
"cause problems when types from those crates are exposed by the crates using "
"them. This is because the types and items are considered different by the "
"Rust compiler, even if they have the same name. Libraries should take care "
"when publishing a SemVer-incompatible version (for example, publishing "
"`2.0.0` after `1.0.0` has been in use), particularly for libraries that are "
"widely used."
msgstr ""

#: src/reference/resolver.md:181
msgid ""
"The \"[semver trick](https://github.com/dtolnay/semver-trick)\" is a "
"workaround for this problem of publishing a breaking change while retaining "
"compatibility with older versions. The linked page goes into detail about "
"what the problem is and how to address it. In short, when a library wants to "
"publish a SemVer-breaking release, publish the new release, and also publish "
"a point release of the previous version that reexports the types from the "
"newer version."
msgstr ""

#: src/reference/resolver.md:188
msgid ""
"These incompatibilities usually manifest as a compile-time error, but "
"sometimes they will only appear as a runtime misbehavior. For example, let's "
"say there is a common library named `foo` that ends up appearing with both "
"version `1.0.0` and `2.0.0` in the resolve graph. If [`downcast_ref`](../../"
"std/any/trait.Any.html#method.downcast_ref) is used on an object created by "
"a library using version `1.0.0`, and the code calling `downcast_ref` is "
"downcasting to a type from version `2.0.0`, the downcast will fail at "
"runtime."
msgstr ""

#: src/reference/resolver.md:196
msgid ""
"It is important to make sure that if you have multiple versions of a library "
"that you are properly using them, especially if it is ever possible for the "
"types from different versions to be used together. The [`cargo tree -d`](../"
"commands/cargo-tree.md) command can be used to identify duplicate versions "
"and where they come from. Similarly, it is important to consider the impact "
"on the ecosystem if you publish a SemVer-incompatible version of a popular "
"library."
msgstr ""

#: src/reference/resolver.md:206
msgid "Rust version"
msgstr ""

#: src/reference/resolver.md:208
msgid ""
"To support developing software with a minimum supported [Rust version](rust-"
"version.md), the resolver can take into account a dependency version's "
"compatibility with your Rust version. This is controlled by the config field "
"[`resolver.incompatible-rust-versions`](config.md#resolverincompatible-rust-"
"versions)."
msgstr ""

#: src/reference/resolver.md:212
msgid ""
"With the `fallback` setting, the resolver will prefer packages with a Rust "
"version that is less than or equal to your own Rust version. For example, "
"you are using Rust 1.85 to develop the following package:"
msgstr ""

#: src/reference/resolver.md:215
msgid ""
"```toml\n"
"[package]\n"
"name = \"my-cli\"\n"
"rust-version = \"1.62\"\n"
"\n"
"[dependencies]\n"
"clap = \"4.0\"  # resolves to 4.0.32\n"
"```"
msgstr ""

#: src/reference/resolver.md:223
msgid ""
"The resolver would pick version 4.0.32 because it has a Rust version of "
"1.60.0."
msgstr ""

#: src/reference/resolver.md:224
msgid ""
"4.0.0 is not picked because it is a [lower version number](#version-numbers) "
"despite it also having a Rust version of 1.60.0."
msgstr ""

#: src/reference/resolver.md:225
msgid ""
"4.5.20 is not picked because it is incompatible with `my-cli`'s Rust version "
"of 1.62 despite having a much [higher version](#version-numbers) and it has "
"a Rust version of 1.74.0 which is compatible with your 1.85 toolchain."
msgstr ""

#: src/reference/resolver.md:227
msgid ""
"If a version requirement does not include a Rust version compatible "
"dependency version, the resolver won't error but will instead pick a "
"version, even if its potentially suboptimal. For example, you change the "
"dependency on `clap`:"
msgstr ""

#: src/reference/resolver.md:230
msgid ""
"```toml\n"
"[package]\n"
"name = \"my-cli\"\n"
"rust-version = \"1.62\"\n"
"\n"
"[dependencies]\n"
"clap = \"4.2\"  # resolves to 4.5.20\n"
"```"
msgstr ""

#: src/reference/resolver.md:238
msgid ""
"No version of `clap` matches that [version requirement](#version-"
"requirements) that is compatible with Rust version 1.62. The resolver will "
"then pick an incompatible version, like 4.5.20 despite it having a Rust "
"version of 1.74."
msgstr ""

#: src/reference/resolver.md:242
msgid ""
"When the resolver selects a dependency version of a package, it does not "
"know all the workspace members that will eventually have a transitive "
"dependency on that version and so it cannot take into account only the Rust "
"versions relevant for that dependency. The resolver has heuristics to find a "
"\"good enough\" solution when workspace members have different Rust "
"versions. This applies even for packages in a workspace without a Rust "
"version."
msgstr ""

#: src/reference/resolver.md:248
msgid ""
"When a workspace has members with different Rust versions, the resolver may "
"pick a lower dependency version than necessary. For example, you have the "
"following workspace members:"
msgstr ""

#: src/reference/resolver.md:251
msgid ""
"```toml\n"
"[package]\n"
"name = \"a\"\n"
"rust-version = \"1.62\"\n"
"\n"
"[package]\n"
"name = \"b\"\n"
"\n"
"[dependencies]\n"
"clap = \"4.2\"  # resolves to 4.5.20\n"
"```"
msgstr ""

#: src/reference/resolver.md:262
msgid ""
"Though package `b` does not have a Rust version and could use a higher "
"version like 4.5.20, 4.0.32 will be selected because of package `a`'s Rust "
"version of 1.62."
msgstr ""

#: src/reference/resolver.md:265
msgid ""
"Or the resolver may pick too high of a version. For example, you have the "
"following workspace members:"
msgstr ""

#: src/reference/resolver.md:267
msgid ""
"```toml\n"
"[package]\n"
"name = \"a\"\n"
"rust-version = \"1.62\"\n"
"\n"
"[dependencies]\n"
"clap = \"4.2\"  # resolves to 4.5.20\n"
"\n"
"[package]\n"
"name = \"b\"\n"
"\n"
"[dependencies]\n"
"clap = \"4.5\"  # resolves to 4.5.20\n"
"```"
msgstr ""

#: src/reference/resolver.md:281
msgid ""
"Though each package has a version requirement for `clap` that would meet its "
"own Rust version, because of [version unification](#version-numbers), the "
"resolver will need to pick one version that works in both cases and that "
"would be a version like 4.5.20."
msgstr ""

#: src/reference/resolver.md:288
msgid "Features"
msgstr ""

#: src/reference/resolver.md:290
msgid ""
"For the purpose of generating `Cargo.lock`, the resolver builds the "
"dependency graph as-if all [features](features.md) of all [workspace]"
"(workspaces.md) members are enabled. This ensures that any optional "
"dependencies are available and properly resolved with the rest of the graph "
"when features are added or removed with the [`--features` command-line flag]"
"(features.md#command-line-feature-options). The resolver runs a second time "
"to determine the actual features used when _compiling_ a crate, based on the "
"features selected on the command-line."
msgstr ""

#: src/reference/resolver.md:298
msgid ""
"Dependencies are resolved with the union of all features enabled on them. "
"For example, if one package depends on the [`im`](https://crates.io/crates/"
"im) package with the [`serde` dependency](https://github.com/bodil/im-rs/"
"blob/v15.0.0/Cargo.toml#L46) enabled and another package depends on it with "
"the [`rayon` dependency](https://github.com/bodil/im-rs/blob/v15.0.0/Cargo."
"toml#L47) enabled, then `im` will be built with both features enabled, and "
"the `serde` and `rayon` crates will be included in the resolve graph. If no "
"packages depend on `im` with those features, then those optional "
"dependencies will be ignored, and they will not affect resolution."
msgstr ""

#: src/reference/resolver.md:306
msgid ""
"When building multiple packages in a workspace (such as with `--workspace` "
"or multiple `-p` flags), the features of the dependencies of all of those "
"packages are unified. If you have a circumstance where you want to avoid "
"that unification for different workspace members, you will need to build "
"them via separate `cargo` invocations."
msgstr ""

#: src/reference/resolver.md:312
msgid ""
"The resolver will skip over versions of packages that are missing required "
"features. For example, if a package depends on version `^1` of [`regex`]"
"(https://crates.io/crates/regex) with the [`perf` feature](https://github."
"com/rust-lang/regex/blob/1.3.0/Cargo.toml#L56), then the oldest version it "
"can select is `1.3.0`, because versions prior to that did not contain the "
"`perf` feature. Similarly, if a feature is removed from a new release, then "
"packages that require that feature will be stuck on the older releases that "
"contain that feature. It is discouraged to remove features in a SemVer-"
"compatible release. Beware that optional dependencies also define an "
"implicit feature, so removing an optional dependency or making it non-"
"optional can cause problems, see [removing an optional dependency](semver."
"md#cargo-remove-opt-dep)."
msgstr ""

#: src/reference/resolver.md:332
msgid "Feature resolver version 2"
msgstr ""

#: src/reference/resolver.md:334
msgid ""
"When `resolver = \"2\"` is specified in `Cargo.toml` (see [resolver versions]"
"(#resolver-versions) below), a different feature resolver is used which uses "
"a different algorithm for unifying features. The version `\"1\"` resolver "
"will unify features for a package no matter where it is specified. The "
"version `\"2\"` resolver will avoid unifying features in the following "
"situations:"
msgstr ""

#: src/reference/resolver.md:341
msgid ""
"Features for target-specific dependencies are not enabled if the target is "
"not currently being built. For example:"
msgstr ""

#: src/reference/resolver.md:344
msgid ""
"```toml\n"
"[dependencies.common]\n"
"version = \"1.0\"\n"
"features = [\"f1\"]\n"
"\n"
"[target.'cfg(windows)'.dependencies.common]\n"
"version = \"1.0\"\n"
"features = [\"f2\"]\n"
"```"
msgstr ""

#: src/reference/resolver.md:354
msgid ""
"When building this example for a non-Windows platform, the `f2` feature will "
"_not_ be enabled."
msgstr ""

#: src/reference/resolver.md:357
msgid ""
"Features enabled on [build-dependencies](specifying-dependencies.md#build-"
"dependencies) or proc-macros will not be unified when those same "
"dependencies are used as a normal dependency. For example:"
msgstr ""

#: src/reference/resolver.md:360
msgid ""
"```toml\n"
"[dependencies]\n"
"log = \"0.4\"\n"
"\n"
"[build-dependencies]\n"
"log = {version = \"0.4\", features=['std']}\n"
"```"
msgstr ""

#: src/reference/resolver.md:368
msgid ""
"When building the build script, the `log` crate will be built with the `std` "
"feature. When building the library of your package, it will not enable the "
"feature."
msgstr ""

#: src/reference/resolver.md:372
msgid ""
"Features enabled on [dev-dependencies](specifying-dependencies."
"md#development-dependencies) will not be unified when those same "
"dependencies are used as a normal dependency, unless those dev-dependencies "
"are currently being built. For example:"
msgstr ""

#: src/reference/resolver.md:376
msgid ""
"```toml\n"
"[dependencies]\n"
"serde = {version = \"1.0\", default-features = false}\n"
"\n"
"[dev-dependencies]\n"
"serde = {version = \"1.0\", features = [\"std\"]}\n"
"```"
msgstr ""

#: src/reference/resolver.md:384
msgid ""
"In this example, the library will normally link against `serde` without the "
"`std` feature. However, when built as a test or example, it will include the "
"`std` feature. For example, `cargo test` or `cargo build --all-targets` will "
"unify these features. Note that dev-dependencies in dependencies are always "
"ignored, this is only relevant for the top-level package or workspace "
"members."
msgstr ""

#: src/reference/resolver.md:395
msgid "`links`"
msgstr ""

#: src/reference/resolver.md:397
msgid ""
"The [`links` field](manifest.md#the-links-field) is used to ensure only one "
"copy of a native library is linked into a binary. The resolver will attempt "
"to find a graph where there is only one instance of each `links` name. If it "
"is unable to find a graph that satisfies that constraint, it will return an "
"error."
msgstr ""

#: src/reference/resolver.md:402
msgid ""
"For example, it is an error if one package depends on [`libgit2-sys`]"
"(https://crates.io/crates/libgit2-sys) version `0.11` and another depends on "
"`0.12`, because Cargo is unable to unify those, but they both link to the "
"`git2` native library. Due to this requirement, it is encouraged to be very "
"careful when making SemVer-incompatible releases with the `links` field if "
"your library is in common use."
msgstr ""

#: src/reference/resolver.md:411
msgid "Yanked versions"
msgstr ""

#: src/reference/resolver.md:413
msgid ""
"[Yanked releases](publishing.md#cargo-yank) are those that are marked that "
"they should not be used. When the resolver is building the graph, it will "
"ignore all yanked releases unless they already exist in the `Cargo.lock` "
"file or are explicitly requested by the [`--precise`](../commands/cargo-"
"update.md#option-cargo-update---precise) flag of `cargo update` (nightly "
"only)."
msgstr ""

#: src/reference/resolver.md:421
msgid "Dependency updates"
msgstr ""

#: src/reference/resolver.md:423
msgid ""
"Dependency resolution is automatically performed by all Cargo commands that "
"need to know about the dependency graph. For example, [`cargo build`](../"
"commands/cargo-build.md) will run the resolver to discover all the "
"dependencies to build. After the first time it runs, the result is stored in "
"the `Cargo.lock` file. Subsequent commands will run the resolver, keeping "
"dependencies locked to the versions in `Cargo.lock` _if it can_."
msgstr ""

#: src/reference/resolver.md:430
msgid ""
"If the dependency list in `Cargo.toml` has been modified, for example "
"changing the version of a dependency from `1.0` to `2.0`, then the resolver "
"will select a new version for that dependency that matches the new "
"requirements. If that new dependency introduces new requirements, those new "
"requirements may also trigger additional updates. The `Cargo.lock` file will "
"be updated with the new result. The `--locked` or `--frozen` flags can be "
"used to change this behavior to prevent automatic updates when requirements "
"change, and return an error instead."
msgstr ""

#: src/reference/resolver.md:439
msgid ""
"[`cargo update`](../commands/cargo-update.md) can be used to update the "
"entries in `Cargo.lock` when new versions are published. Without any "
"options, it will attempt to update all packages in the lock file. The `-p` "
"flag can be used to target the update for a specific package, and other "
"flags such as `--recursive` or `--precise` can be used to control how "
"versions are selected."
msgstr ""

#: src/reference/resolver.md:448
msgid "Overrides"
msgstr ""

#: src/reference/resolver.md:450
msgid ""
"Cargo has several mechanisms to override dependencies within the graph. The "
"[Overriding Dependencies](overriding-dependencies.md) chapter goes into "
"detail on how to use overrides. The overrides appear as an overlay to a "
"registry, replacing the patched version with the new entry. Otherwise, "
"resolution is performed like normal."
msgstr ""

#: src/reference/resolver.md:457
msgid "Dependency kinds"
msgstr ""

#: src/reference/resolver.md:459
msgid ""
"There are three kinds of dependencies in a package: normal, [build]"
"(specifying-dependencies.md#build-dependencies), and [dev](specifying-"
"dependencies.md#development-dependencies). For the most part these are all "
"treated the same from the perspective of the resolver. One difference is "
"that dev-dependencies for non-workspace members are always ignored, and do "
"not influence resolution."
msgstr ""

#: src/reference/resolver.md:464
msgid ""
"[Platform-specific dependencies](specifying-dependencies.md#platform-"
"specific-dependencies) with the `[target]` table are resolved as-if all "
"platforms are enabled. In other words, the resolver ignores the platform or "
"`cfg` expression."
msgstr ""

#: src/reference/resolver.md:472
msgid "dev-dependency cycles"
msgstr ""

#: src/reference/resolver.md:474
msgid ""
"Usually the resolver does not allow cycles in the graph, but it does allow "
"them for [dev-dependencies](specifying-dependencies.md#development-"
"dependencies). For example, project \"foo\" has a dev-dependency on \"bar\", "
"which has a normal dependency on \"foo\" (usually as a \"path\" dependency). "
"This is allowed because there isn't really a cycle from the perspective of "
"the build artifacts. In this example, the \"foo\" library is built (which "
"does not need \"bar\" because \"bar\" is only used for tests), and then "
"\"bar\" can be built depending on \"foo\", then the \"foo\" tests can be "
"built linking to \"bar\"."
msgstr ""

#: src/reference/resolver.md:483
msgid ""
"Beware that this can lead to confusing errors. In the case of building "
"library unit tests, there are actually two copies of the library linked into "
"the final test binary: the one that was linked with \"bar\", and the one "
"built that contains the unit tests. Similar to the issues highlighted in the "
"[Version-incompatibility hazards](#version-incompatibility-hazards) section, "
"the types between the two are not compatible. Be careful when exposing types "
"of \"foo\" from \"bar\" in this situation, since the \"foo\" unit tests "
"won't treat them the same as the local types."
msgstr ""

#: src/reference/resolver.md:492
msgid ""
"If possible, try to split your package into multiple packages and "
"restructure it so that it remains strictly acyclic."
msgstr ""

#: src/reference/resolver.md:495
msgid "Resolver versions"
msgstr ""

#: src/reference/resolver.md:497
msgid ""
"Different resolver behavior can be specified through the resolver version in "
"`Cargo.toml` like this:"
msgstr ""

#: src/reference/resolver.md:500
msgid ""
"```toml\n"
"[package]\n"
"name = \"my-package\"\n"
"version = \"1.0.0\"\n"
"resolver = \"2\"\n"
"```"
msgstr ""

#: src/reference/resolver.md:506
msgid "`\"1\"` (default)"
msgstr ""

#: src/reference/resolver.md:507
msgid ""
"`\"2\"` ([`edition = \"2021\"`](manifest.md#the-edition-field) default): "
"Introduces changes in [feature unification](#features). See the [features "
"chapter](features.md#feature-resolver-version-2) for more details."
msgstr ""

#: src/reference/resolver.md:510
msgid ""
"`\"3\"` ([`edition = \"2024\"`](manifest.md#the-edition-field) default, "
"requires Rust 1.84+): Change the default for [`resolver.incompatible-rust-"
"versions`](config.md#resolverincompatible-rust-versions) from `allow` to "
"`fallback`"
msgstr ""

#: src/reference/resolver.md:512
msgid ""
"The resolver is a global option that affects the entire workspace. The "
"`resolver` version in dependencies is ignored, only the value in the top-"
"level package will be used. If using a [virtual workspace](workspaces."
"md#virtual-workspace), the version should be specified in the `[workspace]` "
"table, for example:"
msgstr ""

#: src/reference/resolver.md:517
msgid ""
"```toml\n"
"[workspace]\n"
"members = [\"member1\", \"member2\"]\n"
"resolver = \"2\"\n"
"```"
msgstr ""

#: src/reference/resolver.md:523
msgid "**MSRV:** Requires 1.51+"
msgstr ""

#: src/reference/resolver.md:528
msgid "Recommendations"
msgstr ""

#: src/reference/resolver.md:530
msgid ""
"The following are some recommendations for setting the version within your "
"package, and for specifying dependency requirements. These are general "
"guidelines that should apply to common situations, but of course some "
"situations may require specifying unusual requirements."
msgstr ""

#: src/reference/resolver.md:535
msgid ""
"Follow the [SemVer guidelines](semver.md) when deciding how to update your "
"version number, and whether or not you will need to make a SemVer-"
"incompatible version change."
msgstr ""

#: src/reference/resolver.md:538
msgid ""
"Use caret requirements for dependencies, such as `\"1.2.3\"`, for most "
"situations. This ensures that the resolver can be maximally flexible in "
"choosing a version while maintaining build compatibility."
msgstr ""

#: src/reference/resolver.md:541
msgid ""
"Specify all three components with the version you are currently using. This "
"helps set the minimum version that will be used, and ensures that other "
"users won't end up with an older version of the dependency that might be "
"missing something that your package requires."
msgstr ""

#: src/reference/resolver.md:545
msgid ""
"Avoid `*` requirements, as they are not allowed on [crates.io](https://"
"crates.io/), and they can pull in SemVer-breaking changes during a normal "
"`cargo update`."
msgstr ""

#: src/reference/resolver.md:547
msgid ""
"Avoid overly broad version requirements. For example, `>=2.0.0` can pull in "
"any SemVer-incompatible version, like version `5.0.0`, which can result in "
"broken builds in the future."
msgstr ""

#: src/reference/resolver.md:550
msgid ""
"Avoid overly narrow version requirements if possible. For example, if you "
"specify a tilde requirement like `bar=\"~1.3\"`, and another package "
"specifies a requirement of `bar=\"1.4\"`, this will fail to resolve, even "
"though minor releases should be compatible."
msgstr ""

#: src/reference/resolver.md:554
msgid ""
"Try to keep the dependency versions up-to-date with the actual minimum "
"versions that your library requires. For example, if you have a requirement "
"of `bar=\"1.0.12\"`, and then in a future release you start using new "
"features added in the `1.1.0` release of \"bar\", update your dependency "
"requirement to `bar=\"1.1.0\"`."
msgstr ""

#: src/reference/resolver.md:560
msgid ""
"If you fail to do this, it may not be immediately obvious because Cargo can "
"opportunistically choose the newest version when you run a blanket `cargo "
"update`. However, if another user depends on your library, and runs `cargo "
"update your-library`, it will _not_ automatically update \"bar\" if it is "
"locked in their `Cargo.lock`. It will only update \"bar\" in that situation "
"if the dependency declaration is also updated. Failure to do so can cause "
"confusing build errors for the user using `cargo update your-library`."
msgstr ""

#: src/reference/resolver.md:567
msgid ""
"If two packages are tightly coupled, then an `=` dependency requirement may "
"help ensure that they stay in sync. For example, a library with a companion "
"proc-macro library will sometimes make assumptions between the two libraries "
"that won't work well if the two are out of sync (and it is never expected to "
"use the two libraries independently). The parent library can use an `=` "
"requirement on the proc-macro, and re-export the macros for easy access."
msgstr ""

#: src/reference/resolver.md:573
msgid ""
"`0.0.x` versions can be used for packages that are permanently unstable."
msgstr ""

#: src/reference/resolver.md:575
msgid ""
"In general, the stricter you make the dependency requirements, the more "
"likely it will be for the resolver to fail. Conversely, if you use "
"requirements that are too loose, it may be possible for new versions to be "
"published that will break the build."
msgstr ""

#: src/reference/resolver.md:583
msgid "Troubleshooting"
msgstr ""

#: src/reference/resolver.md:585
msgid ""
"The following illustrates some problems you may experience, and some "
"possible solutions."
msgstr ""

#: src/reference/resolver.md:588
msgid "Why was a dependency included?"
msgstr ""

#: src/reference/resolver.md:590
msgid ""
"Say you see dependency `rand` in the `cargo check` output but don't think "
"it's needed and want to understand why it's being pulled in."
msgstr ""

#: src/reference/resolver.md:592
msgid "You can run"
msgstr ""

#: src/reference/resolver.md:602
msgid "Why was that feature on this dependency enabled?"
msgstr ""

#: src/reference/resolver.md:604
msgid ""
"You might identify that it was an activated feature that caused `rand` to "
"show up.  **To figure out which package activated the feature, you can add "
"the `--edges features`**"
msgstr ""

#: src/reference/resolver.md:614
msgid "Unexpected dependency duplication"
msgstr ""

#: src/reference/resolver.md:616
msgid "You see multiple instances of `rand` when you run"
msgstr ""

#: src/reference/resolver.md:626
msgid ""
"The resolver algorithm has converged on a solution that includes two copies "
"of a dependency when one would suffice. For example:"
msgstr ""

#: src/reference/resolver.md:629
msgid ""
"```toml\n"
"# Package A\n"
"[dependencies]\n"
"rand = \"0.7\"\n"
"\n"
"# Package B\n"
"[dependencies]\n"
"rand = \">=0.6\"  # note: open requirements such as this are discouraged\n"
"```"
msgstr ""

#: src/reference/resolver.md:639
msgid ""
"In this example, Cargo may build two copies of the `rand` crate, even though "
"a single copy at version `0.7.3` would meet all requirements. This is "
"because the resolver's algorithm favors building the latest available "
"version of `rand` for Package B, which is `0.8.5` at the time of this "
"writing, and that is incompatible with Package A's specification. The "
"resolver's algorithm does not currently attempt to \"deduplicate\" in this "
"situation."
msgstr ""

#: src/reference/resolver.md:646
msgid ""
"The use of open-ended version requirements like `>=0.6` is discouraged in "
"Cargo. But, if you run into this situation, the [`cargo update`](../commands/"
"cargo-update.md) command with the `--precise` flag can be used to manually "
"remove such duplications."
msgstr ""

#: src/reference/resolver.md:652
msgid "Why wasn't a newer version selected?"
msgstr ""

#: src/reference/resolver.md:654
msgid ""
"Say you noticed that the latest version of a dependency wasn't selected when "
"you ran:"
msgstr ""

#: src/reference/resolver.md:658
msgid "You can enable some extra logging to see why this happened:"
msgstr ""

#: src/reference/resolver.md:662
msgid "**Note:** Cargo log targets and levels may change over time."
msgstr ""

#: src/reference/resolver.md:664
msgid "SemVer-breaking patch release breaks the build"
msgstr ""

#: src/reference/resolver.md:666
msgid ""
"Sometimes a project may inadvertently publish a point release with a SemVer-"
"breaking change. When users update with `cargo update`, they will pick up "
"this new release, and then their build may break. In this situation, it is "
"recommended that the project should [yank](publishing.md#cargo-yank) the "
"release, and either remove the SemVer-breaking change, or publish it as a "
"new SemVer-major version increase."
msgstr ""

#: src/reference/resolver.md:672
msgid ""
"If the change happened in a third-party project, if possible try to "
"(politely!) work with the project to resolve the issue."
msgstr ""

#: src/reference/resolver.md:675
msgid ""
"While waiting for the release to be yanked, some workarounds depend on the "
"circumstances:"
msgstr ""

#: src/reference/resolver.md:678
msgid ""
"If your project is the end product (such as a binary executable), just avoid "
"updating the offending package in `Cargo.lock`. This can be done with the `--"
"precise` flag in [`cargo update`](../commands/cargo-update.md)."
msgstr ""

#: src/reference/resolver.md:681
msgid ""
"If you publish a binary on [crates.io](https://crates.io/), then you can "
"temporarily add an `=` requirement to force the dependency to a specific "
"good version."
msgstr ""

#: src/reference/resolver.md:683
msgid ""
"Binary projects can alternatively recommend users to use the `--locked` flag "
"with [`cargo install`](../commands/cargo-install.md) to use the original "
"`Cargo.lock` that contains the known good version."
msgstr ""

#: src/reference/resolver.md:686
msgid ""
"Libraries may also consider publishing a temporary new release with stricter "
"requirements that avoid the troublesome dependency. You may want to consider "
"using range requirements (instead of `=`) to avoid overly-strict "
"requirements that may conflict with other packages using the same "
"dependency. Once the problem has been resolved, you can publish another "
"point release that relaxes the dependency back to a caret requirement."
msgstr ""

#: src/reference/resolver.md:692
msgid ""
"If it looks like the third-party project is unable or unwilling to yank the "
"release, then one option is to update your code to be compatible with the "
"changes, and update the dependency requirement to set the minimum version to "
"the new release. You will also need to consider if this is a SemVer-breaking "
"change of your own library, for example if it exposes types from the "
"dependency."
msgstr ""
