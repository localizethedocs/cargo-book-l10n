msgid ""
msgstr ""
"Project-Id-Version: The Cargo Book\n"
"POT-Creation-Date: 2026-01-24T08:43:08Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/reference/manifest.md:1
msgid "The Manifest Format"
msgstr ""

#: src/reference/manifest.md:3
msgid ""
"The `Cargo.toml` file for each package is called its _manifest_. Every "
"manifest file consists of one or more sections."
msgstr ""

#: src/reference/manifest.md:6
msgid "The `[package]` section"
msgstr ""

#: src/reference/manifest.md:8
msgid "The first section in a `Cargo.toml` is `[package]`."
msgstr ""

#: src/reference/manifest.md:10
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\" # the name of the package\n"
"version = \"0.1.0\"    # the current version, obeying semver\n"
"authors = [\"Alice <a@example.com>\", \"Bob <b@example.com>\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:17
msgid "The `name` field"
msgstr ""

#: src/reference/manifest.md:19
msgid ""
"The package name is an identifier used to refer to the package. It is used "
"when listed as a dependency in another package, and as the default name of "
"inferred lib and bin targets."
msgstr ""

#: src/reference/manifest.md:23
msgid ""
"The name must not be empty, use only [alphanumeric](../../std/primitive.char."
"html#method.is_alphanumeric) characters or `-` or `_`. Note that [`cargo "
"new`](../commands/cargo-new.md) and [`cargo init`](../commands/cargo-init."
"md) impose some additional restrictions on the package name, such as "
"enforcing that it is a valid Rust identifier and not a keyword. [crates.io]"
"(https://crates.io/) imposes even more restrictions, such as enforcing only "
"ASCII characters, not a reserved name, not a special Windows name such as "
"\"nul\", is not too long, etc."
msgstr ""

#: src/reference/manifest.md:32
msgid "The `version` field"
msgstr ""

#: src/reference/manifest.md:34
msgid ""
"Cargo bakes in the concept of [Semantic Versioning](https://semver.org/), so "
"make sure you follow some basic rules:"
msgstr ""

#: src/reference/manifest.md:37
msgid ""
"Before you reach 1.0.0, anything goes, but if you make breaking changes, "
"increment the minor version. In Rust, breaking changes include adding fields "
"to structs or variants to enums."
msgstr ""

#: src/reference/manifest.md:40
msgid ""
"After 1.0.0, only make breaking changes when you increment the major "
"version. Don’t break the build."
msgstr ""

#: src/reference/manifest.md:42
msgid ""
"After 1.0.0, don’t add any new public API (no new `pub` anything) in patch-"
"level versions. Always increment the minor version if you add any new `pub` "
"structs, traits, fields, types, functions, methods or anything else."
msgstr ""

#: src/reference/manifest.md:45
msgid ""
"Use version numbers with three numeric parts such as 1.0.0 rather than 1.0."
msgstr ""

#: src/reference/manifest.md:47
msgid "The `authors` field (optional)"
msgstr ""

#: src/reference/manifest.md:49
msgid ""
"The `authors` field lists people or organizations that are considered the "
"\"authors\" of the package. The exact meaning is open to interpretation — it "
"may list the original or primary authors, current maintainers, or owners of "
"the package. These names will be listed on the crate's page on [crates.io]"
"(https://crates.io/). An optional email address may be included within "
"angled brackets at the end of each author."
msgstr ""

#: src/reference/manifest.md:56
msgid "The `edition` field (optional)"
msgstr ""

#: src/reference/manifest.md:58
msgid ""
"You can opt in to a specific Rust Edition for your package with the "
"`edition` key in `Cargo.toml`. If you don't specify the edition, it will "
"default to 2015."
msgstr ""

#: src/reference/manifest.md:68
msgid ""
"The `edition` key affects which edition your package is compiled with. Cargo "
"will always generate packages via [`cargo new`](../commands/cargo-new.md) "
"with the `edition` key set to the latest edition. Setting the `edition` key "
"in `[package]` will affect all targets/crates in the package, including test "
"suites, benchmarks, binaries, examples, etc."
msgstr ""

#: src/reference/manifest.md:74
msgid "The `build` field (optional)"
msgstr ""

#: src/reference/manifest.md:76
msgid ""
"This field specifies a file in the package root which is a [build script]"
"(build-scripts.md) for building native code. More information can be found "
"in the [build script guide](build-scripts.md)."
msgstr ""

#: src/reference/manifest.md:82
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"build = \"build.rs\"\n"
"```"
msgstr ""

#: src/reference/manifest.md:88
msgid "The `links` field (optional)"
msgstr ""

#: src/reference/manifest.md:90
msgid ""
"This field specifies the name of a native library that is being linked to. "
"More information can be found in the [`links`](build-scripts.md#the-links-"
"manifest-key) section of the build script guide."
msgstr ""

#: src/reference/manifest.md:96
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"links = \"foo\"\n"
"build = \"build.rs\"\n"
"```"
msgstr ""

#: src/reference/manifest.md:103
msgid "The `documentation` field (optional)"
msgstr ""

#: src/reference/manifest.md:105
msgid ""
"This field specifies a URL to a website hosting the crate's documentation. "
"If no URL is specified in the manifest file, [crates.io](https://crates.io/) "
"will automatically link your crate to the corresponding [docs.rs](https://"
"docs.rs/) page."
msgstr ""

#: src/reference/manifest.md:109
msgid ""
"Documentation links from specific hosts are blacklisted. Hosts are added to "
"the blacklist if they are known to not be hosting documentation and are "
"possibly of malicious intent e.g., ad tracking networks. URLs from the "
"following hosts are blacklisted:"
msgstr ""

#: src/reference/manifest.md:114
msgid "rust-ci.org"
msgstr ""

#: src/reference/manifest.md:116
msgid ""
"Documentation URLs from blacklisted hosts will not appear on crates.io, and "
"may be replaced by docs.rs links."
msgstr ""

#: src/reference/manifest.md:122
msgid "The `exclude` and `include` fields (optional)"
msgstr ""

#: src/reference/manifest.md:124
msgid ""
"You can explicitly specify that a set of file patterns should be ignored or "
"included for the purposes of packaging. The patterns specified in the "
"`exclude` field identify a set of files that are not included, and the "
"patterns in `include` specify files that are explicitly included."
msgstr ""

#: src/reference/manifest.md:129
msgid ""
"The patterns should be [gitignore](https://git-scm.com/docs/gitignore)\\-"
"style patterns. Briefly:"
msgstr ""

#: src/reference/manifest.md:131
msgid ""
"`foo` matches any file or directory with the name `foo` anywhere in the "
"package. This is equivalent to the pattern `**/foo`."
msgstr ""

#: src/reference/manifest.md:133
msgid ""
"`/foo` matches any file or directory with the name `foo` only in the root of "
"the package."
msgstr ""

#: src/reference/manifest.md:135
msgid ""
"`foo/` matches any _directory_ with the name `foo` anywhere in the package."
msgstr ""

#: src/reference/manifest.md:136
msgid "Common glob patterns like `*`, `?`, and `[]` are supported:"
msgstr ""

#: src/reference/manifest.md:137
msgid ""
"`*` matches zero or more characters except `/`.  For example, `*.html` "
"matches any file or directory with the `.html` extension anywhere in the "
"package."
msgstr ""

#: src/reference/manifest.md:140
msgid ""
"`?` matches any character except `/`. For example, `foo?` matches `food`, "
"but not `foo`."
msgstr ""

#: src/reference/manifest.md:142
msgid ""
"`[]` allows for matching a range of characters. For example, `[ab]` matches "
"either `a` or `b`. `[a-z]` matches letters a through z."
msgstr ""

#: src/reference/manifest.md:144
msgid ""
"`**/` prefix matches in any directory. For example, `**/foo/bar` matches the "
"file or directory `bar` anywhere that is directly under directory `foo`."
msgstr ""

#: src/reference/manifest.md:146
msgid ""
"`/**` suffix matches everything inside. For example, `foo/**` matches all "
"files inside directory `foo`, including all files in subdirectories below "
"`foo`."
msgstr ""

#: src/reference/manifest.md:149
msgid ""
"`/**/` matches zero or more directories. For example, `a/**/b` matches `a/"
"b`, `a/x/b`, `a/x/y/b`, and so on."
msgstr ""

#: src/reference/manifest.md:151
msgid ""
"`!` prefix negates a pattern. For example, a pattern of `src/**.rs` and `!"
"foo.rs` would match all files with the `.rs` extension inside the `src` "
"directory, except for any file named `foo.rs`."
msgstr ""

#: src/reference/manifest.md:155
msgid ""
"If git is being used for a package, the `exclude` field will be seeded with "
"the `gitignore` settings from the repository."
msgstr ""

#: src/reference/manifest.md:158
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"exclude = [\"build/**/*.o\", \"doc/**/*.html\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:164
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"include = [\"src/**/*\", \"Cargo.toml\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:170
msgid ""
"The options are mutually exclusive: setting `include` will override an "
"`exclude`. Note that `include` must be an exhaustive list of files as "
"otherwise necessary source files may not be included. The package's `Cargo."
"toml` is automatically included."
msgstr ""

#: src/reference/manifest.md:175
msgid ""
"The include/exclude list is also used for change tracking in some "
"situations. For targets built with `rustdoc`, it is used to determine the "
"list of files to track to determine if the target should be rebuilt. If the "
"package has a [build script](build-scripts.md) that does not emit any `rerun-"
"if-*` directives, then the include/exclude list is used for tracking if the "
"build script should be re-run if any of those files change."
msgstr ""

#: src/reference/manifest.md:184
msgid "The `publish`  field (optional)"
msgstr ""

#: src/reference/manifest.md:186
msgid ""
"The `publish` field can be used to prevent a package from being published to "
"a package registry (like _crates.io_) by mistake, for instance to keep a "
"package private in a company."
msgstr ""

#: src/reference/manifest.md:196
msgid ""
"The value may also be an array of strings which are registry names that are "
"allowed to be published to."
msgstr ""

#: src/reference/manifest.md:199
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"publish = [\"some-registry-name\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:205
msgid "The `workspace`  field (optional)"
msgstr ""

#: src/reference/manifest.md:207
msgid ""
"The `workspace` field can be used to configure the workspace that this "
"package will be a member of. If not specified this will be inferred as the "
"first Cargo.toml with `[workspace]` upwards in the filesystem."
msgstr ""

#: src/reference/manifest.md:211
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"workspace = \"path/to/workspace/root\"\n"
"```"
msgstr ""

#: src/reference/manifest.md:217
msgid ""
"For more information, see the documentation for the workspace table below."
msgstr ""

#: src/reference/manifest.md:219
msgid "Package metadata"
msgstr ""

#: src/reference/manifest.md:221
msgid ""
"There are a number of optional metadata fields also accepted under the "
"`[package]` section:"
msgstr ""

#: src/reference/manifest.md:224
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"\n"
"# A short blurb about the package. This is not rendered in any format when\n"
"# uploaded to crates.io (aka this is not markdown).\n"
"description = \"...\"\n"
"\n"
"# These URLs point to more information about the package. These are\n"
"# intended to be webviews of the relevant data, not necessarily compatible\n"
"# with VCS tools and the like.\n"
"documentation = \"...\"\n"
"homepage = \"...\"\n"
"repository = \"...\"\n"
"\n"
"# This points to a file under the package root (relative to this `Cargo."
"toml`).\n"
"# The contents of this file are stored and indexed in the registry.\n"
"# crates.io will render this file and place the result on the crate's page.\n"
"readme = \"...\"\n"
"\n"
"# This is a list of up to five keywords that describe this crate. Keywords\n"
"# are searchable on crates.io, and you may choose any words that would\n"
"# help someone find this crate.\n"
"keywords = [\"...\", \"...\"]\n"
"\n"
"# This is a list of up to five categories where this crate would fit.\n"
"# Categories are a fixed list available at crates.io/category_slugs, and\n"
"# they must match exactly.\n"
"categories = [\"...\", \"...\"]\n"
"\n"
"# This is an SPDX 2.1 license expression for this package. Currently\n"
"# crates.io will validate the license provided against a whitelist of\n"
"# known license and exception identifiers from the SPDX license list\n"
"# 2.4. Parentheses are not currently supported.\n"
"#\n"
"# Multiple licenses can be separated with a `/`, although that usage\n"
"# is deprecated. Instead, use a license expression with AND and OR\n"
"# operators to get more explicit semantics.\n"
"license = \"...\"\n"
"\n"
"# If a package is using a nonstandard license, then this key may be "
"specified in\n"
"# lieu of the above key and must point to a file relative to this manifest\n"
"# (similar to the readme key).\n"
"license-file = \"...\"\n"
"\n"
"# Optional specification of badges to be displayed on crates.io.\n"
"#\n"
"# - The badges pertaining to build status that are currently available are\n"
"#   Appveyor, CircleCI, Cirrus CI, GitLab, Azure DevOps and TravisCI.\n"
"# - Available badges pertaining to code test coverage are Codecov and\n"
"#   Coveralls.\n"
"# - There are also maintenance-related badges based on isitmaintained.com\n"
"#   which state the issue resolution time, percent of open issues, and "
"future\n"
"#   maintenance intentions.\n"
"#\n"
"# If a `repository` key is required, this refers to a repository in\n"
"# `user/repo` format.\n"
"[badges]\n"
"\n"
"# Appveyor: `repository` is required. `branch` is optional; default is "
"`master`\n"
"# `service` is optional; valid values are `github` (default), `bitbucket`, "
"and\n"
"# `gitlab`; `id` is optional; you can specify the appveyor project id if "
"you\n"
"# want to use that instead. `project_name` is optional; use when the "
"repository\n"
"# name differs from the appveyor project name.\n"
"appveyor = { repository = \"...\", branch = \"master\", service = "
"\"github\" }\n"
"\n"
"# Circle CI: `repository` is required. `branch` is optional; default is "
"`master`\n"
"circle-ci = { repository = \"...\", branch = \"master\" }\n"
"\n"
"# Cirrus CI: `repository` is required. `branch` is optional; default is "
"`master`\n"
"cirrus-ci = { repository = \"...\", branch = \"master\" }\n"
"\n"
"# GitLab: `repository` is required. `branch` is optional; default is "
"`master`\n"
"gitlab = { repository = \"...\", branch = \"master\" }\n"
"\n"
"# Azure DevOps: `project` is required. `pipeline` is required. `build` is "
"optional; default is `1`\n"
"# Note: project = `organization/project`, pipeline = `name_of_pipeline`, "
"build = `definitionId`\n"
"azure-devops = { project = \"...\", pipeline = \"...\", build=\"2\" }\n"
"\n"
"# Travis CI: `repository` in format \"<user>/<project>\" is required.\n"
"# `branch` is optional; default is `master`\n"
"travis-ci = { repository = \"...\", branch = \"master\" }\n"
"\n"
"# Codecov: `repository` is required. `branch` is optional; default is "
"`master`\n"
"# `service` is optional; valid values are `github` (default), `bitbucket`, "
"and\n"
"# `gitlab`.\n"
"codecov = { repository = \"...\", branch = \"master\", service = "
"\"github\" }\n"
"\n"
"# Coveralls: `repository` is required. `branch` is optional; default is "
"`master`\n"
"# `service` is optional; valid values are `github` (default) and "
"`bitbucket`.\n"
"coveralls = { repository = \"...\", branch = \"master\", service = "
"\"github\" }\n"
"\n"
"# Is it maintained resolution time: `repository` is required.\n"
"is-it-maintained-issue-resolution = { repository = \"...\" }\n"
"\n"
"# Is it maintained percentage of open issues: `repository` is required.\n"
"is-it-maintained-open-issues = { repository = \"...\" }\n"
"\n"
"# Maintenance: `status` is required. Available options are:\n"
"# - `actively-developed`: New features are being added and bugs are being "
"fixed.\n"
"# - `passively-maintained`: There are no plans for new features, but the "
"maintainer intends to\n"
"#   respond to issues that get filed.\n"
"# - `as-is`: The crate is feature complete, the maintainer does not intend "
"to continue working on\n"
"#   it or providing support, but it works for the purposes it was designed "
"for.\n"
"# - `experimental`: The author wants to share it with the community but is "
"not intending to meet\n"
"#   anyone's particular use case.\n"
"# - `looking-for-maintainer`: The current maintainer would like to transfer "
"the crate to someone\n"
"#   else.\n"
"# - `deprecated`: The maintainer does not recommend using this crate (the "
"description of the crate\n"
"#   can describe why, there could be a better solution available or there "
"could be problems with\n"
"#   the crate that the author does not want to fix).\n"
"# - `none`: Displays no badge on crates.io, since the maintainer has not "
"chosen to specify\n"
"#   their intentions, potential crate users will need to investigate on "
"their own.\n"
"maintenance = { status = \"...\" }\n"
"```"
msgstr ""

#: src/reference/manifest.md:340
msgid ""
"The [crates.io](https://crates.io) registry will render the description, "
"display the license, link to the three URLs and categorize by the keywords. "
"These keys provide useful information to users of the registry and also "
"influence the search ranking of a crate. It is highly discouraged to omit "
"everything in a published crate."
msgstr ""

#: src/reference/manifest.md:346
msgid ""
"SPDX 2.1 license expressions are documented [here](https://spdx.org/spdx-"
"specification-21-web-version#h.jxpfx0ykyb60). The current version of the "
"license list is available [here](https://spdx.org/licenses/), and version "
"2.4 is available [here](https://github.com/spdx/license-list-data/tree/v2.4)."
msgstr ""

#: src/reference/manifest.md:351
msgid "The `metadata` table (optional)"
msgstr ""

#: src/reference/manifest.md:353
msgid ""
"Cargo by default will warn about unused keys in `Cargo.toml` to assist in "
"detecting typos and such. The `package.metadata` table, however, is "
"completely ignored by Cargo and will not be warned about. This section can "
"be used for tools which would like to store package configuration in `Cargo."
"toml`. For example:"
msgstr ""

#: src/reference/manifest.md:359
msgid ""
"```toml\n"
"[package]\n"
"name = \"...\"\n"
"# ...\n"
"\n"
"# Metadata used when generating an Android APK, for example.\n"
"[package.metadata.android]\n"
"package-name = \"my-awesome-android-app\"\n"
"assets = \"path/to/static\"\n"
"```"
msgstr ""

#: src/reference/manifest.md:370
msgid "The `default-run` field"
msgstr ""

#: src/reference/manifest.md:372
msgid ""
"The `default-run` field in the `[package]` section of the manifest can be "
"used to specify a default binary picked by [`cargo run`](../commands/cargo-"
"run.md). For example, when there is both `src/bin/a.rs` and `src/bin/b.rs`:"
msgstr ""

#: src/reference/manifest.md:376
msgid ""
"```toml\n"
"[package]\n"
"default-run = \"a\"\n"
"```"
msgstr ""

#: src/reference/manifest.md:381
msgid "Dependency sections"
msgstr ""

#: src/reference/manifest.md:383
msgid ""
"See the [specifying dependencies page](specifying-dependencies.md) for "
"information on the `[dependencies]`, `[dev-dependencies]`, `[build-"
"dependencies]`, and target-specific `[target.*.dependencies]` sections."
msgstr ""

#: src/reference/manifest.md:387
msgid "The `[profile.*]` sections"
msgstr ""

#: src/reference/manifest.md:389
msgid ""
"Cargo supports custom configuration of how rustc is invoked through profiles "
"at the top level. Any manifest may declare a profile, but only the top level "
"package’s profiles are actually read. All dependencies’ profiles will be "
"overridden. This is done so the top-level package has control over how its "
"dependencies are compiled."
msgstr ""

#: src/reference/manifest.md:395
msgid ""
"There are four currently supported profile names, all of which have the same "
"configuration available to them. Listed below is the configuration "
"available, along with the defaults for each profile."
msgstr ""

#: src/reference/manifest.md:467
msgid "The `[features]` section"
msgstr ""

#: src/reference/manifest.md:469
msgid "Cargo supports features to allow expression of:"
msgstr ""

#: src/reference/manifest.md:471
msgid "conditional compilation options (usable through `cfg` attributes);"
msgstr ""

#: src/reference/manifest.md:472
msgid ""
"optional dependencies, which enhance a package, but are not required; and"
msgstr ""

#: src/reference/manifest.md:473
msgid ""
"clusters of optional dependencies, such as `postgres`, that would include "
"the `postgres` package, the `postgres-macros` package, and possibly other "
"packages (such as development-time mocking libraries, debugging tools, etc.)."
msgstr ""

#: src/reference/manifest.md:477
msgid ""
"A feature of a package is either an optional dependency, or a set of other "
"features. The format for specifying features is:"
msgstr ""

#: src/reference/manifest.md:480
msgid ""
"```toml\n"
"[package]\n"
"name = \"awesome\"\n"
"\n"
"[features]\n"
"# The default set of optional packages. Most people will want to use these\n"
"# packages, but they are strictly optional. Note that `session` is not a "
"package\n"
"# but rather another feature listed in this manifest.\n"
"default = [\"jquery\", \"uglifier\", \"session\"]\n"
"\n"
"# A feature with no dependencies is used mainly for conditional "
"compilation,\n"
"# like `#[cfg(feature = \"go-faster\")]`.\n"
"go-faster = []\n"
"\n"
"# The `secure-password` feature depends on the bcrypt package. This "
"aliasing\n"
"# will allow people to talk about the feature in a higher-level way and "
"allow\n"
"# this package to add more requirements to the feature in the future.\n"
"secure-password = [\"bcrypt\"]\n"
"\n"
"# Features can be used to reexport features of other packages. The "
"`session`\n"
"# feature of package `awesome` will ensure that the `session` feature of "
"the\n"
"# package `cookie` is also enabled.\n"
"session = [\"cookie/session\"]\n"
"\n"
"[dependencies]\n"
"# These packages are mandatory and form the core of this package’s "
"distribution.\n"
"cookie = \"1.2.0\"\n"
"oauth = \"1.1.0\"\n"
"route-recognizer = \"=2.1.0\"\n"
"\n"
"# A list of all of the optional dependencies, some of which are included in "
"the\n"
"# above `features`. They can be opted into by apps.\n"
"jquery = { version = \"1.0.2\", optional = true }\n"
"uglifier = { version = \"1.5.3\", optional = true }\n"
"bcrypt = { version = \"*\", optional = true }\n"
"civet = { version = \"*\", optional = true }\n"
"```"
msgstr ""

#: src/reference/manifest.md:518
msgid "To use the package `awesome`:"
msgstr ""

#: src/reference/manifest.md:520
msgid ""
"```toml\n"
"[dependencies.awesome]\n"
"version = \"1.3.5\"\n"
"default-features = false # do not include the default features, and "
"optionally\n"
"                         # cherry-pick individual features\n"
"features = [\"secure-password\", \"civet\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:528
msgid "Rules"
msgstr ""

#: src/reference/manifest.md:530
msgid "The usage of features is subject to a few rules:"
msgstr ""

#: src/reference/manifest.md:532
msgid ""
"Feature names must not conflict with other package names in the manifest. "
"This is because they are opted into via `features = [...]`, which only has a "
"single namespace."
msgstr ""

#: src/reference/manifest.md:535
msgid ""
"With the exception of the `default` feature, all features are opt-in. To opt "
"out of the default feature, use `default-features = false` and cherry-pick "
"individual features."
msgstr ""

#: src/reference/manifest.md:538
msgid "Feature groups are not allowed to cyclically depend on one another."
msgstr ""

#: src/reference/manifest.md:539
msgid "Dev-dependencies cannot be optional."
msgstr ""

#: src/reference/manifest.md:540
msgid "Features groups can only reference optional dependencies."
msgstr ""

#: src/reference/manifest.md:541
msgid ""
"When a feature is selected, Cargo will call `rustc` with `--cfg "
"feature=\"${feature_name}\"`. If a feature group is included, it and all of "
"its individual features will be included. This can be tested in code via "
"`#[cfg(feature = \"foo\")]`."
msgstr ""

#: src/reference/manifest.md:546
msgid ""
"Note that it is explicitly allowed for features to not actually activate any "
"optional dependencies. This allows packages to internally enable/disable "
"features without requiring a new dependency."
msgstr ""

#: src/reference/manifest.md:550
msgid "Usage in end products"
msgstr ""

#: src/reference/manifest.md:552
msgid ""
"One major use-case for this feature is specifying optional features in end-"
"products. For example, the Servo package may want to include optional "
"features that people can enable or disable when they build it."
msgstr ""

#: src/reference/manifest.md:556
msgid ""
"In that case, Servo will describe features in its `Cargo.toml` and they can "
"be enabled using command-line flags:"
msgstr ""

#: src/reference/manifest.md:559
msgid ""
"```console\n"
"$ cargo build --release --features \"shumway pdf\"\n"
"```"
msgstr ""

#: src/reference/manifest.md:563
msgid "Default features could be excluded using `--no-default-features`."
msgstr ""

#: src/reference/manifest.md:565
msgid "Usage in packages"
msgstr ""

#: src/reference/manifest.md:567
msgid ""
"In most cases, the concept of _optional dependency_ in a library is best "
"expressed as a separate package that the top-level application depends on."
msgstr ""

#: src/reference/manifest.md:570
msgid ""
"However, high-level packages, like Iron or Piston, may want the ability to "
"curate a number of packages for easy installation. The current Cargo system "
"allows them to curate a number of mandatory dependencies into a single "
"package for easy installation."
msgstr ""

#: src/reference/manifest.md:575
msgid ""
"In some cases, packages may want to provide additional curation for optional "
"dependencies:"
msgstr ""

#: src/reference/manifest.md:578
msgid ""
"grouping a number of low-level optional dependencies together into a single "
"high-level feature;"
msgstr ""

#: src/reference/manifest.md:580
msgid ""
"specifying packages that are recommended (or suggested) to be included by "
"users of the package; and"
msgstr ""

#: src/reference/manifest.md:582
msgid ""
"including a feature (like `secure-password` in the motivating example) that "
"will only work if an optional dependency is available, and would be "
"difficult to implement as a separate package (for example, it may be overly "
"difficult to design an IO package to be completely decoupled from OpenSSL, "
"with opt-in via the inclusion of a separate package)."
msgstr ""

#: src/reference/manifest.md:588
msgid ""
"In almost all cases, it is an antipattern to use these features outside of "
"high-level packages that are designed for curation. If a feature is "
"optional, it can almost certainly be expressed as a separate package."
msgstr ""

#: src/reference/manifest.md:592
msgid "The `[workspace]` section"
msgstr ""

#: src/reference/manifest.md:594
msgid ""
"Packages can define a workspace which is a set of crates that will all share "
"the same `Cargo.lock` and output directory. The `[workspace]` table can be "
"defined as:"
msgstr ""

#: src/reference/manifest.md:598
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"# Optional key, inferred from path dependencies if not present.\n"
"# Additional non-path dependencies that should be included must be given "
"here.\n"
"# In particular, for a virtual manifest, all members have to be listed.\n"
"members = [\"path/to/member1\", \"path/to/member2\", \"path/to/member3/*\"]\n"
"\n"
"# Optional key, empty if not present.\n"
"exclude = [\"path1\", \"path/to/dir2\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:610
msgid ""
"Workspaces were added to Cargo as part of [RFC 1525](https://github.com/rust-"
"lang/rfcs/blob/master/text/1525-cargo-workspace.md) and have a number of "
"properties:"
msgstr ""

#: src/reference/manifest.md:613
msgid ""
"A workspace can contain multiple crates where one of them is the _root "
"crate_."
msgstr ""

#: src/reference/manifest.md:614
msgid ""
"The _root crate_'s `Cargo.toml` contains the `[workspace]` table, but is not "
"required to have other configuration."
msgstr ""

#: src/reference/manifest.md:616
msgid ""
"Whenever any crate in the workspace is compiled, output is placed in the "
"_workspace root_ (i.e., next to the _root crate_'s `Cargo.toml`)."
msgstr ""

#: src/reference/manifest.md:618
msgid ""
"The lock file for all crates in the workspace resides in the _workspace "
"root_."
msgstr ""

#: src/reference/manifest.md:619
msgid ""
"The `[patch]`, `[replace]` and `[profile.*]` sections in `Cargo.toml` are "
"only recognized in the _root crate_'s manifest, and ignored in member "
"crates' manifests."
msgstr ""

#: src/reference/manifest.md:625
msgid ""
"The _root crate_ of a workspace, indicated by the presence of `[workspace]` "
"in its manifest, is responsible for defining the entire workspace. All "
"`path` dependencies residing in the workspace directory become members. You "
"can add additional packages to the workspace by listing them in the "
"`members` key. Note that members of the workspaces listed explicitly will "
"also have their path dependencies included in the workspace. Sometimes a "
"package may have a lot of workspace members and it can be onerous to keep up "
"to date. The `members` list can also use [globs](https://docs.rs/glob/0.2.11/"
"glob/struct.Pattern.html) to match multiple paths. Finally, the `exclude` "
"key can be used to blacklist paths from being included in a workspace. This "
"can be useful if some path dependencies aren't desired to be in the "
"workspace at all."
msgstr ""

#: src/reference/manifest.md:637
msgid ""
"The `package.workspace` manifest key (described above) is used in member "
"crates to point at a workspace's root crate. If this key is omitted then it "
"is inferred to be the first crate whose manifest contains `[workspace]` "
"upwards in the filesystem."
msgstr ""

#: src/reference/manifest.md:642
msgid ""
"A crate may either specify `package.workspace` or specify `[workspace]`. "
"That is, a crate cannot both be a root crate in a workspace (contain "
"`[workspace]`) and also be a member crate of another workspace (contain "
"`package.workspace`)."
msgstr ""

#: src/reference/manifest.md:646
msgid ""
"Most of the time workspaces will not need to be dealt with as [`cargo new`]"
"(../commands/cargo-new.md) and [`cargo init`](../commands/cargo-init.md) "
"will handle workspace configuration automatically."
msgstr ""

#: src/reference/manifest.md:651
msgid "Virtual Manifest"
msgstr ""

#: src/reference/manifest.md:653
msgid ""
"In workspace manifests, if the `package` table is present, the workspace "
"root crate will be treated as a normal package, as well as a workspace. If "
"the `package` table is not present in a workspace manifest, it is called a "
"_virtual manifest_."
msgstr ""

#: src/reference/manifest.md:658
msgid "Package selection"
msgstr ""

#: src/reference/manifest.md:660
msgid ""
"In a workspace, package-related cargo commands like [`cargo build`](../"
"commands/cargo-build.md) apply to packages selected by `-p` / `--package` or "
"`--workspace` command-line parameters. When neither is specified, the "
"optional `default-members` configuration is used:"
msgstr ""

#: src/reference/manifest.md:664
msgid ""
"```toml\n"
"[workspace]\n"
"members = [\"path/to/member1\", \"path/to/member2\", \"path/to/member3/*\"]\n"
"default-members = [\"path/to/member2\", \"path/to/member3/foo\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:670
msgid "When specified, `default-members` must expand to a subset of `members`."
msgstr ""

#: src/reference/manifest.md:672
msgid ""
"When `default-members` is not specified, the default is the root manifest if "
"it is a package, or every member manifest (as if `--workspace` were "
"specified on the command-line) for virtual workspaces."
msgstr ""

#: src/reference/manifest.md:676
msgid "The project layout"
msgstr ""

#: src/reference/manifest.md:678
msgid ""
"If your package is an executable, name the main source file `src/main.rs`. "
"If it is a library, name the main source file `src/lib.rs`."
msgstr ""

#: src/reference/manifest.md:681
msgid ""
"Cargo will also treat any files located in `src/bin/*.rs` as executables. If "
"your executable consists of more than just one source file, you might also "
"use a directory inside `src/bin` containing a `main.rs` file which will be "
"treated as an executable with a name of the parent directory."
msgstr ""

#: src/reference/manifest.md:686
msgid ""
"Your package can optionally contain folders named `examples`, `tests`, and "
"`benches`, which Cargo will treat as containing examples, integration tests, "
"and benchmarks respectively. Analogous to `bin` targets, they may be "
"composed of single files or directories with a `main.rs` file."
msgstr ""

#: src/reference/manifest.md:713
msgid ""
"To structure your code after you've created the files and folders for your "
"package, you should remember to use Rust's module system, which you can read "
"about in [the book](../../book/ch07-00-managing-growing-projects-with-"
"packages-crates-and-modules.html)."
msgstr ""

#: src/reference/manifest.md:718
msgid ""
"See [Configuring a target](#configuring-a-target) below for more details on "
"manually configuring target settings. See [Target auto-discovery](#target-"
"auto-discovery) below for more information on controlling how Cargo "
"automatically infers targets."
msgstr ""

#: src/reference/manifest.md:723
msgid "Examples"
msgstr ""

#: src/reference/manifest.md:725
msgid ""
"Files located under `examples` are example uses of the functionality "
"provided by the library. When compiled, they are placed in the `target/"
"examples` directory."
msgstr ""

#: src/reference/manifest.md:728
msgid ""
"They can compile either as executables (with a `main()` function) or "
"libraries and pull in the library by using `extern crate <library-name>`. "
"They are compiled when you run your tests to protect them from bitrotting."
msgstr ""

#: src/reference/manifest.md:732
msgid ""
"You can run individual executable examples with the command `cargo run --"
"example <example-name>`."
msgstr ""

#: src/reference/manifest.md:735
msgid ""
"Specify `crate-type` to make an example be compiled as a library (additional "
"information about crate types is available in [The Rust Reference](../../"
"reference/linkage.html)):"
msgstr ""

#: src/reference/manifest.md:739
msgid ""
"```toml\n"
"[[example]]\n"
"name = \"foo\"\n"
"crate-type = [\"staticlib\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:745
msgid ""
"You can build individual library examples with the command `cargo build --"
"example <example-name>`."
msgstr ""

#: src/reference/manifest.md:748
msgid "Tests"
msgstr ""

#: src/reference/manifest.md:750
msgid "When you run [`cargo test`](../commands/cargo-test.md), Cargo will:"
msgstr ""

#: src/reference/manifest.md:752
msgid ""
"compile and run your library’s unit tests, which are in the files reachable "
"from `lib.rs` (naturally, any sections marked with `#[cfg(test)]` will be "
"considered at this stage);"
msgstr ""

#: src/reference/manifest.md:755
msgid ""
"compile and run your library’s documentation tests, which are embedded "
"inside of documentation blocks;"
msgstr ""

#: src/reference/manifest.md:757
msgid ""
"compile and run your library’s [integration tests](#integration-tests); and"
msgstr ""

#: src/reference/manifest.md:758
msgid "compile your library’s examples."
msgstr ""

#: src/reference/manifest.md:760
msgid "Integration tests"
msgstr ""

#: src/reference/manifest.md:762
msgid ""
"Each file in `tests/*.rs` is an integration test. When you run [`cargo test`]"
"(../commands/cargo-test.md), Cargo will compile each of these files as a "
"separate crate. The crate can link to your library by using `extern crate "
"<library-name>`, like any other code that depends on it."
msgstr ""

#: src/reference/manifest.md:767
msgid ""
"Cargo will not automatically compile files inside subdirectories of `tests`, "
"but an integration test can import modules from these directories as usual. "
"For example, if you want several integration tests to share some code, you "
"can put the shared code in `tests/common/mod.rs` and then put `mod common;` "
"in each of the test files."
msgstr ""

#: src/reference/manifest.md:773
msgid "Configuring a target"
msgstr ""

#: src/reference/manifest.md:775
msgid ""
"All of the  `[[bin]]`, `[lib]`, `[[bench]]`, `[[test]]`, and `[[example]]` "
"sections support similar configuration for specifying how a target should be "
"built. The double-bracket sections like `[[bin]]` are array-of-table of "
"[TOML](https://github.com/toml-lang/toml#array-of-tables), which means you "
"can write more than one `[[bin]]` section to make several executables in "
"your crate."
msgstr ""

#: src/reference/manifest.md:781
msgid ""
"The example below uses `[lib]`, but it also applies to all other sections as "
"well. All values listed are the defaults for that option unless otherwise "
"specified."
msgstr ""

#: src/reference/manifest.md:785
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"\n"
"[lib]\n"
"# The name of a target is the name of the library that will be generated. "
"This\n"
"# is defaulted to the name of the package, with any dashes replaced\n"
"# with underscores. (Rust `extern crate` declarations reference this name;\n"
"# therefore the value must be a valid Rust identifier to be usable.)\n"
"name = \"foo\"\n"
"\n"
"# This field points at where the crate is located, relative to the `Cargo."
"toml`.\n"
"path = \"src/lib.rs\"\n"
"\n"
"# A flag for enabling unit tests for this target. This is used by `cargo "
"test`.\n"
"test = true\n"
"\n"
"# A flag for enabling documentation tests for this target. This is only "
"relevant\n"
"# for libraries, it has no effect on other sections. This is used by\n"
"# `cargo test`.\n"
"doctest = true\n"
"\n"
"# A flag for enabling benchmarks for this target. This is used by `cargo "
"bench`.\n"
"bench = true\n"
"\n"
"# A flag for enabling documentation of this target. This is used by `cargo "
"doc`.\n"
"doc = true\n"
"\n"
"# If the target is meant to be a compiler plugin, this field must be set to "
"true\n"
"# for Cargo to correctly compile it and make it available for all "
"dependencies.\n"
"plugin = false\n"
"\n"
"# If the target is meant to be a \"macros 1.1\" procedural macro, this field "
"must\n"
"# be set to true.\n"
"proc-macro = false\n"
"\n"
"# If set to false, `cargo test` will omit the `--test` flag to rustc, which\n"
"# stops it from generating a test harness. This is useful when the binary "
"being\n"
"# built manages the test runner itself.\n"
"harness = true\n"
"\n"
"# If set then a target can be configured to use a different edition than "
"the\n"
"# `[package]` is configured to use, perhaps only compiling a library with "
"the\n"
"# 2018 edition or only compiling one unit test with the 2015 edition. By "
"default\n"
"# all targets are compiled with the edition specified in `[package]`.\n"
"edition = '2015'\n"
"\n"
"# Here's an example of a TOML \"array of tables\" section, in this case "
"specifying\n"
"# a binary target name and path.\n"
"[[bin]]\n"
"name = \"my-cool-binary\"\n"
"path = \"src/my-cool-binary.rs\"\n"
"```"
msgstr ""

#: src/reference/manifest.md:839
msgid "Target auto-discovery"
msgstr ""

#: src/reference/manifest.md:841
msgid ""
"By default, Cargo automatically determines the targets to build based on the "
"[layout of the files](#the-project-layout) on the filesystem. The target "
"configuration tables, such as `[lib]`, `[[bin]]`, `[[test]]`, `[[bench]]`, "
"or `[[example]]`, can be used to add additional targets that don't follow "
"the standard directory layout."
msgstr ""

#: src/reference/manifest.md:847
msgid ""
"The automatic target discovery can be disabled so that only manually "
"configured targets will be built. Setting the keys `autobins`, "
"`autoexamples`, `autotests`, or `autobenches` to `false` in the `[package]` "
"section will disable auto-discovery of the corresponding target type."
msgstr ""

#: src/reference/manifest.md:852
msgid ""
"Disabling automatic discovery should only be needed for specialized "
"situations. For example, if you have a library where you want a _module_ "
"named `bin`, this would present a problem because Cargo would usually "
"attempt to compile anything in the `bin` directory as an executable. Here is "
"a sample layout of this scenario:"
msgstr ""

#: src/reference/manifest.md:866
msgid ""
"To prevent Cargo from inferring `src/bin/mod.rs` as an executable, set "
"`autobins = false` in `Cargo.toml` to disable auto-discovery:"
msgstr ""

#: src/reference/manifest.md:875
msgid ""
"**Note**: For packages with the 2015 edition, the default for auto-discovery "
"is `false` if at least one target is manually defined in `Cargo.toml`. "
"Beginning with the 2018 edition, the default is always `true`."
msgstr ""

#: src/reference/manifest.md:879
msgid "The `required-features` field (optional)"
msgstr ""

#: src/reference/manifest.md:881
msgid ""
"The `required-features` field specifies which features the target needs in "
"order to be built. If any of the required features are not selected, the "
"target will be skipped. This is only relevant for the `[[bin]]`, "
"`[[bench]]`, `[[test]]`, and `[[example]]` sections, it has no effect on "
"`[lib]`."
msgstr ""

#: src/reference/manifest.md:886
msgid ""
"```toml\n"
"[features]\n"
"# ...\n"
"postgres = []\n"
"sqlite = []\n"
"tools = []\n"
"\n"
"[[bin]]\n"
"# ...\n"
"required-features = [\"postgres\", \"tools\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:898
msgid "Building dynamic or static libraries"
msgstr ""

#: src/reference/manifest.md:900
msgid ""
"If your package produces a library, you can specify which kind of library to "
"build by explicitly listing the library in your `Cargo.toml`:"
msgstr ""

#: src/reference/manifest.md:903
msgid ""
"```toml\n"
"# ...\n"
"\n"
"[lib]\n"
"name = \"...\"\n"
"crate-type = [\"dylib\"] # could be `staticlib` as well\n"
"```"
msgstr ""

#: src/reference/manifest.md:911
msgid ""
"The available options are `dylib`, `rlib`, `staticlib`, `cdylib`, and `proc-"
"macro`."
msgstr ""

#: src/reference/manifest.md:914
msgid ""
"You can read more about the different crate types in the [Rust Reference "
"Manual](../../reference/linkage.html)"
msgstr ""

#: src/reference/manifest.md:917
msgid "The `[patch]` Section"
msgstr ""

#: src/reference/manifest.md:919 src/reference/manifest.md:987
msgid ""
"This section of Cargo.toml can be used to [override dependencies](specifying-"
"dependencies.md#overriding-dependencies) with other copies. The syntax is "
"similar to the `[dependencies]` section:"
msgstr ""

#: src/reference/manifest.md:922
msgid ""
"```toml\n"
"[patch.crates-io]\n"
"foo = { git = 'https://github.com/example/foo' }\n"
"bar = { path = 'my/local/bar' }\n"
"\n"
"[dependencies.baz]\n"
"git = 'https://github.com/example/baz'\n"
"\n"
"[patch.'https://github.com/example/baz']\n"
"baz = { git = 'https://github.com/example/patched-baz', branch = 'my-"
"branch' }\n"
"```"
msgstr ""

#: src/reference/manifest.md:934
msgid ""
"The `[patch]` table is made of dependency-like sub-tables. Each key after "
"`[patch]` is a URL of the source that is being patched, or the name of a "
"registry. The name `crates-io` may be used to override the default registry "
"[crates.io](https://crates.io/). The first `[patch]` in the example above "
"demonstrates overriding [crates.io](https://crates.io/), and the second "
"`[patch]` demonstrates overriding a git source."
msgstr ""

#: src/reference/manifest.md:940
msgid ""
"Each entry in these tables is a normal dependency specification, the same as "
"found in the `[dependencies]` section of the manifest. The dependencies "
"listed in the `[patch]` section are resolved and used to patch the source at "
"the URL specified. The above manifest snippet patches the `crates-io` source "
"(e.g. crates.io itself) with the `foo` crate and `bar` crate. It also "
"patches the `https://github.com/example/baz` source with a `my-branch` that "
"comes from elsewhere."
msgstr ""

#: src/reference/manifest.md:948
msgid ""
"Sources can be patched with versions of crates that do not exist, and they "
"can also be patched with versions of crates that already exist. If a source "
"is patched with a crate version that already exists in the source, then the "
"source's original crate is replaced."
msgstr ""

#: src/reference/manifest.md:953
msgid ""
"More information about overriding dependencies can be found in the "
"[overriding dependencies](specifying-dependencies.md#overriding-"
"dependencies) section of the documentation and [RFC 1969](https://github.com/"
"rust-lang/rfcs/pull/1969) for the technical specification of this feature."
msgstr ""

#: src/reference/manifest.md:961
msgid "Using `[patch]` with multiple versions"
msgstr ""

#: src/reference/manifest.md:963
msgid ""
"You can patch in multiple versions of the same crate with the `package` key "
"used to rename dependencies. For example let's say that the `serde` crate "
"has a bugfix that we'd like to use to its 1.\\* series but we'd also like to "
"prototype using a 2.0.0 version of serde we have in our git repository. To "
"configure this we'd do:"
msgstr ""

#: src/reference/manifest.md:969
msgid ""
"```toml\n"
"[patch.crates-io]\n"
"serde = { git = 'https://github.com/serde-rs/serde' }\n"
"serde2 = { git = 'https://github.com/example/serde', package = 'serde', "
"branch = 'v2' }\n"
"```"
msgstr ""

#: src/reference/manifest.md:975
msgid ""
"The first `serde = ...` directive indicates that serde 1.\\* should be used "
"from the git repository (pulling in the bugfix we need) and the second "
"`serde2 = ...` directive indicates that the `serde` package should also be "
"pulled from the `v2` branch of `https://github.com/example/serde`. We're "
"assuming here that `Cargo.toml` on that branch mentions version 2.0.0."
msgstr ""

#: src/reference/manifest.md:981
msgid ""
"Note that when using the `package` key the `serde2` identifier here is "
"actually ignored. We simply need a unique name which doesn't conflict with "
"other patched crates."
msgstr ""

#: src/reference/manifest.md:985
msgid "The `[replace]` Section"
msgstr ""

#: src/reference/manifest.md:990
msgid ""
"```toml\n"
"[replace]\n"
"\"foo:0.1.0\" = { git = 'https://github.com/example/foo' }\n"
"\"bar:1.0.2\" = { path = 'my/local/bar' }\n"
"```"
msgstr ""

#: src/reference/manifest.md:996
msgid ""
"Each key in the `[replace]` table is a [package ID specification](pkgid-spec."
"md), which allows arbitrarily choosing a node in the dependency graph to "
"override. The value of each key is the same as the `[dependencies]` syntax "
"for specifying dependencies, except that you can't specify features. Note "
"that when a crate is overridden the copy it's overridden with must have both "
"the same name and version, but it can come from a different source (e.g., "
"git or a local path)."
msgstr ""

#: src/reference/manifest.md:1004
msgid ""
"More information about overriding dependencies can be found in the "
"[overriding dependencies](specifying-dependencies.md#overriding-"
"dependencies) section of the documentation."
msgstr ""
