msgid ""
msgstr ""
"Project-Id-Version: The Cargo Book\n"
"POT-Creation-Date: 2026-01-24T08:42:16Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/reference/build-scripts.md:1
msgid "Build Scripts"
msgstr ""

#: src/reference/build-scripts.md:3
msgid ""
"Some packages need to compile third-party non-Rust code, for example C "
"libraries. Other packages need to link to C libraries which can either be "
"located on the system or possibly need to be built from source. Others still "
"need facilities for functionality such as code generation before building "
"(think parser generators)."
msgstr ""

#: src/reference/build-scripts.md:9
msgid ""
"Cargo does not aim to replace other tools that are well-optimized for these "
"tasks, but it does integrate with them with custom build scripts. Placing a "
"file named `build.rs` in the root of a package will cause Cargo to compile "
"that script and execute it just before building the package."
msgstr ""

#: src/reference/build-scripts.md:15
msgid "// Example custom build script.\n"
msgstr ""

#: src/reference/build-scripts.md:17
msgid ""
"// Tell Cargo that if the given file changes, to rerun this build script.\n"
msgstr ""

#: src/reference/build-scripts.md:18
msgid "\"cargo:rerun-if-changed=src/hello.c\""
msgstr ""

#: src/reference/build-scripts.md:19
msgid "// Use the `cc` crate to build a C file and statically link it.\n"
msgstr ""

#: src/reference/build-scripts.md:21
msgid "\"src/hello.c\""
msgstr ""

#: src/reference/build-scripts.md:22
msgid "\"hello\""
msgstr ""

#: src/reference/build-scripts.md:26
msgid "Some example use cases of build scripts are:"
msgstr ""

#: src/reference/build-scripts.md:28
msgid "Building a bundled C library."
msgstr ""

#: src/reference/build-scripts.md:29
msgid "Finding a C library on the host system."
msgstr ""

#: src/reference/build-scripts.md:30
msgid "Generating a Rust module from a specification."
msgstr ""

#: src/reference/build-scripts.md:31
msgid "Performing any platform-specific configuration needed for the crate."
msgstr ""

#: src/reference/build-scripts.md:33
msgid ""
"The sections below describe how build scripts work, and the [examples "
"chapter](build-script-examples.md) shows a variety of examples on how to "
"write scripts."
msgstr ""

#: src/reference/build-scripts.md:37
msgid ""
"Note: The [`package.build` manifest key](manifest.md#package-build) can be "
"used to change the name of the build script, or disable it entirely."
msgstr ""

#: src/reference/build-scripts.md:40
msgid "Life Cycle of a Build Script"
msgstr ""

#: src/reference/build-scripts.md:42
msgid ""
"Just before a package is built, Cargo will compile a build script into an "
"executable (if it has not already been built). It will then run the script, "
"which may perform any number of tasks. The script may communicate with Cargo "
"by printing specially formated commands prefixed with `cargo:` to stdout."
msgstr ""

#: src/reference/build-scripts.md:47
msgid ""
"The build script will be rebuilt if any of its source files or dependencies "
"change."
msgstr ""

#: src/reference/build-scripts.md:50
msgid ""
"By default, Cargo will re-run the build script if any of the files in the "
"package changes. Typically it is best to use the `rerun-if` commands, "
"described in the [change detection](#change-detection) section below, to "
"narrow the focus of what triggers a build script to run again."
msgstr ""

#: src/reference/build-scripts.md:55
msgid ""
"Once the build script successfully finishes executing, the rest of the "
"package will be compiled. Scripts should exit with a non-zero exit code to "
"halt the build if there is an error, in which case the build script's output "
"will be displayed on the terminal."
msgstr ""

#: src/reference/build-scripts.md:60
msgid "Inputs to the Build Script"
msgstr ""

#: src/reference/build-scripts.md:62
msgid ""
"When the build script is run, there are a number of inputs to the build "
"script, all passed in the form of [environment variables](environment-"
"variables.md#environment-variables-cargo-sets-for-build-scripts)."
msgstr ""

#: src/reference/build-scripts.md:65
msgid ""
"In addition to environment variables, the build script’s current directory "
"is the source directory of the build script’s package."
msgstr ""

#: src/reference/build-scripts.md:70
msgid "Outputs of the Build Script"
msgstr ""

#: src/reference/build-scripts.md:72
msgid ""
"Build scripts may save any output files in the directory specified in the "
"[`OUT_DIR` environment variable](environment-variables.md#environment-"
"variables-cargo-sets-for-build-scripts). Scripts should not modify any files "
"outside of that directory."
msgstr ""

#: src/reference/build-scripts.md:76
msgid ""
"Build scripts communicate with Cargo by printing to stdout. Cargo will "
"interpret each line that starts with `cargo:` as an instruction that will "
"influence compilation of the package. All other lines are ignored."
msgstr ""

#: src/reference/build-scripts.md:80
msgid ""
"The output of the script is hidden from the terminal during normal "
"compilation. If you would like to see the output directly in your terminal, "
"invoke Cargo as \"very verbose\" with the `-vv` flag. This only happens when "
"the build script is run. If Cargo determines nothing has changed, it will "
"not re-run the script, see [change detection](#change-detection) below for "
"more."
msgstr ""

#: src/reference/build-scripts.md:86
msgid ""
"All the lines printed to stdout by a build script are written to a file like "
"`target/debug/build/<pkg>/output` (the precise location may depend on your "
"configuration). The stderr output is also saved in that same directory."
msgstr ""

#: src/reference/build-scripts.md:90
msgid ""
"The following is a summary of the instructions that Cargo recognizes, with "
"each one detailed below."
msgstr ""

#: src/reference/build-scripts.md:93
msgid ""
"[`cargo:rerun-if-changed=PATH`](#rerun-if-changed) — Tells Cargo when to re-"
"run the script."
msgstr ""

#: src/reference/build-scripts.md:95
msgid ""
"[`cargo:rerun-if-env-changed=VAR`](#rerun-if-env-changed) — Tells Cargo when "
"to re-run the script."
msgstr ""

#: src/reference/build-scripts.md:97
msgid ""
"[`cargo:rustc-link-lib=[KIND=]NAME`](#rustc-link-lib) — Adds a library to "
"link."
msgstr ""

#: src/reference/build-scripts.md:99
msgid ""
"[`cargo:rustc-link-search=[KIND=]PATH`](#rustc-link-search) — Adds to the "
"library search path."
msgstr ""

#: src/reference/build-scripts.md:101
msgid ""
"[`cargo:rustc-flags=FLAGS`](#rustc-flags) — Passes certain flags to the "
"compiler."
msgstr ""

#: src/reference/build-scripts.md:103
msgid ""
"[`cargo:rustc-cfg=KEY[=\"VALUE\"]`](#rustc-cfg) — Enables compile-time `cfg` "
"settings."
msgstr ""

#: src/reference/build-scripts.md:105
msgid ""
"[`cargo:rustc-env=VAR=VALUE`](#rustc-env) — Sets an environment variable."
msgstr ""

#: src/reference/build-scripts.md:106
msgid ""
"[`cargo:rustc-cdylib-link-arg=FLAG`](#rustc-cdylib-link-arg) — Passes custom "
"flags to a linker for cdylib crates."
msgstr ""

#: src/reference/build-scripts.md:108
msgid ""
"[`cargo:warning=MESSAGE`](#cargo-warning) — Displays a warning on the "
"terminal."
msgstr ""

#: src/reference/build-scripts.md:110
msgid ""
"[`cargo:KEY=VALUE`](#the-links-manifest-key) — Metadata, used by `links` "
"scripts."
msgstr ""

#: src/reference/build-scripts.md:113
msgid "<a id=\"rustc-link-lib\"></a>"
msgstr ""

#: src/reference/build-scripts.md:114
msgid "`cargo:rustc-link-lib=[KIND=]NAME`"
msgstr ""

#: src/reference/build-scripts.md:116
msgid ""
"The `rustc-link-lib` instruction tells Cargo to link the given library using "
"the compiler's [`-l` flag](../../rustc/command-line-arguments.md#option-l-"
"link-lib). This is typically used to link a native library using [FFI](../../"
"nomicon/ffi.md)."
msgstr ""

#: src/reference/build-scripts.md:120
msgid ""
"The `-l` flag is only passed to the library target of the package, unless "
"there is no library target, in which case it is passed to all targets. This "
"is done because all other targets have an implicit dependency on the library "
"target, and the given library to link should only be included once. This "
"means that if a package has both a library and a binary target, the "
"_library_ has access to the symbols from the given lib, and the binary "
"should access them through the library target's public API."
msgstr ""

#: src/reference/build-scripts.md:128
msgid ""
"The optional `KIND` may be one of `dylib`, `static`, or `framework`. See the "
"[rustc book](../../rustc/command-line-arguments.md#option-l-link-lib) for "
"more detail."
msgstr ""

#: src/reference/build-scripts.md:134
msgid "<a id=\"rustc-link-search\"></a>"
msgstr ""

#: src/reference/build-scripts.md:135
msgid "`cargo:rustc-link-search=[KIND=]PATH`"
msgstr ""

#: src/reference/build-scripts.md:137
msgid ""
"The `rustc-link-search` instruction tells Cargo to pass the [`-L` flag]"
"(../../rustc/command-line-arguments.md#option-l-search-path) to the compiler "
"to add a directory to the library search path."
msgstr ""

#: src/reference/build-scripts.md:141
msgid ""
"The optional `KIND` may be one of `dependency`, `crate`, `native`, "
"`framework`, or `all`. See the [rustc book](../../rustc/command-line-"
"arguments.md#option-l-search-path) for more detail."
msgstr ""

#: src/reference/build-scripts.md:144
msgid ""
"These paths are also added to the [dynamic library search path environment "
"variable](environment-variables.md#dynamic-library-paths) if they are within "
"the `OUT_DIR`. Depending on this behavior is discouraged since this makes it "
"difficult to use the resulting binary. In general, it is best to avoid "
"creating dynamic libraries in a build script (using existing system "
"libraries is fine)."
msgstr ""

#: src/reference/build-scripts.md:153
msgid "<a id=\"rustc-flags\"></a>"
msgstr ""

#: src/reference/build-scripts.md:154
msgid "`cargo:rustc-flags=FLAGS`"
msgstr ""

#: src/reference/build-scripts.md:156
msgid ""
"The `rustc-flags` instruction tells Cargo to pass the given space-separated "
"flags to the compiler. This only allows the `-l` and `-L` flags, and is "
"equivalent to using [`rustc-link-lib`](#rustc-link-lib) and [`rustc-link-"
"search`](#rustc-link-search)."
msgstr ""

#: src/reference/build-scripts.md:161
msgid "<a id=\"rustc-cfg\"></a>"
msgstr ""

#: src/reference/build-scripts.md:162
msgid "`cargo:rustc-cfg=KEY[=\"VALUE\"]`"
msgstr ""

#: src/reference/build-scripts.md:164
msgid ""
"The `rustc-cfg` instruction tells Cargo to pass the given value to the [`--"
"cfg` flag](../../rustc/command-line-arguments.md#option-cfg) to the "
"compiler. This may be used for compile-time detection of features to enable "
"[conditional compilation](../../reference/conditional-compilation.md)."
msgstr ""

#: src/reference/build-scripts.md:168
msgid ""
"Note that this does _not_ affect Cargo's dependency resolution. This cannot "
"be used to enable an optional dependency, or enable other Cargo features."
msgstr ""

#: src/reference/build-scripts.md:171
msgid ""
"Be aware that [Cargo features](manifest.md#the-features-section) use the "
"form `feature=\"foo\"`. `cfg` values passed with this flag are not "
"restricted to that form, and may provide just a single identifier, or any "
"arbitrary key/value pair. For example, emitting `cargo:rustc-cfg=abc` will "
"then allow code to use `#[cfg(abc)]` (note the lack of `feature=`). Or an "
"arbitrary key/value pair may be used with an `=` symbol like `cargo:rustc-"
"cfg=my_component=\"foo\"`. The key should be a Rust identifier, the value "
"should be a string."
msgstr ""

#: src/reference/build-scripts.md:183
msgid "<a id=\"rustc-env\"></a>"
msgstr ""

#: src/reference/build-scripts.md:184
msgid "`cargo:rustc-env=VAR=VALUE`"
msgstr ""

#: src/reference/build-scripts.md:186
msgid ""
"The `rustc-env` instruction tells Cargo to set the given environment "
"variable when compiling the package. The value can be then retrieved by the "
"[`env!` macro](../../std/macro.env.html) in the compiled crate. This is "
"useful for embedding additional metadata in crate's code, such as the hash "
"of git HEAD or the unique identifier of a continuous integration server."
msgstr ""

#: src/reference/build-scripts.md:192
msgid ""
"See also the [environment variables automatically included by Cargo]"
"(environment-variables.md#environment-variables-cargo-sets-for-crates)."
msgstr ""

#: src/reference/build-scripts.md:198
msgid "<a id=\"rustc-cdylib-link-arg\"></a>"
msgstr ""

#: src/reference/build-scripts.md:199
msgid "`cargo:rustc-cdylib-link-arg=FLAG`"
msgstr ""

#: src/reference/build-scripts.md:201
msgid ""
"The `rustc-cdylib-link-arg` instruction tells Cargo to pass the [`-C link-"
"arg=FLAG` option](../../rustc/codegen-options/index.md#link-arg) to the "
"compiler, but only when building a `cdylib` library target. Its usage is "
"highly platform specific. It is useful to set the shared library version or "
"the runtime-path."
msgstr ""

#: src/reference/build-scripts.md:208
msgid "<a id=\"cargo-warning\"></a>"
msgstr ""

#: src/reference/build-scripts.md:209
msgid "`cargo:warning=MESSAGE`"
msgstr ""

#: src/reference/build-scripts.md:211
msgid ""
"The `warning` instruction tells Cargo to display a warning after the build "
"script has finished running. Warnings are only shown for `path` dependencies "
"(that is, those you're working on locally), so for example warnings printed "
"out in [crates.io](https://crates.io/) crates are not emitted by default. "
"The `-vv` \"very verbose\" flag may be used to have Cargo display warnings "
"for all crates."
msgstr ""

#: src/reference/build-scripts.md:217
msgid "Build Dependencies"
msgstr ""

#: src/reference/build-scripts.md:219
msgid ""
"Build scripts are also allowed to have dependencies on other Cargo-based "
"crates. Dependencies are declared through the `build-dependencies` section "
"of the manifest."
msgstr ""

#: src/reference/build-scripts.md:223
msgid ""
"```toml\n"
"[build-dependencies]\n"
"cc = \"1.0.46\"\n"
"```"
msgstr ""

#: src/reference/build-scripts.md:228
msgid ""
"The build script **does not** have access to the dependencies listed in the "
"`dependencies` or `dev-dependencies` section (they’re not built yet!). Also, "
"build dependencies are not available to the package itself unless also "
"explicitly added in the `[dependencies]` table."
msgstr ""

#: src/reference/build-scripts.md:233
msgid ""
"It is recommended to carefully consider each dependency you add, weighing "
"against the impact on compile time, licensing, maintenance, etc. Cargo will "
"attempt to reuse a dependency if it is shared between build dependencies and "
"normal dependencies. However, this is not always possible, for example when "
"cross-compiling, so keep that in consideration of the impact on compile time."
msgstr ""

#: src/reference/build-scripts.md:239
msgid "Change Detection"
msgstr ""

#: src/reference/build-scripts.md:241
msgid ""
"When rebuilding a package, Cargo does not necessarily know if the build "
"script needs to be run again. By default, it takes a conservative approach "
"of always re-running the build script if any file within the package is "
"changed. For most cases, this is not a good choice, so it is recommended "
"that every build script emit at least one of the `rerun-if` instructions "
"(described below). If these are emitted, then Cargo will only re-run the "
"script if the given value has changed."
msgstr ""

#: src/reference/build-scripts.md:249
msgid "<a id=\"rerun-if-changed\"></a>"
msgstr ""

#: src/reference/build-scripts.md:250
msgid "`cargo:rerun-if-changed=PATH`"
msgstr ""

#: src/reference/build-scripts.md:252
msgid ""
"The `rerun-if-changed` instruction tells Cargo to re-run the build script if "
"the file at the given path has changed. Currently, Cargo only uses the "
"filesystem last-modified \"mtime\" timestamp to determine if the file has "
"changed. It compares against an internal cached timestamp of when the build "
"script last ran."
msgstr ""

#: src/reference/build-scripts.md:258
msgid ""
"If the path points to a directory, it does _not_ automatically traverse the "
"directory for changes. Only the mtime change of the directory itself is "
"considered (which corresponds to some types of changes within the directory, "
"depending on platform). To request a re-run on any changes within an entire "
"directory, print a line for the directory and separate lines for everything "
"inside it, recursively."
msgstr ""

#: src/reference/build-scripts.md:265
msgid ""
"If the build script inherently does not need to re-run under any "
"circumstance, then emitting `cargo:rerun-if-changed=build.rs` is a simple "
"way to prevent it from being re-run. Cargo automatically handles whether or "
"not the script itself needs to be recompiled, and of course the script will "
"be re-run after it has been recompiled. Otherwise, specifying `build.rs` is "
"redundant and unnecessary."
msgstr ""

#: src/reference/build-scripts.md:272
msgid "<a id=\"rerun-if-env-changed\"></a>"
msgstr ""

#: src/reference/build-scripts.md:273
msgid "`cargo:rerun-if-env-changed=NAME`"
msgstr ""

#: src/reference/build-scripts.md:275
msgid ""
"The `rerun-if-env-changed` instruction tells Cargo to re-run the build "
"script if the value of an environment variable of the given name has changed."
msgstr ""

#: src/reference/build-scripts.md:278
msgid ""
"Note that the environment variables here are intended for global environment "
"variables like `CC` and such, it is not necessary to use this for "
"environment variables like `TARGET` that Cargo sets."
msgstr ""

#: src/reference/build-scripts.md:283
msgid "The `links` Manifest Key"
msgstr ""

#: src/reference/build-scripts.md:285
msgid ""
"The `package.links` key may be set in the `Cargo.toml` manifest to declare "
"that the package links with the given native library. The purpose of this "
"manifest key is to give Cargo an understanding about the set of native "
"dependencies that a package has, as well as providing a principled system of "
"passing metadata between package build scripts."
msgstr ""

#: src/reference/build-scripts.md:291
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"links = \"foo\"\n"
"```"
msgstr ""

#: src/reference/build-scripts.md:297
msgid ""
"This manifest states that the package links to the `libfoo` native library. "
"When using the `links` key, the package must have a build script, and the "
"build script should use the [`rustc-link-lib` instruction](#rustc-link-lib) "
"to link the library."
msgstr ""

#: src/reference/build-scripts.md:302
msgid ""
"Primarily, Cargo requires that there is at most one package per `links` "
"value. In other words, it is forbidden to have two packages link to the same "
"native library. This helps prevent duplicate symbols between crates. Note, "
"however, that there are [conventions in place](#-sys-packages) to alleviate "
"this."
msgstr ""

#: src/reference/build-scripts.md:307
msgid ""
"As mentioned above in the output format, each build script can generate an "
"arbitrary set of metadata in the form of key-value pairs. This metadata is "
"passed to the build scripts of **dependent** packages. For example, if the "
"package `bar` depends on `foo`, then if `foo` generates `key=value` as part "
"of its build script metadata, then the build script of `bar` will have the "
"environment variables `DEP_FOO_KEY=value`. See the [\"Using another `sys` "
"crate\"](build-script-examples.md#using-another-sys-crate) for an example of "
"how this can be used."
msgstr ""

#: src/reference/build-scripts.md:316
msgid ""
"Note that metadata is only passed to immediate dependents, not transitive "
"dependents."
msgstr ""

#: src/reference/build-scripts.md:321
msgid "`*-sys` Packages"
msgstr ""

#: src/reference/build-scripts.md:323
msgid ""
"Some Cargo packages that link to system libraries have a naming convention "
"of having a `-sys` suffix. Any package named `foo-sys` should provide two "
"major pieces of functionality:"
msgstr ""

#: src/reference/build-scripts.md:327
msgid ""
"The library crate should link to the native library `libfoo`. This will "
"often probe the current system for `libfoo` before resorting to building "
"from source."
msgstr ""

#: src/reference/build-scripts.md:330
msgid ""
"The library crate should provide **declarations** for functions in `libfoo`, "
"but **not** bindings or higher-level abstractions."
msgstr ""

#: src/reference/build-scripts.md:333
msgid ""
"The set of `*-sys` packages provides a common set of dependencies for "
"linking to native libraries. There are a number of benefits earned from "
"having this convention of native-library-related packages:"
msgstr ""

#: src/reference/build-scripts.md:337
msgid ""
"Common dependencies on `foo-sys` alleviates the rule about one package per "
"value of `links`."
msgstr ""

#: src/reference/build-scripts.md:339
msgid ""
"Other `-sys` packages can take advantage of the `DEP_NAME_KEY=value` "
"environment variables to better integrate with other packages. See the "
"[\"Using another `sys` crate\"](build-script-examples.md#using-another-sys-"
"crate) example."
msgstr ""

#: src/reference/build-scripts.md:342
msgid ""
"A common dependency allows centralizing logic on discovering `libfoo` itself "
"(or building it from source)."
msgstr ""

#: src/reference/build-scripts.md:344
msgid "These dependencies are easily [overridable](#overriding-build-scripts)."
msgstr ""

#: src/reference/build-scripts.md:346
msgid ""
"It is common to have a companion package without the `-sys` suffix that "
"provides a safe, high-level abstractions on top of the sys package. For "
"example, the [`git2` crate](https://crates.io/crates/git2) provides a high-"
"level interface to the [`libgit2-sys` crate](https://crates.io/crates/"
"libgit2-sys)."
msgstr ""

#: src/reference/build-scripts.md:354
msgid "Overriding Build Scripts"
msgstr ""

#: src/reference/build-scripts.md:356
msgid ""
"If a manifest contains a `links` key, then Cargo supports overriding the "
"build script specified with a custom library. The purpose of this "
"functionality is to prevent running the build script in question altogether "
"and instead supply the metadata ahead of time."
msgstr ""

#: src/reference/build-scripts.md:361
msgid ""
"To override a build script, place the following configuration in any "
"acceptable Cargo [configuration location](config.md)."
msgstr ""

#: src/reference/build-scripts.md:364
msgid ""
"```toml\n"
"[target.x86_64-unknown-linux-gnu.foo]\n"
"rustc-link-lib = [\"foo\"]\n"
"rustc-link-search = [\"/path/to/foo\"]\n"
"rustc-flags = \"-L /some/path\"\n"
"rustc-cfg = ['key=\"value\"']\n"
"rustc-env = {key = \"value\"}\n"
"rustc-cdylib-link-arg = [\"…\"]\n"
"metadata_key1 = \"value\"\n"
"metadata_key2 = \"value\"\n"
"```"
msgstr ""

#: src/reference/build-scripts.md:376
msgid ""
"With this configuration, if a package declares that it links to `foo` then "
"the build script will **not** be compiled or run, and the metadata specified "
"will be used instead."
msgstr ""

#: src/reference/build-scripts.md:380
msgid ""
"The `warning`, `rerun-if-changed`, and `rerun-if-env-changed` keys should "
"not be used and will be ignored."
msgstr ""

#: src/reference/build-scripts.md:383
msgid "Jobserver"
msgstr ""

#: src/reference/build-scripts.md:385
msgid ""
"Cargo and `rustc` use the [jobserver protocol](http://make.mad-scientist.net/"
"papers/jobserver-implementation/), developed for GNU make, to coordinate "
"concurrency across processes. It is essentially a semaphore that controls "
"the number of jobs running concurrently. The concurrency may be set with the "
"`--jobs` flag, which defaults to the number of logical CPUs."
msgstr ""

#: src/reference/build-scripts.md:390
msgid ""
"Each build script inherits one job slot from Cargo, and should endeavor to "
"only use one CPU while it runs. If the script wants to use more CPUs in "
"parallel, it should use the [`jobserver` crate](https://crates.io/crates/"
"jobserver) to coordinate with Cargo."
msgstr ""

#: src/reference/build-scripts.md:394
msgid ""
"As an example, the [`cc` crate](https://crates.io/crates/cc) may enable the "
"optional `parallel` feature which will use the jobserver protocol to attempt "
"to build multiple C files at the same time."
msgstr ""
