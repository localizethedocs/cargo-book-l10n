<!DOCTYPE HTML>
<html lang="zh_CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Specifying Dependencies - The Cargo Book</title>


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>
        <script type="text/javascript" src="../ltd-provenance.js"></script>
        <script type="text/javascript" src="../ltd-current.js"></script>
        <script type="text/javascript" src="../../../ltd-config.js"></script>
        <script type="text/javascript" src="../../../ltd-flyout.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/tree/master/src/doc/src" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="specifying-dependencies"><a class="header" href="#specifying-dependencies">Specifying Dependencies</a></h2>
<p>Your crates can depend on other libraries from <a href="https://crates.io/">crates.io</a> or other registries, <code>git</code> repositories, or subdirectories on your local file system. You can also temporarily override the location of a dependency — for example, to be able to test out a bug fix in the dependency that you are working on locally. You can have different dependencies for different platforms, and dependencies that are only used during development. Let's take a look at how to do each of these.</p>
<h3 id="specifying-dependencies-from-cratesio"><a class="header" href="#specifying-dependencies-from-cratesio">Specifying dependencies from crates.io</a></h3>
<p>Cargo is configured to look for dependencies on <a href="https://crates.io/">crates.io</a> by default. Only the name and a version string are required in this case. In <a href="guide/index.html">the cargo guide</a>, we specified a dependency on the <code>time</code> crate:</p>
<pre><code class="language-toml">[dependencies]
time = "0.1.12"
</code></pre>
<p>The string <code>"0.1.12"</code> is a <a href="https://github.com/steveklabnik/semver#requirements">semver</a> version requirement. Since this string does not have any operators in it, it is interpreted the same way as if we had specified <code>"^0.1.12"</code>, which is called a caret requirement.</p>
<h3 id="caret-requirements"><a class="header" href="#caret-requirements">Caret requirements</a></h3>
<p><strong>Caret requirements</strong> allow SemVer compatible updates to a specified version. An update is allowed if the new version number does not modify the left-most non-zero digit in the major, minor, patch grouping. In this case, if we ran <code>cargo update -p time</code>, cargo should update us to version <code>0.1.13</code> if it is the latest <code>0.1.z</code> release, but would not update us to <code>0.2.0</code>. If instead we had specified the version string as <code>^1.0</code>, cargo should update to <code>1.1</code> if it is the latest <code>1.y</code> release, but not <code>2.0</code>. The version <code>0.0.x</code> is not considered compatible with any other version.</p>
<p>Here are some more examples of caret requirements and the versions that would be allowed with them:</p>
<pre><code class="language-notrust">^1.2.3 := &gt;=1.2.3 &lt;2.0.0
^1.2 := &gt;=1.2.0 &lt;2.0.0
^1 := &gt;=1.0.0 &lt;2.0.0
^0.2.3 := &gt;=0.2.3 &lt;0.3.0
^0.2 := &gt;= 0.2.0 &lt; 0.3.0
^0.0.3 := &gt;=0.0.3 &lt;0.0.4
^0.0 := &gt;=0.0.0 &lt;0.1.0
^0 := &gt;=0.0.0 &lt;1.0.0
</code></pre>
<p>This compatibility convention is different from SemVer in the way it treats versions before 1.0.0. While SemVer says there is no compatibility before 1.0.0, Cargo considers <code>0.x.y</code> to be compatible with <code>0.x.z</code>, where <code>y ≥ z</code> and <code>x &gt; 0</code>.</p>
<h3 id="tilde-requirements"><a class="header" href="#tilde-requirements">Tilde requirements</a></h3>
<p><strong>Tilde requirements</strong> specify a minimal version with some ability to update. If you specify a major, minor, and patch version or only a major and minor version, only patch-level changes are allowed. If you only specify a major version, then minor- and patch-level changes are allowed.</p>
<p><code>~1.2.3</code> is an example of a tilde requirement.</p>
<pre><code class="language-notrust">~1.2.3 := &gt;=1.2.3 &lt;1.3.0
~1.2 := &gt;=1.2.0 &lt;1.3.0
~1 := &gt;=1.0.0 &lt;2.0.0
</code></pre>
<h3 id="wildcard-requirements"><a class="header" href="#wildcard-requirements">Wildcard requirements</a></h3>
<p><strong>Wildcard requirements</strong> allow for any version where the wildcard is positioned.</p>
<p><code>*</code>, <code>1.*</code> and <code>1.2.*</code> are examples of wildcard requirements.</p>
<pre><code class="language-notrust">* := &gt;=0.0.0
1.* := &gt;=1.0.0 &lt;2.0.0
1.2.* := &gt;=1.2.0 &lt;1.3.0
</code></pre>
<h3 id="inequality-requirements"><a class="header" href="#inequality-requirements">Inequality requirements</a></h3>
<p><strong>Inequality requirements</strong> allow manually specifying a version range or an exact version to depend on.</p>
<p>Here are some examples of inequality requirements:</p>
<pre><code class="language-notrust">&gt;= 1.2.0
&gt; 1
&lt; 2
= 1.2.3
</code></pre>
<h3 id="multiple-requirements"><a class="header" href="#multiple-requirements">Multiple requirements</a></h3>
<p>Multiple version requirements can also be separated with a comma, e.g., <code>&gt;= 1.2, &lt; 1.5</code>.</p>
<h3 id="specifying-dependencies-from-other-registries"><a class="header" href="#specifying-dependencies-from-other-registries">Specifying dependencies from other registries</a></h3>
<p>To specify a dependency from a registry other than <a href="https://crates.io/">crates.io</a>, first the registry must be configured in a <code>.cargo/config</code> file. See the <a href="reference/registries.html">registries documentation</a> for more information. In the dependency, set the <code>registry</code> key to the name of the registry to use.</p>
<pre><code class="language-toml">[dependencies]
some-crate = { version = "1.0", registry = "my-registry" }
</code></pre>
<h3 id="specifying-dependencies-from-git-repositories"><a class="header" href="#specifying-dependencies-from-git-repositories">Specifying dependencies from <code>git</code> repositories</a></h3>
<p>To depend on a library located in a <code>git</code> repository, the minimum information you need to specify is the location of the repository with the <code>git</code> key:</p>
<pre><code class="language-toml">[dependencies]
rand = { git = "https://github.com/rust-lang-nursery/rand" }
</code></pre>
<p>Cargo will fetch the <code>git</code> repository at this location then look for a <code>Cargo.toml</code> for the requested crate anywhere inside the <code>git</code> repository (not necessarily at the root - for example, specifying a member crate name of a workspace and setting <code>git</code> to the repository containing the workspace).</p>
<p>Since we haven’t specified any other information, Cargo assumes that we intend to use the latest commit on the <code>master</code> branch to build our package. You can combine the <code>git</code> key with the <code>rev</code>, <code>tag</code>, or <code>branch</code> keys to specify something else. Here's an example of specifying that you want to use the latest commit on a branch named <code>next</code>:</p>
<pre><code class="language-toml">[dependencies]
rand = { git = "https://github.com/rust-lang-nursery/rand", branch = "next" }
</code></pre>
<h3 id="specifying-path-dependencies"><a class="header" href="#specifying-path-dependencies">Specifying path dependencies</a></h3>
<p>Over time, our <code>hello_world</code> package from <a href="guide/index.html">the guide</a> has grown significantly in size! It’s gotten to the point that we probably want to split out a separate crate for others to use. To do this Cargo supports <strong>path dependencies</strong> which are typically sub-crates that live within one repository. Let’s start off by making a new crate inside of our <code>hello_world</code> package:</p>
<pre><code class="language-console"># inside of hello_world/
$ cargo new hello_utils
</code></pre>
<p>This will create a new folder <code>hello_utils</code> inside of which a <code>Cargo.toml</code> and <code>src</code> folder are ready to be configured. In order to tell Cargo about this, open up <code>hello_world/Cargo.toml</code> and add <code>hello_utils</code> to your dependencies:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = "hello_utils" }
</code></pre>
<p>This tells Cargo that we depend on a crate called <code>hello_utils</code> which is found in the <code>hello_utils</code> folder (relative to the <code>Cargo.toml</code> it’s written in).</p>
<p>And that’s it! The next <code>cargo build</code> will automatically build <code>hello_utils</code> and all of its own dependencies, and others can also start using the crate as well. However, crates that use dependencies specified with only a path are not permitted on <a href="https://crates.io/">crates.io</a>. If we wanted to publish our <code>hello_world</code> crate, we would need to publish a version of <code>hello_utils</code> to <a href="https://crates.io">crates.io</a> and specify its version in the dependencies line as well:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = "hello_utils", version = "0.1.0" }
</code></pre>
<h3 id="overriding-dependencies"><a class="header" href="#overriding-dependencies">Overriding dependencies</a></h3>
<p>There are a number of methods in Cargo to support overriding dependencies and otherwise controlling the dependency graph. These options are typically, though, only available at the workspace level and aren't propagated through dependencies. In other words, "applications" have the ability to override dependencies but "libraries" do not.</p>
<p>The desire to override a dependency or otherwise alter some dependencies can arise through a number of scenarios. Most of them, however, boil down to the ability to work with a crate before it's been published to crates.io. For example:</p>
<ul>
<li>A crate you're working on is also used in a much larger application you're working on, and you'd like to test a bug fix to the library inside of the larger application.</li>
<li>An upstream crate you don't work on has a new feature or a bug fix on the master branch of its git repository which you'd like to test out.</li>
<li>You're about to publish a new major version of your crate, but you'd like to do integration testing across an entire package to ensure the new major version works.</li>
<li>You've submitted a fix to an upstream crate for a bug you found, but you'd like to immediately have your application start depending on the fixed version of the crate to avoid blocking on the bug fix getting merged.</li>
</ul>
<p>These scenarios are currently all solved with the <a href="reference/manifest.html#the-patch-section"><code>[patch]</code> manifest section</a>. Historically some of these scenarios have been solved with <a href="reference/manifest.html#the-replace-section">the <code>[replace]</code> section</a>, but we'll document the <code>[patch]</code> section here.</p>
<h3 id="testing-a-bugfix"><a class="header" href="#testing-a-bugfix">Testing a bugfix</a></h3>
<p>Let's say you're working with the <a href="https://crates.io/crates/uuid"><code>uuid</code> crate</a> but while you're working on it you discover a bug. You are, however, quite enterprising so you decide to also try to fix the bug! Originally your manifest will look like:</p>
<pre><code class="language-toml">[package]
name = "my-library"
version = "0.1.0"
authors = ["..."]

[dependencies]
uuid = "1.0"
</code></pre>
<p>First thing we'll do is to clone the <a href="https://github.com/rust-lang-nursery/uuid"><code>uuid</code> repository</a> locally via:</p>
<pre><code class="language-console">$ git clone https://github.com/rust-lang-nursery/uuid
</code></pre>
<p>Next we'll edit the manifest of <code>my-library</code> to contain:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { path = "../path/to/uuid" }
</code></pre>
<p>Here we declare that we're <em>patching</em> the source <code>crates-io</code> with a new dependency. This will effectively add the local checked out version of <code>uuid</code> to the crates.io registry for our local package.</p>
<p>Next up we need to ensure that our lock file is updated to use this new version of <code>uuid</code> so our package uses the locally checked out copy instead of one from crates.io. The way <code>[patch]</code> works is that it'll load the dependency at <code>../path/to/uuid</code> and then whenever crates.io is queried for versions of <code>uuid</code> it'll <em>also</em> return the local version.</p>
<p>This means that the version number of the local checkout is significant and will affect whether the patch is used. Our manifest declared <code>uuid = "1.0"</code> which means we'll only resolve to <code>&gt;= 1.0.0, &lt; 2.0.0</code>, and Cargo's greedy resolution algorithm also means that we'll resolve to the maximum version within that range. Typically this doesn't matter as the version of the git repository will already be greater or match the maximum version published on crates.io, but it's important to keep this in mind!</p>
<p>In any case, typically all you need to do now is:</p>
<pre><code class="language-console">$ cargo build
   Compiling uuid v1.0.0 (.../uuid)
   Compiling my-library v0.1.0 (.../my-library)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>And that's it! You're now building with the local version of <code>uuid</code> (note the path in parentheses in the build output). If you don't see the local path version getting built then you may need to run <code>cargo update -p uuid --precise $version</code> where <code>$version</code> is the version of the locally checked out copy of <code>uuid</code>.</p>
<p>Once you've fixed the bug you originally found the next thing you'll want to do is to likely submit that as a pull request to the <code>uuid</code> crate itself. Once you've done this then you can also update the <code>[patch]</code> section. The listing inside of <code>[patch]</code> is just like the <code>[dependencies]</code> section, so once your pull request is merged you could change your <code>path</code> dependency to:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }
</code></pre>
<h3 id="working-with-an-unpublished-minor-version"><a class="header" href="#working-with-an-unpublished-minor-version">Working with an unpublished minor version</a></h3>
<p>Let's now shift gears a bit from bug fixes to adding features. While working on <code>my-library</code> you discover that a whole new feature is needed in the <code>uuid</code> crate. You've implemented this feature, tested it locally above with <code>[patch]</code>, and submitted a pull request. Let's go over how you continue to use and test it before it's actually published.</p>
<p>Let's also say that the current version of <code>uuid</code> on crates.io is <code>1.0.0</code>, but since then the master branch of the git repository has updated to <code>1.0.1</code>. This branch includes your new feature you submitted previously. To use this repository we'll edit our <code>Cargo.toml</code> to look like</p>
<pre><code class="language-toml">[package]
name = "my-library"
version = "0.1.0"
authors = ["..."]

[dependencies]
uuid = "1.0.1"

[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }
</code></pre>
<p>Note that our local dependency on <code>uuid</code> has been updated to <code>1.0.1</code> as it's what we'll actually require once the crate is published. This version doesn't exist on crates.io, though, so we provide it with the <code>[patch]</code> section of the manifest.</p>
<p>Now when our library is built it'll fetch <code>uuid</code> from the git repository and resolve to 1.0.1 inside the repository instead of trying to download a version from crates.io. Once 1.0.1 is published on crates.io the <code>[patch]</code> section can be deleted.</p>
<p>It's also worth noting that <code>[patch]</code> applies <em>transitively</em>. Let's say you use <code>my-library</code> in a larger package, such as:</p>
<pre><code class="language-toml">[package]
name = "my-binary"
version = "0.1.0"
authors = ["..."]

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = "1.0"

[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }
</code></pre>
<p>Remember that <code>[patch]</code> is applicable <em>transitively</em> but can only be defined at the <em>top level</em> so we consumers of <code>my-library</code> have to repeat the <code>[patch]</code> section if necessary. Here, though, the new <code>uuid</code> crate applies to <em>both</em> our dependency on <code>uuid</code> and the <code>my-library -&gt; uuid</code> dependency. The <code>uuid</code> crate will be resolved to one version for this entire crate graph, 1.0.1, and it'll be pulled from the git repository.</p>
<h4 id="overriding-repository-url"><a class="header" href="#overriding-repository-url">Overriding repository URL</a></h4>
<p>In case the dependency you want to override isn't loaded from <code>crates.io</code>, you'll have to change a bit how you use <code>[patch]</code>:</p>
<pre><code class="language-toml">[patch."https://github.com/your/repository"]
my-library = { path = "../my-library/path" }
</code></pre>
<p>And that's it!</p>
<h3 id="prepublishing-a-breaking-change"><a class="header" href="#prepublishing-a-breaking-change">Prepublishing a breaking change</a></h3>
<p>As a final scenario, let's take a look at working with a new major version of a crate, typically accompanied with breaking changes. Sticking with our previous crates, this means that we're going to be creating version 2.0.0 of the <code>uuid</code> crate. After we've submitted all changes upstream we can update our manifest for <code>my-library</code> to look like:</p>
<pre><code class="language-toml">[dependencies]
uuid = "2.0"

[patch.crates-io]
uuid = { git = "https://github.com/rust-lang-nursery/uuid", branch = "2.0.0" }
</code></pre>
<p>And that's it! Like with the previous example the 2.0.0 version doesn't actually exist on crates.io but we can still put it in through a git dependency through the usage of the <code>[patch]</code> section. As a thought exercise let's take another look at the <code>my-binary</code> manifest from above again as well:</p>
<pre><code class="language-toml">[package]
name = "my-binary"
version = "0.1.0"
authors = ["..."]

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = "1.0"

[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid', branch = '2.0.0' }
</code></pre>
<p>Note that this will actually resolve to two versions of the <code>uuid</code> crate. The <code>my-binary</code> crate will continue to use the 1.x.y series of the <code>uuid</code> crate but the <code>my-library</code> crate will use the 2.0.0 version of <code>uuid</code>. This will allow you to gradually roll out breaking changes to a crate through a dependency graph without being force to update everything all at once.</p>
<h3 id="overriding-with-local-dependencies"><a class="header" href="#overriding-with-local-dependencies">Overriding with local dependencies</a></h3>
<p>Sometimes you're only temporarily working on a crate and you don't want to have to modify <code>Cargo.toml</code> like with the <code>[patch]</code> section above. For this use case Cargo offers a much more limited version of overrides called <strong>path overrides</strong>.</p>
<p>Path overrides are specified through <code>.cargo/config</code> instead of <code>Cargo.toml</code>, and you can find <a href="reference/config.html">more documentation about this configuration</a>. Inside of <code>.cargo/config</code> you'll specify a key called <code>paths</code>:</p>
<pre><code class="language-toml">paths = ["/path/to/uuid"]
</code></pre>
<p>This array should be filled with directories that contain a <code>Cargo.toml</code>. In this instance, we’re just adding <code>uuid</code>, so it will be the only one that’s overridden. This path can be either absolute or relative to the directory that contains the <code>.cargo</code> folder.</p>
<p>Path overrides are more restricted than the <code>[patch]</code> section, however, in that they cannot change the structure of the dependency graph. When a path replacement is used then the previous set of dependencies must all match exactly to the new <code>Cargo.toml</code> specification. For example this means that path overrides cannot be used to test out adding a dependency to a crate, instead <code>[patch]</code> must be used in that situation. As a result usage of a path override is typically isolated to quick bug fixes rather than larger changes.</p>
<p>Note: using a local configuration to override paths will only work for crates that have been published to <a href="https://crates.io/">crates.io</a>. You cannot use this feature to tell Cargo how to find local unpublished crates.</p>
<h3 id="platform-specific-dependencies"><a class="header" href="#platform-specific-dependencies">Platform specific dependencies</a></h3>
<p>Platform-specific dependencies take the same format, but are listed under a <code>target</code> section. Normally Rust-like <code>#[cfg]</code> syntax will be used to define these sections:</p>
<pre><code class="language-toml">[target.'cfg(windows)'.dependencies]
winhttp = "0.4.0"

[target.'cfg(unix)'.dependencies]
openssl = "1.0.1"

[target.'cfg(target_arch = "x86")'.dependencies]
native = { path = "native/i686" }

[target.'cfg(target_arch = "x86_64")'.dependencies]
native = { path = "native/x86_64" }
</code></pre>
<p>Like with Rust, the syntax here supports the <code>not</code>, <code>any</code>, and <code>all</code> operators to combine various cfg name/value pairs. Note that the <code>cfg</code> syntax has only been available since Cargo 0.9.0 (Rust 1.8.0).</p>
<p>In addition to <code>#[cfg]</code> syntax, Cargo also supports listing out the full target the dependencies would apply to:</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-gnu.dependencies]
winhttp = "0.4.0"

[target.i686-unknown-linux-gnu.dependencies]
openssl = "1.0.1"
</code></pre>
<p>If you’re using a custom target specification, quote the full path and file name:</p>
<pre><code class="language-toml">[target."x86_64/windows.json".dependencies]
winhttp = "0.4.0"

[target."i686/linux.json".dependencies]
openssl = "1.0.1"
native = { path = "native/i686" }

[target."x86_64/linux.json".dependencies]
openssl = "1.0.1"
native = { path = "native/x86_64" }
</code></pre>
<h3 id="development-dependencies"><a class="header" href="#development-dependencies">Development dependencies</a></h3>
<p>You can add a <code>[dev-dependencies]</code> section to your <code>Cargo.toml</code> whose format is equivalent to <code>[dependencies]</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
tempdir = "0.3"
</code></pre>
<p>Dev-dependencies are not used when compiling a package for building, but are used for compiling tests, examples, and benchmarks.</p>
<p>These dependencies are <em>not</em> propagated to other packages which depend on this package.</p>
<p>You can also have target-specific development dependencies by using <code>dev-dependencies</code> in the target section header instead of <code>dependencies</code>. For example:</p>
<pre><code class="language-toml">[target.'cfg(unix)'.dev-dependencies]
mio = "0.0.1"
</code></pre>
<h3 id="build-dependencies"><a class="header" href="#build-dependencies">Build dependencies</a></h3>
<p>You can depend on other Cargo-based crates for use in your build scripts. Dependencies are declared through the <code>build-dependencies</code> section of the manifest:</p>
<pre><code class="language-toml">[build-dependencies]
cc = "1.0.3"
</code></pre>
<p>The build script <strong>does not</strong> have access to the dependencies listed in the <code>dependencies</code> or <code>dev-dependencies</code> section. Build dependencies will likewise not be available to the package itself unless listed under the <code>dependencies</code> section as well. A package itself and its build script are built separately, so their dependencies need not coincide. Cargo is kept simpler and cleaner by using independent dependencies for independent purposes.</p>
<h3 id="choosing-features"><a class="header" href="#choosing-features">Choosing features</a></h3>
<p>If a package you depend on offers conditional features, you can specify which to use:</p>
<pre><code class="language-toml">[dependencies.awesome]
version = "1.3.5"
default-features = false # do not include the default features, and optionally
                         # cherry-pick individual features
features = ["secure-password", "civet"]
</code></pre>
<p>More information about features can be found in the <a href="reference/manifest.html#the-features-section">manifest documentation</a>.</p>
<h3 id="renaming-dependencies-in-cargotoml"><a class="header" href="#renaming-dependencies-in-cargotoml">Renaming dependencies in <code>Cargo.toml</code></a></h3>
<p>When writing a <code>[dependencies]</code> section in <code>Cargo.toml</code> the key you write for a dependency typically matches up to the name of the crate you import from in the code. For some projects, though, you may wish to reference the crate with a different name in the code regardless of how it's published on crates.io. For example you may wish to:</p>
<ul>
<li>Avoid the need to  <code>use foo as bar</code> in Rust source.</li>
<li>Depend on multiple versions of a crate.</li>
<li>Depend on crates with the same name from different registries.</li>
</ul>
<p>To support this Cargo supports a <code>package</code> key in the <code>[dependencies]</code> section of which package should be depended on:</p>
<pre><code class="language-toml">[package]
name = "mypackage"
version = "0.0.1"

[dependencies]
foo = "0.1"
bar = { git = "https://github.com/example/project", package = "foo" }
baz = { version = "0.1", registry = "custom", package = "foo" }
</code></pre>
<p>In this example, three crates are now available in your Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate foo; // crates.io
extern crate bar; // git repository
extern crate baz; // registry `custom`
<span class="boring">}</span></code></pre></pre>
<p>All three of these crates have the package name of <code>foo</code> in their own <code>Cargo.toml</code>, so we're explicitly using the <code>package</code> key to inform Cargo that we want the <code>foo</code> package even though we're calling it something else locally. The <code>package</code> key, if not specified, defaults to the name of the dependency being requested.</p>
<p>Note that if you have an optional dependency like:</p>
<pre><code class="language-toml">[dependencies]
foo = { version = "0.1", package = 'bar', optional = true }
</code></pre>
<p>you're depending on the crate <code>bar</code> from crates.io, but your crate has a <code>foo</code> feature instead of a <code>bar</code> feature. That is, names of features take after the name of the dependency, not the package name, when renamed.</p>
<p>Enabling transitive dependencies works similarly, for example we could add the following to the above manifest:</p>
<pre><code class="language-toml">[features]
log-debug = ['foo/log-debug'] # using 'bar/log-debug' would be an error!
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reference/manifest.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reference/manifest.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
