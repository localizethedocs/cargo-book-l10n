msgid ""
msgstr ""
"Project-Id-Version: The Cargo Book\n"
"POT-Creation-Date: 2026-01-24T08:49:29Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/guide/index.md:1
msgid "Cargo Guide"
msgstr ""

#: src/guide/index.md:3
msgid ""
"This guide will give you all that you need to know about how to use Cargo to "
"develop Rust projects."
msgstr ""

#: src/guide/index.md:6
msgid "[Why Cargo Exists](guide/why-cargo-exists.html)"
msgstr ""

#: src/guide/index.md:7
msgid "[Creating a New Project](guide/creating-a-new-project.html)"
msgstr ""

#: src/guide/index.md:8
msgid ""
"[Working on an Existing Cargo Project](guide/working-on-an-existing-project."
"html)"
msgstr ""

#: src/guide/index.md:9
msgid "[Dependencies](guide/dependencies.html)"
msgstr ""

#: src/guide/index.md:10
msgid "[Project Layout](guide/project-layout.html)"
msgstr ""

#: src/guide/index.md:11
msgid "[Cargo.toml vs Cargo.lock](guide/cargo-toml-vs-cargo-lock.html)"
msgstr ""

#: src/guide/index.md:12
msgid "[Tests](guide/tests.html)"
msgstr ""

#: src/guide/index.md:13
msgid "[Continuous Integration](guide/continuous-integration.html)"
msgstr ""

#: src/guide/index.md:14
msgid "[Build Cache](guide/build-cache.html)"
msgstr ""

#: src/guide/build-cache.md:1
msgid "Build cache"
msgstr ""

#: src/guide/build-cache.md:3
msgid ""
"Cargo shares build artifacts among all the packages of a single workspace. "
"Today, Cargo does not share build results across different workspaces, but a "
"similar result can be achieved by using a third party tool, [sccache]"
"(https://github.com/mozilla/sccache)."
msgstr ""

#: src/guide/build-cache.md:7
msgid ""
"To setup `sccache`, install it with `cargo install sccache` and set "
"`RUSTC_WRAPPER` environmental variable to `sccache` before invoking Cargo. "
"If you use bash, it makes sense to add `export RUSTC_WRAPPER=sccache` to `."
"bashrc`. Refer to sccache documentation for more details."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:1
msgid "Cargo.toml vs Cargo.lock"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:3
msgid ""
"`Cargo.toml` and `Cargo.lock` serve two different purposes. Before we talk "
"about them, here’s a summary:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:6
msgid ""
"`Cargo.toml` is about describing your dependencies in a broad sense, and is "
"written by you."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:8
msgid ""
"`Cargo.lock` contains exact information about your dependencies. It is "
"maintained by Cargo and should not be manually edited."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:11
msgid ""
"If you’re building a library that other projects will depend on, put `Cargo."
"lock` in your `.gitignore`. If you’re building an executable like a command-"
"line tool or an application, check `Cargo.lock` into `git`. If you're "
"curious about why that is, see [\"Why do binaries have `Cargo.lock` in "
"version control, but not libraries?\" in the FAQ](faq.html#why-do-binaries-"
"have-cargolock-in-version-control-but-not-libraries)."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:18
msgid "Let’s dig in a little bit more."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:20
msgid ""
"`Cargo.toml` is a **manifest** file in which we can specify a bunch of "
"different metadata about our project. For example, we can say that we depend "
"on another project:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:24
#: src/guide/cargo-toml-vs-cargo-lock.md:60
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"authors = [\"Your Name <you@example.com>\"]\n"
"\n"
"[dependencies]\n"
"rand = { git = \"https://github.com/rust-lang-nursery/rand.git\" }\n"
"```"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:34
msgid ""
"This project has a single dependency, on the `rand` library. We’ve stated in "
"this case that we’re relying on a particular Git repository that lives on "
"GitHub. Since we haven’t specified any other information, Cargo assumes that "
"we intend to use the latest commit on the `master` branch to build our "
"project."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:39
msgid ""
"Sound good? Well, there’s one problem: If you build this project today, and "
"then you send a copy to me, and I build this project tomorrow, something bad "
"could happen. There could be more commits to `rand` in the meantime, and my "
"build would include new commits while yours would not. Therefore, we would "
"get different builds. This would be bad because we want reproducible builds."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:45
msgid "We could fix this problem by putting a `rev` line in our `Cargo.toml`:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:47
msgid ""
"```toml\n"
"[dependencies]\n"
"rand = { git = \"https://github.com/rust-lang-nursery/rand.git\", rev = "
"\"9f35b8e\" }\n"
"```"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:52
msgid ""
"Now our builds will be the same. But there’s a big drawback: now we have to "
"manually think about SHA-1s every time we want to update our library. This "
"is both tedious and error prone."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:56
msgid ""
"Enter the `Cargo.lock`. Because of its existence, we don’t need to manually "
"keep track of the exact revisions: Cargo will do it for us. When we have a "
"manifest like this:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:70
msgid ""
"Cargo will take the latest commit and write that information out into our "
"`Cargo.lock` when we build for the first time. That file will look like this:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:73
msgid ""
"```toml\n"
"[[package]]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"dependencies = [\n"
" \"rand 0.1.0 (git+https://github.com/rust-lang-nursery/rand."
"git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9)\",\n"
"]\n"
"\n"
"[[package]]\n"
"name = \"rand\"\n"
"version = \"0.1.0\"\n"
"source = \"git+https://github.com/rust-lang-nursery/rand."
"git#9f35b8e439eeedd60b9414c58f389bdc6a3284f9\"\n"
"```"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:87
msgid ""
"You can see that there’s a lot more information here, including the exact "
"revision we used to build. Now when you give your project to someone else, "
"they’ll use the exact same SHA, even though we didn’t specify it in our "
"`Cargo.toml`."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:92
msgid ""
"When we’re ready to opt in to a new version of the library, Cargo can re-"
"calculate the dependencies and update things for us:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:100
msgid ""
"This will write out a new `Cargo.lock` with the new version information. "
"Note that the argument to `cargo update` is actually a [Package ID "
"Specification](reference/pkgid-spec.html) and `rand` is just a short "
"specification."
msgstr ""

#: src/guide/continuous-integration.md:1
msgid "Continuous Integration"
msgstr ""

#: src/guide/continuous-integration.md:3
msgid "Travis CI"
msgstr ""

#: src/guide/continuous-integration.md:5
msgid "To test your project on Travis CI, here is a sample `.travis.yml` file:"
msgstr ""

#: src/guide/continuous-integration.md:8
msgid "language"
msgstr ""

#: src/guide/continuous-integration.md:8 src/guide/continuous-integration.md:15
msgid "rust"
msgstr ""

#: src/guide/continuous-integration.md:10
msgid "stable"
msgstr ""

#: src/guide/continuous-integration.md:11
msgid "beta"
msgstr ""

#: src/guide/continuous-integration.md:12
#: src/guide/continuous-integration.md:15
msgid "nightly"
msgstr ""

#: src/guide/continuous-integration.md:12
msgid "matrix"
msgstr ""

#: src/guide/continuous-integration.md:14
msgid "allow_failures"
msgstr ""

#: src/guide/continuous-integration.md:18
msgid ""
"This will test all three release channels, but any breakage in nightly will "
"not fail your overall build. Please see the [Travis CI Rust documentation]"
"(https://docs.travis-ci.com/user/languages/rust/) for more information."
msgstr ""

#: src/guide/continuous-integration.md:23
msgid "GitLab CI"
msgstr ""

#: src/guide/continuous-integration.md:25
msgid ""
"To test your project on GitLab CI, here is a sample `.gitlab-ci.yml` file:"
msgstr ""

#: src/guide/continuous-integration.md:28
msgid "stages"
msgstr ""

#: src/guide/continuous-integration.md:29
#: src/guide/continuous-integration.md:32
#: src/guide/continuous-integration.md:39
msgid "build"
msgstr ""

#: src/guide/continuous-integration.md:30
msgid "rust-latest"
msgstr ""

#: src/guide/continuous-integration.md:32
#: src/guide/continuous-integration.md:39
msgid "stage"
msgstr ""

#: src/guide/continuous-integration.md:33
#: src/guide/continuous-integration.md:40
msgid "image"
msgstr ""

#: src/guide/continuous-integration.md:33
msgid "rust:latest"
msgstr ""

#: src/guide/continuous-integration.md:34
#: src/guide/continuous-integration.md:41
msgid "script"
msgstr ""

#: src/guide/continuous-integration.md:35
#: src/guide/continuous-integration.md:42
msgid "cargo build --verbose"
msgstr ""

#: src/guide/continuous-integration.md:36
#: src/guide/continuous-integration.md:43
msgid "cargo test --verbose"
msgstr ""

#: src/guide/continuous-integration.md:37
msgid "rust-nightly"
msgstr ""

#: src/guide/continuous-integration.md:40
msgid "rustlang/rust:nightly"
msgstr ""

#: src/guide/continuous-integration.md:44
msgid "allow_failure"
msgstr ""

#: src/guide/continuous-integration.md:47
msgid ""
"This will test on the stable channel and nightly channel, but any breakage "
"in nightly will not fail your overall build. Please see the [GitLab CI]"
"(https://docs.gitlab.com/ce/ci/yaml/README.html) for more information."
msgstr ""

#: src/guide/creating-a-new-project.md:1
msgid "Creating a New Project"
msgstr ""

#: src/guide/creating-a-new-project.md:3
msgid "To start a new project with Cargo, use `cargo new`:"
msgstr ""

#: src/guide/creating-a-new-project.md:9
msgid ""
"We’re passing `--bin` because we’re making a binary program: if we were "
"making a library, we’d pass `--lib`. This also initializes a new `git` "
"repository by default. If you don't want it to do that, pass `--vcs none`."
msgstr ""

#: src/guide/creating-a-new-project.md:13
msgid "Let’s check out what Cargo has generated for us:"
msgstr ""

#: src/guide/creating-a-new-project.md:26
msgid "Let’s take a closer look at `Cargo.toml`:"
msgstr ""

#: src/guide/creating-a-new-project.md:28
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"authors = [\"Your Name <you@example.com>\"]\n"
"```"
msgstr ""

#: src/guide/creating-a-new-project.md:35
msgid ""
"This is called a **manifest**, and it contains all of the metadata that "
"Cargo needs to compile your project."
msgstr ""

#: src/guide/creating-a-new-project.md:38
msgid "Here’s what’s in `src/main.rs`:"
msgstr ""

#: src/guide/creating-a-new-project.md:42
msgid "\"Hello, world!\""
msgstr ""

#: src/guide/creating-a-new-project.md:46
msgid "Cargo generated a “hello world” for us. Let’s compile it:"
msgstr ""

#: src/guide/creating-a-new-project.md:48
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)\n"
"```"
msgstr ""

#: src/guide/creating-a-new-project.md:53
msgid "And then run it:"
msgstr ""

#: src/guide/creating-a-new-project.md:60
msgid ""
"We can also use `cargo run` to compile and then run it, all in one step (You "
"won't see the `Compiling` line if you have not made any changes since you "
"last compiled):"
msgstr ""

#: src/guide/creating-a-new-project.md:64
msgid ""
"```console\n"
"$ cargo run\n"
"   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)\n"
"     Running `target/debug/hello_world`\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/guide/creating-a-new-project.md:71
msgid ""
"You’ll now notice a new file, `Cargo.lock`. It contains information about "
"our dependencies. Since we don’t have any yet, it’s not very interesting."
msgstr ""

#: src/guide/creating-a-new-project.md:74
msgid ""
"Once you’re ready for release, you can use `cargo build --release` to "
"compile your files with optimizations turned on:"
msgstr ""

#: src/guide/creating-a-new-project.md:77
msgid ""
"```console\n"
"$ cargo build --release\n"
"   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)\n"
"```"
msgstr ""

#: src/guide/creating-a-new-project.md:82
msgid ""
"`cargo build --release` puts the resulting binary in `target/release` "
"instead of `target/debug`."
msgstr ""

#: src/guide/creating-a-new-project.md:85
msgid ""
"Compiling in debug mode is the default for development-- compilation time is "
"shorter since the compiler doesn't do optimizations, but the code will run "
"slower. Release mode takes longer to compile, but the code will run faster."
msgstr ""

#: src/guide/dependencies.md:1
msgid "Dependencies"
msgstr ""

#: src/guide/dependencies.md:3
msgid ""
"[crates.io](https://crates.io/) is the Rust community's central package "
"registry that serves as a location to discover and download packages. "
"`cargo` is configured to use it by default to find requested packages."
msgstr ""

#: src/guide/dependencies.md:7
msgid ""
"To depend on a library hosted on [crates.io](https://crates.io/), add it to "
"your `Cargo.toml`."
msgstr ""

#: src/guide/dependencies.md:11
msgid "Adding a dependency"
msgstr ""

#: src/guide/dependencies.md:13
msgid ""
"If your `Cargo.toml` doesn't already have a `[dependencies]` section, add "
"that, then list the crate name and version that you would like to use. This "
"example adds a dependency of the `time` crate:"
msgstr ""

#: src/guide/dependencies.md:17
msgid ""
"```toml\n"
"[dependencies]\n"
"time = \"0.1.12\"\n"
"```"
msgstr ""

#: src/guide/dependencies.md:22
msgid ""
"The version string is a [semver](https://github.com/steveklabnik/"
"semver#requirements) version requirement. The [specifying dependencies]"
"(reference/specifying-dependencies.html) docs have more information about "
"the options you have here."
msgstr ""

#: src/guide/dependencies.md:28
msgid ""
"If we also wanted to add a dependency on the `regex` crate, we would not "
"need to add `[dependencies]` for each crate listed. Here's what your whole "
"`Cargo.toml` file would look like with dependencies on the `time` and "
"`regex` crates:"
msgstr ""

#: src/guide/dependencies.md:33
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"authors = [\"Your Name <you@example.com>\"]\n"
"\n"
"[dependencies]\n"
"time = \"0.1.12\"\n"
"regex = \"0.1.41\"\n"
"```"
msgstr ""

#: src/guide/dependencies.md:44
msgid ""
"Re-run `cargo build`, and Cargo will fetch the new dependencies and all of "
"their dependencies, compile them all, and update the `Cargo.lock`:"
msgstr ""

#: src/guide/dependencies.md:47
msgid ""
"```console\n"
"$ cargo build\n"
"      Updating registry `https://github.com/rust-lang/crates.io-index`\n"
"   Downloading memchr v0.1.5\n"
"   Downloading libc v0.1.10\n"
"   Downloading regex-syntax v0.2.1\n"
"   Downloading memchr v0.1.5\n"
"   Downloading aho-corasick v0.3.0\n"
"   Downloading regex v0.1.41\n"
"     Compiling memchr v0.1.5\n"
"     Compiling libc v0.1.10\n"
"     Compiling regex-syntax v0.2.1\n"
"     Compiling memchr v0.1.5\n"
"     Compiling aho-corasick v0.3.0\n"
"     Compiling regex v0.1.41\n"
"     Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)\n"
"```"
msgstr ""

#: src/guide/dependencies.md:65
msgid ""
"Our `Cargo.lock` contains the exact information about which revision of all "
"of these dependencies we used."
msgstr ""

#: src/guide/dependencies.md:68
msgid ""
"Now, if `regex` gets updated, we will still build with the same revision "
"until we choose to `cargo update`."
msgstr ""

#: src/guide/dependencies.md:71
msgid "You can now use the `regex` library using `extern crate` in `main.rs`."
msgstr ""

#: src/guide/dependencies.md:79
msgid "r\"^\\d{4}-\\d{2}-\\d{2}$\""
msgstr ""

#: src/guide/dependencies.md:80
msgid "\"Did our date match? {}\""
msgstr ""

#: src/guide/dependencies.md:80
msgid "\"2014-01-01\""
msgstr ""

#: src/guide/dependencies.md:84
msgid "Running it will show:"
msgstr ""

#: src/guide/project-layout.md:1
msgid "Project Layout"
msgstr ""

#: src/guide/project-layout.md:3
msgid ""
"Cargo uses conventions for file placement to make it easy to dive into a new "
"Cargo project:"
msgstr ""

#: src/guide/project-layout.md:23
msgid ""
"`Cargo.toml` and `Cargo.lock` are stored in the root of your project "
"(_package root_)."
msgstr ""

#: src/guide/project-layout.md:25
msgid "Source code goes in the `src` directory."
msgstr ""

#: src/guide/project-layout.md:26
msgid "The default library file is `src/lib.rs`."
msgstr ""

#: src/guide/project-layout.md:27
msgid "The default executable file is `src/main.rs`."
msgstr ""

#: src/guide/project-layout.md:28
msgid "Other executables can be placed in `src/bin/*.rs`."
msgstr ""

#: src/guide/project-layout.md:29
msgid ""
"Integration tests go in the `tests` directory (unit tests go in each file "
"they're testing)."
msgstr ""

#: src/guide/project-layout.md:31
msgid "Examples go in the `examples` directory."
msgstr ""

#: src/guide/project-layout.md:32
msgid "Benchmarks go in the `benches` directory."
msgstr ""

#: src/guide/project-layout.md:34
msgid ""
"These are explained in more detail in the [manifest description](reference/"
"manifest.html#the-project-layout)."
msgstr ""

#: src/guide/tests.md:1
msgid "Tests"
msgstr ""

#: src/guide/tests.md:3
msgid ""
"Cargo can run your tests with the `cargo test` command. Cargo looks for "
"tests to run in two places: in each of your `src` files and any tests in "
"`tests/`. Tests in your `src` files should be unit tests, and tests in "
"`tests/` should be integration-style tests. As such, you’ll need to import "
"your crates into the files in `tests`."
msgstr ""

#: src/guide/tests.md:9
msgid ""
"Here's an example of running `cargo test` in our project, which currently "
"has no tests:"
msgstr ""

#: src/guide/tests.md:12
msgid ""
"```console\n"
"$ cargo test\n"
"   Compiling rand v0.1.0 (https://github.com/rust-lang-nursery/rand."
"git#9f35b8e)\n"
"   Compiling hello_world v0.1.0 (file:///path/to/project/hello_world)\n"
"     Running target/test/hello_world-9c2b65bbb79eabce\n"
"\n"
"running 0 tests\n"
"\n"
"test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n"
"```"
msgstr ""

#: src/guide/tests.md:23
msgid ""
"If our project had tests, we would see more output with the correct number "
"of tests."
msgstr ""

#: src/guide/tests.md:26
msgid "You can also run a specific test by passing a filter:"
msgstr ""

#: src/guide/tests.md:32
msgid "This will run any test with `foo` in its name."
msgstr ""

#: src/guide/tests.md:34
msgid ""
"`cargo test` runs additional checks as well. For example, it will compile "
"any examples you’ve included and will also test the examples in your "
"documentation. Please see the [testing guide](https://doc.rust-lang.org/book/"
"testing.html) in the Rust documentation for more details."
msgstr ""

#: src/guide/why-cargo-exists.md:1
msgid "Why Cargo Exists"
msgstr ""

#: src/guide/why-cargo-exists.md:3
msgid ""
"Cargo is a tool that allows Rust projects to declare their various "
"dependencies and ensure that you’ll always get a repeatable build."
msgstr ""

#: src/guide/why-cargo-exists.md:6
msgid "To accomplish this goal, Cargo does four things:"
msgstr ""

#: src/guide/why-cargo-exists.md:8
msgid "Introduces two metadata files with various bits of project information."
msgstr ""

#: src/guide/why-cargo-exists.md:9
msgid "Fetches and builds your project’s dependencies."
msgstr ""

#: src/guide/why-cargo-exists.md:10
msgid ""
"Invokes `rustc` or another build tool with the correct parameters to build "
"your project."
msgstr ""

#: src/guide/why-cargo-exists.md:12
msgid "Introduces conventions to make working with Rust projects easier."
msgstr ""

#: src/guide/working-on-an-existing-project.md:1
msgid "Working on an Existing Cargo Project"
msgstr ""

#: src/guide/working-on-an-existing-project.md:3
msgid ""
"If you download an existing project that uses Cargo, it’s really easy to get "
"going."
msgstr ""

#: src/guide/working-on-an-existing-project.md:6
msgid ""
"First, get the project from somewhere. In this example, we’ll use `rand` "
"cloned from its repository on GitHub:"
msgstr ""

#: src/guide/working-on-an-existing-project.md:9
msgid ""
"```console\n"
"$ git clone https://github.com/rust-lang-nursery/rand.git\n"
"$ cd rand\n"
"```"
msgstr ""

#: src/guide/working-on-an-existing-project.md:14
msgid "To build, use `cargo build`:"
msgstr ""

#: src/guide/working-on-an-existing-project.md:16
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling rand v0.1.0 (file:///path/to/project/rand)\n"
"```"
msgstr ""

#: src/guide/working-on-an-existing-project.md:21
msgid ""
"This will fetch all of the dependencies and then build them, along with the "
"project."
msgstr ""

#: src/reference/index.md:1
msgid "Cargo Reference"
msgstr ""

#: src/reference/index.md:3
msgid "The reference covers the details of various areas of Cargo."
msgstr ""

#: src/reference/index.md:5
msgid "[Specifying Dependencies](reference/specifying-dependencies.html)"
msgstr ""

#: src/reference/index.md:6
msgid "[The Manifest Format](reference/manifest.html)"
msgstr ""

#: src/reference/index.md:7
msgid "[Configuration](reference/config.html)"
msgstr ""

#: src/reference/index.md:8
msgid "[Environment Variables](reference/environment-variables.html)"
msgstr ""

#: src/reference/index.md:9
msgid "[Build Scripts](reference/build-scripts.html)"
msgstr ""

#: src/reference/index.md:10
msgid "[Publishing on crates.io](reference/publishing.html)"
msgstr ""

#: src/reference/index.md:11
msgid "[Package ID Specifications](reference/pkgid-spec.html)"
msgstr ""

#: src/reference/index.md:12
msgid "[Source Replacement](reference/source-replacement.html)"
msgstr ""

#: src/reference/index.md:13
msgid "[External Tools](reference/external-tools.html)"
msgstr ""

#: src/reference/index.md:14
msgid "[Unstable Features](reference/unstable.html)"
msgstr ""

#: src/reference/build-scripts.md:1
msgid "Build Scripts"
msgstr ""

#: src/reference/build-scripts.md:3
msgid ""
"Some packages need to compile third-party non-Rust code, for example C "
"libraries. Other packages need to link to C libraries which can either be "
"located on the system or possibly need to be built from source. Others still "
"need facilities for functionality such as code generation before building "
"(think parser generators)."
msgstr ""

#: src/reference/build-scripts.md:9
msgid ""
"Cargo does not aim to replace other tools that are well-optimized for these "
"tasks, but it does integrate with them with the `build` configuration option."
msgstr ""

#: src/reference/build-scripts.md:13
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"build = \"build.rs\"\n"
"```"
msgstr ""

#: src/reference/build-scripts.md:19
msgid ""
"The Rust file designated by the `build` command (relative to the package "
"root) will be compiled and invoked before anything else is compiled in the "
"package, allowing your Rust code to depend on the built or generated "
"artifacts. By default Cargo looks up for `\"build.rs\"` file in a package "
"root (even if you do not specify a value for `build`). Use `build = "
"\"custom_build_name.rs\"` to specify a custom build name or `build = false` "
"to disable automatic detection of the build script."
msgstr ""

#: src/reference/build-scripts.md:26
msgid "Some example use cases of the build command are:"
msgstr ""

#: src/reference/build-scripts.md:28
msgid "Building a bundled C library."
msgstr ""

#: src/reference/build-scripts.md:29
msgid "Finding a C library on the host system."
msgstr ""

#: src/reference/build-scripts.md:30
msgid "Generating a Rust module from a specification."
msgstr ""

#: src/reference/build-scripts.md:31
msgid "Performing any platform-specific configuration needed for the crate."
msgstr ""

#: src/reference/build-scripts.md:33
msgid ""
"Each of these use cases will be detailed in full below to give examples of "
"how the build command works."
msgstr ""

#: src/reference/build-scripts.md:36
msgid "Inputs to the Build Script"
msgstr ""

#: src/reference/build-scripts.md:38
msgid ""
"When the build script is run, there are a number of inputs to the build "
"script, all passed in the form of [environment variables](reference/"
"environment-variables.html)."
msgstr ""

#: src/reference/build-scripts.md:41
msgid ""
"In addition to environment variables, the build script’s current directory "
"is the source directory of the build script’s package."
msgstr ""

#: src/reference/build-scripts.md:46
msgid "Outputs of the Build Script"
msgstr ""

#: src/reference/build-scripts.md:48
msgid ""
"All the lines printed to stdout by a build script are written to a file like "
"`target/debug/build/<pkg>/output` (the precise location may depend on your "
"configuration). If you would like to see such output directly in your "
"terminal, invoke cargo as 'very verbose' with the `-vv` flag. Note that if "
"neither the build script nor project source files are modified, subsequent "
"calls to cargo with `-vv` will **not** print output to the terminal because "
"a new build is not executed. Run `cargo clean` before each cargo invocation "
"if you want to ensure that output is always displayed on your terminal. Any "
"line that starts with `cargo:` is interpreted directly by Cargo. This line "
"must be of the form `cargo:key=value`, like the examples below:"
msgstr ""

#: src/reference/build-scripts.md:71
msgid ""
"On the other hand, lines printed to stderr are written to a file like "
"`target/debug/build/<pkg>/stderr` but are not interpreted by cargo."
msgstr ""

#: src/reference/build-scripts.md:74
msgid ""
"There are a few special keys that Cargo recognizes, some affecting how the "
"crate is built:"
msgstr ""

#: src/reference/build-scripts.md:77
msgid ""
"`rustc-link-lib=[KIND=]NAME` indicates that the specified value is a library "
"name and should be passed to the compiler as a `-l` flag. The optional "
"`KIND` can be one of `static`, `dylib` (the default), or `framework`, see "
"`rustc --help` for more details."
msgstr ""

#: src/reference/build-scripts.md:81
msgid ""
"`rustc-link-search=[KIND=]PATH` indicates the specified value is a library "
"search path and should be passed to the compiler as a `-L` flag. The "
"optional `KIND` can be one of `dependency`, `crate`, `native`, `framework` "
"or `all` (the default), see `rustc --help` for more details."
msgstr ""

#: src/reference/build-scripts.md:85
msgid ""
"`rustc-flags=FLAGS` is a set of flags passed to the compiler, only `-l` and "
"`-L` flags are supported."
msgstr ""

#: src/reference/build-scripts.md:87
msgid ""
"`rustc-cfg=FEATURE` indicates that the specified feature will be passed as a "
"`--cfg` flag to the compiler. This is often useful for performing compile-"
"time detection of various features."
msgstr ""

#: src/reference/build-scripts.md:90
msgid ""
"`rustc-env=VAR=VALUE` indicates that the specified environment variable will "
"be added to the environment which the compiler is run within. The value can "
"be then retrieved by the `env!` macro in the compiled crate. This is useful "
"for embedding additional metadata in crate's code, such as the hash of Git "
"HEAD or the unique identifier of a continuous integration server."
msgstr ""

#: src/reference/build-scripts.md:96
msgid ""
"`rerun-if-changed=PATH` is a path to a file or directory which indicates "
"that the build script should be re-run if it changes (detected by a more-"
"recent last-modified timestamp on the file). Normally build scripts are re-"
"run if any file inside the crate root changes, but this can be used to scope "
"changes to just a small set of files. (If this path points to a directory "
"the entire directory will not be traversed for changes -- only changes to "
"the timestamp of the directory itself (which corresponds to some types of "
"changes within the directory, depending on platform) will trigger a rebuild. "
"To request a re-run on any changes within an entire directory, print a line "
"for the directory and another line for everything inside it, recursively.) "
"Note that if the build script itself (or one of its dependencies) changes, "
"then it's rebuilt and rerun unconditionally, so `cargo:rerun-if-"
"changed=build.rs` is almost always redundant (unless you want to ignore "
"changes in all other files except for `build.rs`)."
msgstr ""

#: src/reference/build-scripts.md:110
msgid ""
"`rerun-if-env-changed=VAR` is the name of an environment variable which "
"indicates that if the environment variable's value changes the build script "
"should be rerun. This basically behaves the same as `rerun-if-changed` "
"except that it works with environment variables instead. Note that the "
"environment variables here are intended for global environment variables "
"like `CC` and such, it's not necessary to use this for env vars like "
"`TARGET` that Cargo sets. Also note that if `rerun-if-env-changed` is "
"printed out then Cargo will _only_ rerun the build script if those "
"environment variables change or if files printed out by `rerun-if-changed` "
"change."
msgstr ""

#: src/reference/build-scripts.md:120
msgid ""
"`warning=MESSAGE` is a message that will be printed to the main console "
"after a build script has finished running. Warnings are only shown for path "
"dependencies (that is, those you're working on locally), so for example "
"warnings printed out in crates.io crates are not emitted by default."
msgstr ""

#: src/reference/build-scripts.md:125
msgid ""
"Any other element is a user-defined metadata that will be passed to "
"dependents. More information about this can be found in the [`links`](#the-"
"links-manifest-key) section."
msgstr ""

#: src/reference/build-scripts.md:131
msgid "Build Dependencies"
msgstr ""

#: src/reference/build-scripts.md:133
msgid ""
"Build scripts are also allowed to have dependencies on other Cargo-based "
"crates. Dependencies are declared through the `build-dependencies` section "
"of the manifest."
msgstr ""

#: src/reference/build-scripts.md:137
msgid ""
"```toml\n"
"[build-dependencies]\n"
"foo = { git = \"https://github.com/your-packages/foo\" }\n"
"```"
msgstr ""

#: src/reference/build-scripts.md:142
msgid ""
"The build script **does not** have access to the dependencies listed in the "
"`dependencies` or `dev-dependencies` section (they’re not built yet!). All "
"build dependencies will also not be available to the package itself unless "
"explicitly stated as so."
msgstr ""

#: src/reference/build-scripts.md:147
msgid "The `links` Manifest Key"
msgstr ""

#: src/reference/build-scripts.md:149
msgid ""
"In addition to the manifest key `build`, Cargo also supports a `links` "
"manifest key to declare the name of a native library that is being linked to:"
msgstr ""

#: src/reference/build-scripts.md:152
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"links = \"foo\"\n"
"build = \"build.rs\"\n"
"```"
msgstr ""

#: src/reference/build-scripts.md:159
msgid ""
"This manifest states that the package links to the `libfoo` native library, "
"and it also has a build script for locating and/or building the library. "
"Cargo requires that a `build` command is specified if a `links` entry is "
"also specified."
msgstr ""

#: src/reference/build-scripts.md:164
msgid ""
"The purpose of this manifest key is to give Cargo an understanding about the "
"set of native dependencies that a package has, as well as providing a "
"principled system of passing metadata between package build scripts."
msgstr ""

#: src/reference/build-scripts.md:168
msgid ""
"Primarily, Cargo requires that there is at most one package per `links` "
"value. In other words, it’s forbidden to have two packages link to the same "
"native library. Note, however, that there are [conventions in place](#a-sys-"
"packages) to alleviate this."
msgstr ""

#: src/reference/build-scripts.md:175
msgid ""
"As mentioned above in the output format, each build script can generate an "
"arbitrary set of metadata in the form of key-value pairs. This metadata is "
"passed to the build scripts of **dependent** packages. For example, if "
"`libbar` depends on `libfoo`, then if `libfoo` generates `key=value` as part "
"of its metadata, then the build script of `libbar` will have the environment "
"variables `DEP_FOO_KEY=value`."
msgstr ""

#: src/reference/build-scripts.md:182
msgid ""
"Note that metadata is only passed to immediate dependents, not transitive "
"dependents. The motivation for this metadata passing is outlined in the "
"linking to system libraries case study below."
msgstr ""

#: src/reference/build-scripts.md:186
msgid "Overriding Build Scripts"
msgstr ""

#: src/reference/build-scripts.md:188
msgid ""
"If a manifest contains a `links` key, then Cargo supports overriding the "
"build script specified with a custom library. The purpose of this "
"functionality is to prevent running the build script in question altogether "
"and instead supply the metadata ahead of time."
msgstr ""

#: src/reference/build-scripts.md:193
msgid ""
"To override a build script, place the following configuration in any "
"acceptable Cargo [configuration location](reference/config.html)."
msgstr ""

#: src/reference/build-scripts.md:196
msgid ""
"```toml\n"
"[target.x86_64-unknown-linux-gnu.foo]\n"
"rustc-link-search = [\"/path/to/foo\"]\n"
"rustc-link-lib = [\"foo\"]\n"
"root = \"/path/to/foo\"\n"
"key = \"value\"\n"
"```"
msgstr ""

#: src/reference/build-scripts.md:204
msgid ""
"This section states that for the target `x86_64-unknown-linux-gnu` the "
"library named `foo` has the metadata specified. This metadata is the same as "
"the metadata generated as if the build script had run, providing a number of "
"key/value pairs where the `rustc-flags`, `rustc-link-search`, and `rustc-"
"link-lib` keys are slightly special."
msgstr ""

#: src/reference/build-scripts.md:210
msgid ""
"With this configuration, if a package declares that it links to `foo` then "
"the build script will **not** be compiled or run, and the metadata specified "
"will instead be used."
msgstr ""

#: src/reference/build-scripts.md:214
msgid "Case study: Code generation"
msgstr ""

#: src/reference/build-scripts.md:216
msgid ""
"Some Cargo packages need to have code generated just before they are "
"compiled for various reasons. Here we’ll walk through a simple example which "
"generates a library call as part of the build script."
msgstr ""

#: src/reference/build-scripts.md:220
msgid "First, let’s take a look at the directory structure of this package:"
msgstr ""

#: src/reference/build-scripts.md:232
msgid ""
"Here we can see that we have a `build.rs` build script and our binary in "
"`main.rs`. Next, let’s take a look at the manifest:"
msgstr ""

#: src/reference/build-scripts.md:235
msgid ""
"```toml\n"
"# Cargo.toml\n"
"\n"
"[package]\n"
"name = \"hello-from-generated-code\"\n"
"version = \"0.1.0\"\n"
"authors = [\"you@example.com\"]\n"
"build = \"build.rs\"\n"
"```"
msgstr ""

#: src/reference/build-scripts.md:245
msgid ""
"Here we can see we’ve got a build script specified which we’ll use to "
"generate some code. Let’s see what’s inside the build script:"
msgstr ""

#: src/reference/build-scripts.md:249 src/reference/build-scripts.md:340
#: src/reference/build-scripts.md:383
msgid "// build.rs\n"
msgstr ""

#: src/reference/build-scripts.md:257 src/reference/build-scripts.md:290
#: src/reference/build-scripts.md:347
msgid "\"OUT_DIR\""
msgstr ""

#: src/reference/build-scripts.md:258
msgid "\"hello.rs\""
msgstr ""

#: src/reference/build-scripts.md:261
msgid ""
"b\"\n"
"        pub fn message() -> &'static str {\n"
"            \\\"Hello, World!\\\"\n"
"        }\n"
"    \""
msgstr ""

#: src/reference/build-scripts.md:269
msgid "There’s a couple of points of note here:"
msgstr ""

#: src/reference/build-scripts.md:271
msgid ""
"The script uses the `OUT_DIR` environment variable to discover where the "
"output files should be located. It can use the process’ current working "
"directory to find where the input files should be located, but in this case "
"we don’t have any input files."
msgstr ""

#: src/reference/build-scripts.md:275
msgid ""
"In general, build scripts should not modify any files outside of `OUT_DIR`. "
"It may seem fine on the first blush, but it does cause problems when you use "
"such crate as a dependency, because there's an _implicit_ invariant that "
"sources in `.cargo/registry` should be immutable. `cargo` won't allow such "
"scripts when packaging."
msgstr ""

#: src/reference/build-scripts.md:280
msgid ""
"This script is relatively simple as it just writes out a small generated "
"file. One could imagine that other more fanciful operations could take place "
"such as generating a Rust module from a C header file or another language "
"definition, for example."
msgstr ""

#: src/reference/build-scripts.md:285
msgid "Next, let’s peek at the library itself:"
msgstr ""

#: src/reference/build-scripts.md:288 src/reference/build-scripts.md:434
msgid "// src/main.rs\n"
msgstr ""

#: src/reference/build-scripts.md:290
msgid "\"/hello.rs\""
msgstr ""

#: src/reference/build-scripts.md:293
msgid "\"{}\""
msgstr ""

#: src/reference/build-scripts.md:297
msgid ""
"This is where the real magic happens. The library is using the rustc-defined "
"`include!` macro in combination with the `concat!` and `env!` macros to "
"include the generated file (`hello.rs`) into the crate’s compilation."
msgstr ""

#: src/reference/build-scripts.md:301
msgid ""
"Using the structure shown here, crates can include any number of generated "
"files from the build script itself."
msgstr ""

#: src/reference/build-scripts.md:304
msgid "Case study: Building some native code"
msgstr ""

#: src/reference/build-scripts.md:306
msgid ""
"Sometimes it’s necessary to build some native C or C++ code as part of a "
"package. This is another excellent use case of leveraging the build script "
"to build a native library before the Rust crate itself. As an example, we’ll "
"create a Rust library which calls into C to print “Hello, World!”."
msgstr ""

#: src/reference/build-scripts.md:311
msgid "Like above, let’s first take a look at the project layout:"
msgstr ""

#: src/reference/build-scripts.md:324
msgid "Pretty similar to before! Next, the manifest:"
msgstr ""

#: src/reference/build-scripts.md:326
msgid ""
"```toml\n"
"# Cargo.toml\n"
"\n"
"[package]\n"
"name = \"hello-world-from-c\"\n"
"version = \"0.1.0\"\n"
"authors = [\"you@example.com\"]\n"
"build = \"build.rs\"\n"
"```"
msgstr ""

#: src/reference/build-scripts.md:336
msgid ""
"For now we’re not going to use any build dependencies, so let’s take a look "
"at the build script now:"
msgstr ""

#: src/reference/build-scripts.md:349
msgid ""
"// note that there are a number of downsides to this approach, the comments\n"
"    // below detail how to improve the portability of these commands.\n"
msgstr ""

#: src/reference/build-scripts.md:351
msgid "\"gcc\""
msgstr ""

#: src/reference/build-scripts.md:351 src/reference/build-scripts.md:391
msgid "\"src/hello.c\""
msgstr ""

#: src/reference/build-scripts.md:351
msgid "\"-c\""
msgstr ""

#: src/reference/build-scripts.md:351
msgid "\"-fPIC\""
msgstr ""

#: src/reference/build-scripts.md:351
msgid "\"-o\""
msgstr ""

#: src/reference/build-scripts.md:352
msgid "\"{}/hello.o\""
msgstr ""

#: src/reference/build-scripts.md:354
msgid "\"ar\""
msgstr ""

#: src/reference/build-scripts.md:354
msgid "\"crus\""
msgstr ""

#: src/reference/build-scripts.md:354
msgid "\"libhello.a\""
msgstr ""

#: src/reference/build-scripts.md:354
msgid "\"hello.o\""
msgstr ""

#: src/reference/build-scripts.md:358
msgid "\"cargo:rustc-link-search=native={}\""
msgstr ""

#: src/reference/build-scripts.md:359
msgid "\"cargo:rustc-link-lib=static=hello\""
msgstr ""

#: src/reference/build-scripts.md:363
msgid ""
"This build script starts out by compiling our C file into an object file (by "
"invoking `gcc`) and then converting this object file into a static library "
"(by invoking `ar`). The final step is feedback to Cargo itself to say that "
"our output was in `out_dir` and the compiler should link the crate to "
"`libhello.a` statically via the `-l static=hello` flag."
msgstr ""

#: src/reference/build-scripts.md:369
msgid "Note that there are a number of drawbacks to this hardcoded approach:"
msgstr ""

#: src/reference/build-scripts.md:371
msgid ""
"The `gcc` command itself is not portable across platforms. For example it’s "
"unlikely that Windows platforms have `gcc`, and not even all Unix platforms "
"may have `gcc`. The `ar` command is also in a similar situation."
msgstr ""

#: src/reference/build-scripts.md:374
msgid ""
"These commands do not take cross-compilation into account. If we’re cross "
"compiling for a platform such as Android it’s unlikely that `gcc` will "
"produce an ARM executable."
msgstr ""

#: src/reference/build-scripts.md:378
msgid ""
"Not to fear, though, this is where a `build-dependencies` entry would help! "
"The Cargo ecosystem has a number of packages to make this sort of task much "
"easier, portable, and standardized. For example, the build script could be "
"written as:"
msgstr ""

#: src/reference/build-scripts.md:384
msgid ""
"// Bring in a dependency on an externally maintained `cc` package which "
"manages\n"
"// invoking the C compiler.\n"
msgstr ""

#: src/reference/build-scripts.md:392
msgid "\"hello\""
msgstr ""

#: src/reference/build-scripts.md:396
msgid ""
"Add a build time dependency on the `cc` crate with the following addition to "
"your `Cargo.toml`:"
msgstr ""

#: src/reference/build-scripts.md:399
msgid ""
"```toml\n"
"[build-dependencies]\n"
"cc = \"1.0\"\n"
"```"
msgstr ""

#: src/reference/build-scripts.md:404
msgid ""
"The [`cc` crate](https://crates.io/crates/cc) abstracts a range of build "
"script requirements for C code:"
msgstr ""

#: src/reference/build-scripts.md:407
msgid ""
"It invokes the appropriate compiler (MSVC for windows, `gcc` for MinGW, `cc` "
"for Unix platforms, etc.)."
msgstr ""

#: src/reference/build-scripts.md:409
msgid ""
"It takes the `TARGET` variable into account by passing appropriate flags to "
"the compiler being used."
msgstr ""

#: src/reference/build-scripts.md:411
msgid ""
"Other environment variables, such as `OPT_LEVEL`, `DEBUG`, etc., are all "
"handled automatically."
msgstr ""

#: src/reference/build-scripts.md:413
msgid ""
"The stdout output and `OUT_DIR` locations are also handled by the `cc` "
"library."
msgstr ""

#: src/reference/build-scripts.md:416
msgid ""
"Here we can start to see some of the major benefits of farming as much "
"functionality as possible out to common build dependencies rather than "
"duplicating logic across all build scripts!"
msgstr ""

#: src/reference/build-scripts.md:420
msgid ""
"Back to the case study though, let’s take a quick look at the contents of "
"the `src` directory:"
msgstr ""

#: src/reference/build-scripts.md:424
msgid "// src/hello.c\n"
msgstr ""

#: src/reference/build-scripts.md:426
msgid "<stdio.h>"
msgstr ""

#: src/reference/build-scripts.md:429
msgid "\"Hello, World!\\n\""
msgstr ""

#: src/reference/build-scripts.md:435
msgid ""
"// Note the lack of the `#[link]` attribute. We’re delegating the "
"responsibility\n"
"// of selecting what to link to over to the build script rather than "
"hardcoding\n"
"// it in the source file.\n"
msgstr ""

#: src/reference/build-scripts.md:446
msgid ""
"And there we go! This should complete our example of building some C code "
"from a Cargo package using the build script itself. This also shows why "
"using a build dependency can be crucial in many situations and even much "
"more concise!"
msgstr ""

#: src/reference/build-scripts.md:450
msgid ""
"We’ve also seen a brief example of how a build script can use a crate as a "
"dependency purely for the build process and not for the crate itself at "
"runtime."
msgstr ""

#: src/reference/build-scripts.md:453
msgid "Case study: Linking to system libraries"
msgstr ""

#: src/reference/build-scripts.md:455
msgid ""
"The final case study here will be investigating how a Cargo library links to "
"a system library and how the build script is leveraged to support this use "
"case."
msgstr ""

#: src/reference/build-scripts.md:458
msgid ""
"Quite frequently a Rust crate wants to link to a native library often "
"provided on the system to bind its functionality or just use it as part of "
"an implementation detail. This is quite a nuanced problem when it comes to "
"performing this in a platform-agnostic fashion, and the purpose of a build "
"script is again to farm out as much of this as possible to make this as easy "
"as possible for consumers."
msgstr ""

#: src/reference/build-scripts.md:465
msgid ""
"As an example to follow, let’s take a look at one of [Cargo’s own "
"dependencies](https://github.com/alexcrichton/git2-rs/tree/master/libgit2-"
"sys), [libgit2](https://github.com/libgit2/libgit2). The C library has a "
"number of constraints:"
msgstr ""

#: src/reference/build-scripts.md:472
msgid ""
"It has an optional dependency on OpenSSL on Unix to implement the https "
"transport."
msgstr ""

#: src/reference/build-scripts.md:474
msgid ""
"It has an optional dependency on libssh2 on all platforms to implement the "
"ssh transport."
msgstr ""

#: src/reference/build-scripts.md:476
msgid "It is often not installed on all systems by default."
msgstr ""

#: src/reference/build-scripts.md:477
msgid "It can be built from source using `cmake`."
msgstr ""

#: src/reference/build-scripts.md:479
msgid ""
"To visualize what’s going on here, let’s take a look at the manifest for the "
"relevant Cargo package that links to the native C library."
msgstr ""

#: src/reference/build-scripts.md:482
msgid ""
"```toml\n"
"[package]\n"
"name = \"libgit2-sys\"\n"
"version = \"0.1.0\"\n"
"authors = [\"...\"]\n"
"links = \"git2\"\n"
"build = \"build.rs\"\n"
"\n"
"[dependencies]\n"
"libssh2-sys = { git = \"https://github.com/alexcrichton/ssh2-rs\" }\n"
"\n"
"[target.'cfg(unix)'.dependencies]\n"
"openssl-sys = { git = \"https://github.com/alexcrichton/openssl-sys\" }\n"
"\n"
"# ...\n"
"```"
msgstr ""

#: src/reference/build-scripts.md:499
msgid ""
"As the above manifests show, we’ve got a `build` script specified, but it’s "
"worth noting that this example has a `links` entry which indicates that the "
"crate (`libgit2-sys`) links to the `git2` native library."
msgstr ""

#: src/reference/build-scripts.md:503
msgid ""
"Here we also see that we chose to have the Rust crate have an unconditional "
"dependency on `libssh2` via the `libssh2-sys` crate, as well as a platform-"
"specific dependency on `openssl-sys` for \\*nix (other variants elided for "
"now). It may seem a little counterintuitive to express _C dependencies_ in "
"the _Cargo manifest_, but this is actually using one of Cargo’s conventions "
"in this space."
msgstr ""

#: src/reference/build-scripts.md:510
msgid "`*-sys` Packages"
msgstr ""

#: src/reference/build-scripts.md:512
msgid ""
"To alleviate linking to system libraries, crates.io has a _convention_ of "
"package naming and functionality. Any package named `foo-sys` should provide "
"two major pieces of functionality:"
msgstr ""

#: src/reference/build-scripts.md:516
msgid ""
"The library crate should link to the native library `libfoo`. This will "
"often probe the current system for `libfoo` before resorting to building "
"from source."
msgstr ""

#: src/reference/build-scripts.md:519
msgid ""
"The library crate should provide **declarations** for functions in `libfoo`, "
"but **not** bindings or higher-level abstractions."
msgstr ""

#: src/reference/build-scripts.md:522
msgid ""
"The set of `*-sys` packages provides a common set of dependencies for "
"linking to native libraries. There are a number of benefits earned from "
"having this convention of native-library-related packages:"
msgstr ""

#: src/reference/build-scripts.md:526
msgid ""
"Common dependencies on `foo-sys` alleviates the above rule about one package "
"per value of `links`."
msgstr ""

#: src/reference/build-scripts.md:528
msgid ""
"A common dependency allows centralizing logic on discovering `libfoo` itself "
"(or building it from source)."
msgstr ""

#: src/reference/build-scripts.md:530
msgid "These dependencies are easily overridable."
msgstr ""

#: src/reference/build-scripts.md:532
msgid "Building libgit2"
msgstr ""

#: src/reference/build-scripts.md:534
msgid ""
"Now that we’ve got libgit2’s dependencies sorted out, we need to actually "
"write the build script. We’re not going to look at specific snippets of code "
"here and instead only take a look at the high-level details of the build "
"script of `libgit2-sys`. This is not recommending all packages follow this "
"strategy, but rather just outlining one specific strategy."
msgstr ""

#: src/reference/build-scripts.md:540
msgid ""
"The first step of the build script should do is to query whether libgit2 is "
"already installed on the host system. To do this we’ll leverage the "
"preexisting tool `pkg-config` (when its available). We’ll also use a `build-"
"dependencies` section to refactor out all the `pkg-config` related code (or "
"someone’s already done that!)."
msgstr ""

#: src/reference/build-scripts.md:546
msgid ""
"If `pkg-config` failed to find libgit2, or if `pkg-config` just wasn’t "
"installed, the next step is to build libgit2 from bundled source code "
"(distributed as part of `libgit2-sys` itself). There are a few nuances when "
"doing so that we need to take into account, however:"
msgstr ""

#: src/reference/build-scripts.md:551
msgid ""
"The build system of libgit2, `cmake`, needs to be able to find libgit2’s "
"optional dependency of libssh2. We’re sure we’ve already built it (it’s a "
"Cargo dependency), we just need to communicate this information. To do this "
"we leverage the metadata format to communicate information between build "
"scripts. In this example the libssh2 package printed out `cargo:root=...` to "
"tell us where libssh2 is installed at, and we can then pass this along to "
"cmake with the `CMAKE_PREFIX_PATH` environment variable."
msgstr ""

#: src/reference/build-scripts.md:559
msgid ""
"We’ll need to handle some `CFLAGS` values when compiling C code (and tell "
"`cmake` about this). Some flags we may want to pass are `-m64` for 64-bit "
"code, `-m32` for 32-bit code, or `-fPIC` for 64-bit code as well."
msgstr ""

#: src/reference/build-scripts.md:563
msgid ""
"Finally, we’ll invoke `cmake` to place all output into the `OUT_DIR` "
"environment variable, and then we’ll print the necessary metadata to "
"instruct rustc how to link to libgit2."
msgstr ""

#: src/reference/build-scripts.md:567
msgid ""
"Most of the functionality of this build script is easily refactorable into "
"common dependencies, so our build script isn’t quite as intimidating as this "
"descriptions! In reality it’s expected that build scripts are quite succinct "
"by farming logic such as above to build dependencies."
msgstr ""

#: src/reference/config.md:1
msgid "Configuration"
msgstr ""

#: src/reference/config.md:3
msgid ""
"This document will explain how Cargo’s configuration system works, as well "
"as available keys or configuration.  For configuration of a project through "
"its manifest, see the [manifest format](reference/manifest.html)."
msgstr ""

#: src/reference/config.md:7
msgid "Hierarchical structure"
msgstr ""

#: src/reference/config.md:10
msgid ""
"Cargo allows local configuration for a particular project as well as global "
"configuration, like git. Cargo extends this to a hierarchical strategy. If, "
"for example, Cargo were invoked in `/projects/foo/bar/baz`, then the "
"following configuration files would be probed for and unified in this order:"
msgstr ""

#: src/reference/config.md:15
msgid "`/projects/foo/bar/baz/.cargo/config`"
msgstr ""

#: src/reference/config.md:16
msgid "`/projects/foo/bar/.cargo/config`"
msgstr ""

#: src/reference/config.md:17
msgid "`/projects/foo/.cargo/config`"
msgstr ""

#: src/reference/config.md:18
msgid "`/projects/.cargo/config`"
msgstr ""

#: src/reference/config.md:19
msgid "`/.cargo/config`"
msgstr ""

#: src/reference/config.md:20
msgid "`$HOME/.cargo/config`"
msgstr ""

#: src/reference/config.md:22
msgid ""
"With this structure, you can specify configuration per-project, and even "
"possibly check it into version control. You can also specify personal "
"defaults with a configuration file in your home directory."
msgstr ""

#: src/reference/config.md:26
msgid "Configuration format"
msgstr ""

#: src/reference/config.md:28
msgid ""
"All configuration is currently in the [TOML format](https://github.com/toml-"
"lang/toml) (like the manifest), with simple key-value pairs inside of "
"sections (tables) which all get merged together."
msgstr ""

#: src/reference/config.md:34
msgid "Configuration keys"
msgstr ""

#: src/reference/config.md:36
msgid ""
"All of the following keys are optional, and their defaults are listed as "
"their value unless otherwise noted."
msgstr ""

#: src/reference/config.md:39
msgid ""
"Key values that specify a tool may be given as an absolute path, a relative "
"path or as a pathless tool name. Absolute paths and pathless tool names are "
"used as given. Relative paths are resolved relative to the parent directory "
"of the `.cargo` directory of the config file that the value resides within."
msgstr ""

#: src/reference/config.md:44
msgid ""
"```toml\n"
"# An array of paths to local repositories which are to be used as overrides "
"for\n"
"# dependencies. For more information see the Specifying Dependencies guide.\n"
"paths = [\"/path/to/override\"]\n"
"\n"
"[cargo-new]\n"
"# This is your name/email to place in the `authors` section of a new Cargo."
"toml\n"
"# that is generated. If not present, then `git` will be probed, and if that "
"is\n"
"# not present then `$USER` and `$EMAIL` will be used.\n"
"name = \"...\"\n"
"email = \"...\"\n"
"\n"
"# By default `cargo new` will initialize a new Git repository. This key can "
"be\n"
"# set to `hg` to create a Mercurial repository, or `none` to disable this\n"
"# behavior.\n"
"vcs = \"none\"\n"
"\n"
"# For the following sections, $triple refers to any valid target triple, not "
"the\n"
"# literal string \"$triple\", and it will apply whenever that target triple "
"is\n"
"# being compiled to. 'cfg(...)' refers to the Rust-like `#[cfg]` syntax for\n"
"# conditional compilation.\n"
"[target.$triple]\n"
"# This is the linker which is passed to rustc (via `-C linker=`) when the "
"`$triple`\n"
"# is being compiled for. By default this flag is not passed to the "
"compiler.\n"
"linker = \"..\"\n"
"# Same but for the library archiver which is passed to rustc via `-C ar=`.\n"
"ar = \"..\"\n"
"# If a runner is provided, compiled targets for the `$triple` will be "
"executed\n"
"# by invoking the specified runner executable with actual target as first "
"argument.\n"
"# This applies to `cargo run`, `cargo test` and `cargo bench` commands.\n"
"# By default compiled targets are executed directly.\n"
"runner = \"..\"\n"
"# custom flags to pass to all compiler invocations that target $triple\n"
"# this value overrides build.rustflags when both are present\n"
"rustflags = [\"..\", \"..\"]\n"
"\n"
"[target.'cfg(...)']\n"
"# Similar for the $triple configuration, but using the `cfg` syntax.\n"
"# If several `cfg` and $triple targets are candidates, then the rustflags\n"
"# are concatenated. The `cfg` syntax only applies to rustflags, and not to\n"
"# linker.\n"
"rustflags = [\"..\", \"..\"]\n"
"\n"
"# Configuration keys related to the registry\n"
"[registry]\n"
"index = \"...\"   # URL of the registry index (defaults to the central "
"repository)\n"
"token = \"...\"   # Access token (found on the central repo’s website)\n"
"\n"
"[http]\n"
"proxy = \"host:port\" # HTTP proxy to use for HTTP requests (defaults to "
"none)\n"
"                    # in libcurl format, e.g. \"socks5h://host:port\"\n"
"timeout = 60000     # Timeout for each HTTP request, in milliseconds\n"
"cainfo = \"cert.pem\" # Path to Certificate Authority (CA) bundle "
"(optional)\n"
"check-revoke = true # Indicates whether SSL certs are checked for "
"revocation\n"
"\n"
"[build]\n"
"jobs = 1                  # number of parallel jobs, defaults to # of CPUs\n"
"rustc = \"rustc\"           # the rust compiler tool\n"
"rustdoc = \"rustdoc\"       # the doc generator tool\n"
"target = \"triple\"         # build for the target triple\n"
"target-dir = \"target\"     # path of where to place all generated "
"artifacts\n"
"rustflags = [\"..\", \"..\"]  # custom flags to pass to all compiler "
"invocations\n"
"incremental = true        # whether or not to enable incremental "
"compilation\n"
"dep-info-basedir = \"..\"   # full path for the base directory for targets "
"in depfiles\n"
"\n"
"[term]\n"
"verbose = false        # whether cargo provides verbose output\n"
"color = 'auto'         # whether cargo colorizes output\n"
"\n"
"# Network configuration\n"
"[net]\n"
"retry = 2 # number of times a network call will automatically retried\n"
"\n"
"# Alias cargo commands. The first 3 aliases are built in. If your\n"
"# command requires grouped whitespace use the list format.\n"
"[alias]\n"
"b = \"build\"\n"
"t = \"test\"\n"
"r = \"run\"\n"
"rr = \"run --release\"\n"
"space_example = [\"run\", \"--release\", \"--\", \"\\\"command list\\\"\"]\n"
"```"
msgstr ""

#: src/reference/config.md:127
msgid "Environment variables"
msgstr ""

#: src/reference/config.md:129
msgid ""
"Cargo can also be configured through environment variables in addition to "
"the TOML syntax above. For each configuration key above of the form `foo."
"bar` the environment variable `CARGO_FOO_BAR` can also be used to define the "
"value. For example the `build.jobs` key can also be defined by "
"`CARGO_BUILD_JOBS`."
msgstr ""

#: src/reference/config.md:134
msgid ""
"Environment variables will take precedent over TOML configuration, and "
"currently only integer, boolean, and string keys are supported to be defined "
"by environment variables. This means that [source replacement](reference/"
"source-replacement.html), which is expressed by tables, cannot be configured "
"through environment variables."
msgstr ""

#: src/reference/config.md:139
msgid ""
"In addition to the system above, Cargo recognizes a few other specific "
"[environment variables](reference/environment-variables.html)."
msgstr ""

#: src/reference/environment-variables.md:1
msgid "Environment Variables"
msgstr ""

#: src/reference/environment-variables.md:3
msgid ""
"Cargo sets and reads a number of environment variables which your code can "
"detect or override. Here is a list of the variables Cargo sets, organized by "
"when it interacts with them:"
msgstr ""

#: src/reference/environment-variables.md:7
msgid "Environment variables Cargo reads"
msgstr ""

#: src/reference/environment-variables.md:9
msgid ""
"You can override these environment variables to change Cargo's behavior on "
"your system:"
msgstr ""

#: src/reference/environment-variables.md:12
msgid ""
"`CARGO_HOME` — Cargo maintains a local cache of the registry index and of "
"git checkouts of crates.  By default these are stored under `$HOME/.cargo`, "
"but this variable overrides the location of this directory. Once a crate is "
"cached it is not removed by the clean command."
msgstr ""

#: src/reference/environment-variables.md:16
msgid ""
"`CARGO_TARGET_DIR` — Location of where to place all generated artifacts, "
"relative to the current working directory."
msgstr ""

#: src/reference/environment-variables.md:18
msgid ""
"`RUSTC` — Instead of running `rustc`, Cargo will execute this specified "
"compiler instead."
msgstr ""

#: src/reference/environment-variables.md:20
msgid ""
"`RUSTC_WRAPPER` — Instead of simply running `rustc`, Cargo will execute this "
"specified wrapper instead, passing as its commandline arguments the rustc "
"invocation, with the first argument being rustc."
msgstr ""

#: src/reference/environment-variables.md:23
msgid ""
"`RUSTDOC` — Instead of running `rustdoc`, Cargo will execute this specified "
"`rustdoc` instance instead."
msgstr ""

#: src/reference/environment-variables.md:25
msgid ""
"`RUSTDOCFLAGS` — A space-separated list of custom flags to pass to all "
"`rustdoc` invocations that Cargo performs. In contrast with `cargo rustdoc`, "
"this is useful for passing a flag to _all_ `rustdoc` instances."
msgstr ""

#: src/reference/environment-variables.md:28
msgid ""
"`RUSTFLAGS` — A space-separated list of custom flags to pass to all compiler "
"invocations that Cargo performs. In contrast with `cargo rustc`, this is "
"useful for passing a flag to _all_ compiler instances."
msgstr ""

#: src/reference/environment-variables.md:31
msgid ""
"`CARGO_INCREMENTAL` — If this is set to 1 then Cargo will force incremental "
"compilation to be enabled for the current compilation, and when set to 0 it "
"will force disabling it. If this env var isn't present then cargo's defaults "
"will otherwise be used."
msgstr ""

#: src/reference/environment-variables.md:35
msgid ""
"`CARGO_CACHE_RUSTC_INFO` — If this is set to 0 then Cargo will not try to "
"cache compiler version information."
msgstr ""

#: src/reference/environment-variables.md:38
msgid ""
"Note that Cargo will also read environment variables for `.cargo/config` "
"configuration values, as described in [that documentation](reference/config."
"html#environment-variables)"
msgstr ""

#: src/reference/environment-variables.md:43
msgid "Environment variables Cargo sets for crates"
msgstr ""

#: src/reference/environment-variables.md:45
msgid ""
"Cargo exposes these environment variables to your crate when it is compiled. "
"Note that this applies for test binaries as well. To get the value of any of "
"these variables in a Rust program, do this:"
msgstr ""

#: src/reference/environment-variables.md:50
msgid "\"CARGO_PKG_VERSION\""
msgstr ""

#: src/reference/environment-variables.md:53
msgid "`version` will now contain the value of `CARGO_PKG_VERSION`."
msgstr ""

#: src/reference/environment-variables.md:55
#: src/reference/environment-variables.md:82
#: src/reference/environment-variables.md:143
msgid "`CARGO` - Path to the `cargo` binary performing the build."
msgstr ""

#: src/reference/environment-variables.md:56
msgid ""
"`CARGO_MANIFEST_DIR` - The directory containing the manifest of your package."
msgstr ""

#: src/reference/environment-variables.md:57
msgid "`CARGO_PKG_VERSION` - The full version of your package."
msgstr ""

#: src/reference/environment-variables.md:58
msgid "`CARGO_PKG_VERSION_MAJOR` - The major version of your package."
msgstr ""

#: src/reference/environment-variables.md:59
msgid "`CARGO_PKG_VERSION_MINOR` - The minor version of your package."
msgstr ""

#: src/reference/environment-variables.md:60
msgid "`CARGO_PKG_VERSION_PATCH` - The patch version of your package."
msgstr ""

#: src/reference/environment-variables.md:61
msgid "`CARGO_PKG_VERSION_PRE` - The pre-release version of your package."
msgstr ""

#: src/reference/environment-variables.md:62
msgid ""
"`CARGO_PKG_AUTHORS` - Colon separated list of authors from the manifest of "
"your package."
msgstr ""

#: src/reference/environment-variables.md:63
msgid "`CARGO_PKG_NAME` - The name of your package."
msgstr ""

#: src/reference/environment-variables.md:64
msgid "`CARGO_PKG_DESCRIPTION` - The description of your package."
msgstr ""

#: src/reference/environment-variables.md:65
msgid "`CARGO_PKG_HOMEPAGE` - The home page of your package."
msgstr ""

#: src/reference/environment-variables.md:66
msgid ""
"`OUT_DIR` - If the package has a build script, this is set to the folder "
"where the build script should place its output.  See below for more "
"information."
msgstr ""

#: src/reference/environment-variables.md:69
msgid "Environment variables Cargo sets for build scripts"
msgstr ""

#: src/reference/environment-variables.md:71
msgid ""
"Cargo sets several environment variables when build scripts are run. Because "
"these variables are not yet set when the build script is compiled, the above "
"example using `env!` won't work and instead you'll need to retrieve the "
"values when the build script is run:"
msgstr ""

#: src/reference/environment-variables.md:80
msgid "`out_dir` will now contain the value of `OUT_DIR`."
msgstr ""

#: src/reference/environment-variables.md:83
msgid ""
"`CARGO_MANIFEST_DIR` - The directory containing the manifest for the package "
"being built (the package containing the build script). Also note that this "
"is the value of the current working directory of the build script when it "
"starts."
msgstr ""

#: src/reference/environment-variables.md:88
msgid "`CARGO_MANIFEST_LINKS` - the manifest `links` value."
msgstr ""

#: src/reference/environment-variables.md:89
msgid ""
"`CARGO_FEATURE_<name>` - For each activated feature of the package being "
"built, this environment variable will be present where `<name>` is the name "
"of the feature uppercased and having `-` translated to `_`."
msgstr ""

#: src/reference/environment-variables.md:93
msgid ""
"`CARGO_CFG_<cfg>` - For each [configuration option](https://doc.rust-lang."
"org/reference/attributes.html#conditional-compilation) of the package being "
"built, this environment variable will contain the value of the "
"configuration, where `<cfg>` is the name of the configuration uppercased and "
"having `-` translated to `_`. Boolean configurations are present if they are "
"set, and not present otherwise. Configurations with multiple values are "
"joined to a single variable with the values delimited by `,`."
msgstr ""

#: src/reference/environment-variables.md:102
msgid ""
"`OUT_DIR` - the folder in which all output should be placed. This folder is "
"inside the build directory for the package being built, and it is unique for "
"the package in question."
msgstr ""

#: src/reference/environment-variables.md:105
msgid ""
"`TARGET` - the target triple that is being compiled for. Native code should "
"be compiled for this triple. Some more information about target triples can "
"be found in [clang’s own documentation](http://clang.llvm.org/docs/"
"CrossCompilation.html#target-triple)."
msgstr ""

#: src/reference/environment-variables.md:108
msgid "`HOST` - the host triple of the rust compiler."
msgstr ""

#: src/reference/environment-variables.md:109
msgid ""
"`NUM_JOBS` - the parallelism specified as the top-level parallelism. This "
"can be useful to pass a `-j` parameter to a system like `make`. Note that "
"care should be taken when interpreting this environment variable. For "
"historical purposes this is still provided but recent versions of Cargo, for "
"example, do not need to run `make              -j` as it'll automatically "
"happen. Cargo implements its own [jobserver](https://www.gnu.org/software/"
"make/manual/html_node/Job-Slots.html) and will allow build scripts to "
"inherit this information, so programs compatible with GNU make jobservers "
"will already have appropriately configured parallelism."
msgstr ""

#: src/reference/environment-variables.md:118
msgid ""
"`OPT_LEVEL`, `DEBUG` - values of the corresponding variables for the profile "
"currently being built."
msgstr ""

#: src/reference/environment-variables.md:120
msgid "`PROFILE` - `release` for release builds, `debug` for other builds."
msgstr ""

#: src/reference/environment-variables.md:121
msgid ""
"`DEP_<name>_<key>` - For more information about this set of environment "
"variables, see build script documentation about [`links`](reference/build-"
"scripts.html#the-links-manifest-key)."
msgstr ""

#: src/reference/environment-variables.md:123
msgid ""
"`RUSTC`, `RUSTDOC` - the compiler and documentation generator that Cargo has "
"resolved to use, passed to the build script so it might use it as well."
msgstr ""

#: src/reference/environment-variables.md:126
msgid ""
"`RUSTC_LINKER` - The path to the linker binary that Cargo has resolved to "
"use for the current target, if specified. The linker can be changed by "
"editing `.cargo/config`; see the documentation about [cargo configuration]"
"(reference/config.html) for more information."
msgstr ""

#: src/reference/environment-variables.md:138
msgid "Environment variables Cargo sets for 3rd party subcommands"
msgstr ""

#: src/reference/environment-variables.md:140
msgid ""
"Cargo exposes this environment variable to 3rd party subcommands (ie. "
"programs named `cargo-foobar` placed in `$PATH`):"
msgstr ""

#: src/reference/external-tools.md:1
msgid "External tools"
msgstr ""

#: src/reference/external-tools.md:3
msgid ""
"One of the goals of Cargo is simple integration with third-party tools, like "
"IDEs and other build systems. To make integration easier, Cargo has several "
"facilities:"
msgstr ""

#: src/reference/external-tools.md:7
msgid ""
"a `cargo metadata` command, which outputs project structure and dependencies "
"information in JSON,"
msgstr ""

#: src/reference/external-tools.md:10
msgid ""
"a `--message-format` flag, which outputs information about a particular "
"build, and"
msgstr ""

#: src/reference/external-tools.md:13
msgid "support for custom subcommands."
msgstr ""

#: src/reference/external-tools.md:16
msgid "Information about project structure"
msgstr ""

#: src/reference/external-tools.md:18
msgid ""
"You can use `cargo metadata` command to get information about project "
"structure and dependencies. The output of the command looks like this:"
msgstr ""

#: src/reference/external-tools.md:21
msgid ""
"```text\n"
"{\n"
"  // Integer version number of the format.\n"
"  \"version\": integer,\n"
"\n"
"  // List of packages for this workspace, including dependencies.\n"
"  \"packages\": [\n"
"    {\n"
"      // Opaque package identifier.\n"
"      \"id\": PackageId,\n"
"\n"
"      \"name\": string,\n"
"\n"
"      \"version\": string,\n"
"\n"
"      \"source\": SourceId,\n"
"\n"
"      // A list of declared dependencies, see `resolve` field for actual "
"dependencies.\n"
"      \"dependencies\": [ Dependency ],\n"
"\n"
"      \"targets: [ Target ],\n"
"\n"
"      // Path to Cargo.toml\n"
"      \"manifest_path\": string,\n"
"    }\n"
"  ],\n"
"\n"
"  \"workspace_members\": [ PackageId ],\n"
"\n"
"  // Dependencies graph.\n"
"  \"resolve\": {\n"
"     \"nodes\": [\n"
"       {\n"
"         \"id\": PackageId,\n"
"         \"dependencies\": [ PackageId ]\n"
"       }\n"
"     ]\n"
"  }\n"
"}\n"
"```"
msgstr ""

#: src/reference/external-tools.md:62
msgid ""
"The format is stable and versioned. When calling `cargo metadata`, you "
"should pass `--format-version` flag explicitly to avoid forward "
"incompatibility hazard."
msgstr ""

#: src/reference/external-tools.md:66
msgid ""
"If you are using Rust, there is [cargo_metadata](https://crates.io/crates/"
"cargo_metadata) crate."
msgstr ""

#: src/reference/external-tools.md:71
msgid "Information about build"
msgstr ""

#: src/reference/external-tools.md:73
msgid ""
"When passing `--message-format=json`, Cargo will output the following "
"information during the build:"
msgstr ""

#: src/reference/external-tools.md:76
msgid "compiler errors and warnings,"
msgstr ""

#: src/reference/external-tools.md:78
msgid "produced artifacts,"
msgstr ""

#: src/reference/external-tools.md:80
msgid "results of the build scripts (for example, native dependencies)."
msgstr ""

#: src/reference/external-tools.md:82
msgid ""
"The output goes to stdout in the JSON object per line format. The `reason` "
"field distinguishes different kinds of messages."
msgstr ""

#: src/reference/external-tools.md:85
msgid ""
"Information about dependencies in the Makefile-compatible format is stored "
"in the `.d` files alongside the artifacts."
msgstr ""

#: src/reference/external-tools.md:89
msgid "Custom subcommands"
msgstr ""

#: src/reference/external-tools.md:91
msgid ""
"Cargo is designed to be extensible with new subcommands without having to "
"modify Cargo itself. This is achieved by translating a cargo invocation of "
"the form cargo `(?<command>[^ ]+)` into an invocation of an external tool "
"`cargo-${command}`. The external tool must be present in one of the user's "
"`$PATH` directories."
msgstr ""

#: src/reference/external-tools.md:97
msgid ""
"When Cargo invokes a custom subcommand, the first argument to the subcommand "
"will be the filename of the custom subcommand, as usual. The second argument "
"will be the subcommand name itself. For example, the second argument would "
"be `${command}` when invoking `cargo-${command}`. Any additional arguments "
"on the command line will be forwarded unchanged."
msgstr ""

#: src/reference/external-tools.md:103
msgid ""
"Cargo can also display the help output of a custom subcommand with `cargo "
"help ${command}`. Cargo assumes that the subcommand will print a help "
"message if its third argument is `--help`. So, `cargo help ${command}` would "
"invoke `cargo-${command} ${command} --help`."
msgstr ""

#: src/reference/external-tools.md:108
msgid ""
"Custom subcommands may use the `CARGO` environment variable to call back to "
"Cargo. Alternatively, it can link to `cargo` crate as a library, but this "
"approach has drawbacks:"
msgstr ""

#: src/reference/external-tools.md:112
msgid "Cargo as a library is unstable: the  API may change without deprecation"
msgstr ""

#: src/reference/external-tools.md:114
msgid ""
"versions of the linked Cargo library may be different from the Cargo binary"
msgstr ""

#: src/reference/pkgid-spec.md:1
msgid "Package ID Specifications"
msgstr ""

#: src/reference/pkgid-spec.md:3
msgid "Package ID specifications"
msgstr ""

#: src/reference/pkgid-spec.md:5
msgid ""
"Subcommands of Cargo frequently need to refer to a particular package within "
"a dependency graph for various operations like updating, cleaning, building, "
"etc. To solve this problem, Cargo supports Package ID Specifications. A "
"specification is a string which is used to uniquely refer to one package "
"within a graph of packages."
msgstr ""

#: src/reference/pkgid-spec.md:11
msgid "Specification grammar"
msgstr ""

#: src/reference/pkgid-spec.md:13
msgid "The formal grammar for a Package Id Specification is:"
msgstr ""

#: src/reference/pkgid-spec.md:15
msgid ""
"```notrust\n"
"pkgid := pkgname\n"
"       | [ proto \"://\" ] hostname-and-path [ \"#\" ( pkgname | semver ) ]\n"
"pkgname := name [ \":\" semver ]\n"
"\n"
"proto := \"http\" | \"git\" | ...\n"
"```"
msgstr ""

#: src/reference/pkgid-spec.md:23
msgid "Here, brackets indicate that the contents are optional."
msgstr ""

#: src/reference/pkgid-spec.md:25
msgid "Example specifications"
msgstr ""

#: src/reference/pkgid-spec.md:27
msgid ""
"These could all be references to a package `foo` version `1.2.3` from the "
"registry at `crates.io`"
msgstr ""

#: src/reference/pkgid-spec.md:30
msgid "pkgid"
msgstr ""

#: src/reference/pkgid-spec.md:30
msgid "name"
msgstr ""

#: src/reference/pkgid-spec.md:30
msgid "version"
msgstr ""

#: src/reference/pkgid-spec.md:30
msgid "url"
msgstr ""

#: src/reference/pkgid-spec.md:32 src/reference/pkgid-spec.md:33
#: src/reference/pkgid-spec.md:34 src/reference/pkgid-spec.md:35
#: src/reference/pkgid-spec.md:36 src/reference/pkgid-spec.md:37
msgid "`foo`"
msgstr ""

#: src/reference/pkgid-spec.md:32 src/reference/pkgid-spec.md:33
#: src/reference/pkgid-spec.md:34
msgid "`*`"
msgstr ""

#: src/reference/pkgid-spec.md:33
msgid "`foo:1.2.3`"
msgstr ""

#: src/reference/pkgid-spec.md:33 src/reference/pkgid-spec.md:35
#: src/reference/pkgid-spec.md:36 src/reference/pkgid-spec.md:37
msgid "`1.2.3`"
msgstr ""

#: src/reference/pkgid-spec.md:34
msgid "`crates.io/foo`"
msgstr ""

#: src/reference/pkgid-spec.md:34 src/reference/pkgid-spec.md:35
msgid "`*://crates.io/foo`"
msgstr ""

#: src/reference/pkgid-spec.md:35
msgid "`crates.io/foo#1.2.3`"
msgstr ""

#: src/reference/pkgid-spec.md:36
msgid "`crates.io/bar#foo:1.2.3`"
msgstr ""

#: src/reference/pkgid-spec.md:36
msgid "`*://crates.io/bar`"
msgstr ""

#: src/reference/pkgid-spec.md:37
msgid "`http://crates.io/foo#1.2.3`"
msgstr ""

#: src/reference/pkgid-spec.md:37
msgid "`http://crates.io/foo`"
msgstr ""

#: src/reference/pkgid-spec.md:39
msgid "Brevity of specifications"
msgstr ""

#: src/reference/pkgid-spec.md:41
msgid ""
"The goal of this is to enable both succinct and exhaustive syntaxes for "
"referring to packages in a dependency graph. Ambiguous references may refer "
"to one or more packages. Most commands generate an error if more than one "
"package could be referred to with the same specification."
msgstr ""

#: src/reference/publishing.md:1
msgid "Publishing on crates.io"
msgstr ""

#: src/reference/publishing.md:3
msgid ""
"Once you've got a library that you'd like to share with the world, it's time "
"to publish it on [crates.io](https://crates.io/)! Publishing a crate is when "
"a specific version is uploaded to be hosted on [crates.io](https://crates."
"io/)."
msgstr ""

#: src/reference/publishing.md:7
msgid ""
"Take care when publishing a crate, because a publish is **permanent**. The "
"version can never be overwritten, and the code cannot be deleted. There is "
"no limit to the number of versions which can be published, however."
msgstr ""

#: src/reference/publishing.md:11
msgid "Before your first publish"
msgstr ""

#: src/reference/publishing.md:13
msgid ""
"First thing’s first, you’ll need an account on [crates.io](https://crates."
"io/) to acquire an API token. To do so, [visit the home page](https://crates."
"io/) and log in via a GitHub account (required for now). After this, visit "
"your [Account Settings](https://crates.io/me) page and run the `cargo login` "
"command specified."
msgstr ""

#: src/reference/publishing.md:23
msgid ""
"This command will inform Cargo of your API token and store it locally in "
"your `~/.cargo/credentials` (previously it was `~/.cargo/config`).  Note "
"that this token is a **secret** and should not be shared with anyone else. "
"If it leaks for any reason, you should regenerate it immediately."
msgstr ""

#: src/reference/publishing.md:28
msgid "Before publishing a new crate"
msgstr ""

#: src/reference/publishing.md:30
msgid ""
"Keep in mind that crate names on [crates.io](https://crates.io/) are "
"allocated on a first-come-first- serve basis. Once a crate name is taken, it "
"cannot be used for another crate."
msgstr ""

#: src/reference/publishing.md:33
msgid "Packaging a crate"
msgstr ""

#: src/reference/publishing.md:35
msgid ""
"The next step is to package up your crate into a format that can be uploaded "
"to [crates.io](https://crates.io/). For this we’ll use the `cargo package` "
"subcommand. This will take our entire crate and package it all up into a `*."
"crate` file in the `target/package` directory."
msgstr ""

#: src/reference/publishing.md:44
msgid ""
"As an added bonus, the `*.crate` will be verified independently of the "
"current source tree. After the `*.crate` is created, it’s unpacked into "
"`target/package` and then built from scratch to ensure that all necessary "
"files are there for the build to succeed. This behavior can be disabled with "
"the `--no-verify` flag."
msgstr ""

#: src/reference/publishing.md:50
msgid ""
"Now’s a good time to take a look at the `*.crate` file to make sure you "
"didn’t accidentally package up that 2GB video asset, or large data files "
"used for code generation, integration tests, or benchmarking.  There is "
"currently a 10MB upload size limit on `*.crate` files. So, if the size of "
"`tests` and `benches` directories and their dependencies are up to a couple "
"of MBs, you can keep them in your package; otherwise, better to exclude them."
msgstr ""

#: src/reference/publishing.md:57
msgid ""
"Cargo will automatically ignore files ignored by your version control system "
"when packaging, but if you want to specify an extra set of files to ignore "
"you can use the `exclude` key in the manifest:"
msgstr ""

#: src/reference/publishing.md:61
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"exclude = [\n"
"    \"public/assets/*\",\n"
"    \"videos/*\",\n"
"]\n"
"```"
msgstr ""

#: src/reference/publishing.md:70
msgid ""
"The syntax of each element in this array is what [rust-lang/glob](https://"
"github.com/rust-lang/glob) accepts. If you’d rather roll with a whitelist "
"instead of a blacklist, Cargo also supports an `include` key, which if set, "
"overrides the `exclude` key:"
msgstr ""

#: src/reference/publishing.md:75
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"include = [\n"
"    \"**/*.rs\",\n"
"    \"Cargo.toml\",\n"
"]\n"
"```"
msgstr ""

#: src/reference/publishing.md:84
msgid "Uploading the crate"
msgstr ""

#: src/reference/publishing.md:86
msgid ""
"Now that we’ve got a `*.crate` file ready to go, it can be uploaded to "
"[crates.io](https://crates.io/) with the `cargo publish` command. And that’s "
"it, you’ve now published your first crate!"
msgstr ""

#: src/reference/publishing.md:94
msgid ""
"If you’d like to skip the `cargo package` step, the `cargo publish` "
"subcommand will automatically package up the local crate if a copy isn’t "
"found already."
msgstr ""

#: src/reference/publishing.md:97
msgid ""
"Be sure to check out the [metadata you can specify](reference/manifest."
"html#package-metadata) to ensure your crate can be discovered more easily!"
msgstr ""

#: src/reference/publishing.md:101
msgid "Publishing a new version of an existing crate"
msgstr ""

#: src/reference/publishing.md:103
msgid ""
"In order to release a new version, change the `version` value specified in "
"your `Cargo.toml` manifest. Keep in mind [the semver rules](reference/"
"manifest.html#the-version-field). Then optionally run `cargo package` if you "
"want to inspect the `*.crate` file for the new version before publishing, "
"and run `cargo publish` to upload the new version."
msgstr ""

#: src/reference/publishing.md:109
msgid "Managing a crates.io-based crate"
msgstr ""

#: src/reference/publishing.md:111
msgid ""
"Management of crates is primarily done through the command line `cargo` tool "
"rather than the [crates.io](https://crates.io/) web interface. For this, "
"there are a few subcommands to manage a crate."
msgstr ""

#: src/reference/publishing.md:115
msgid "`cargo yank`"
msgstr ""

#: src/reference/publishing.md:117
msgid ""
"Occasions may arise where you publish a version of a crate that actually "
"ends up being broken for one reason or another (syntax error, forgot to "
"include a file, etc.). For situations such as this, Cargo supports a “yank” "
"of a version of a crate."
msgstr ""

#: src/reference/publishing.md:127
msgid ""
"A yank **does not** delete any code. This feature is not intended for "
"deleting accidentally uploaded secrets, for example. If that happens, you "
"must reset those secrets immediately."
msgstr ""

#: src/reference/publishing.md:131
msgid ""
"The semantics of a yanked version are that no new dependencies can be "
"created against that version, but all existing dependencies continue to "
"work. One of the major goals of [crates.io](https://crates.io/) is to act as "
"a permanent archive of crates that does not change over time, and allowing "
"deletion of a version would go against this goal. Essentially a yank means "
"that all projects with a `Cargo.lock` will not break, while any future "
"`Cargo.lock` files generated will not list the yanked version."
msgstr ""

#: src/reference/publishing.md:139
msgid "`cargo owner`"
msgstr ""

#: src/reference/publishing.md:141
msgid ""
"A crate is often developed by more than one person, or the primary "
"maintainer may change over time! The owner of a crate is the only person "
"allowed to publish new versions of the crate, but an owner may designate "
"additional owners."
msgstr ""

#: src/reference/publishing.md:152
msgid ""
"The owner IDs given to these commands must be GitHub user names or GitHub "
"teams."
msgstr ""

#: src/reference/publishing.md:154
msgid ""
"If a user name is given to `--add`, that user becomes a “named” owner, with "
"full rights to the crate. In addition to being able to publish or yank "
"versions of the crate, they have the ability to add or remove owners, "
"_including_ the owner that made _them_ an owner. Needless to say, you "
"shouldn’t make people you don’t fully trust into a named owner. In order to "
"become a named owner, a user must have logged into [crates.io](https://"
"crates.io/) previously."
msgstr ""

#: src/reference/publishing.md:161
msgid ""
"If a team name is given to `--add`, that team becomes a “team” owner, with "
"restricted right to the crate. While they have permission to publish or yank "
"versions of the crate, they _do not_ have the ability to add or remove "
"owners. In addition to being more convenient for managing groups of owners, "
"teams are just a bit more secure against owners becoming malicious."
msgstr ""

#: src/reference/publishing.md:167
msgid ""
"The syntax for teams is currently `github:org:team` (see examples above). In "
"order to add a team as an owner one must be a member of that team. No such "
"restriction applies to removing a team as an owner."
msgstr ""

#: src/reference/publishing.md:171
msgid "GitHub permissions"
msgstr ""

#: src/reference/publishing.md:173
msgid ""
"Team membership is not something GitHub provides simple public access to, "
"and it is likely for you to encounter the following message when working "
"with them:"
msgstr ""

#: src/reference/publishing.md:176
msgid ""
"It looks like you don’t have permission to query a necessary property from "
"GitHub to complete this request. You may need to re-authenticate on [crates."
"io](https://crates.io/) to grant permission to read GitHub org memberships. "
"Just go to https://crates.io/login"
msgstr ""

#: src/reference/publishing.md:181
msgid ""
"This is basically a catch-all for “you tried to query a team, and one of the "
"five levels of membership access control denied this”. That is not an "
"exaggeration. GitHub’s support for team access control is Enterprise Grade."
msgstr ""

#: src/reference/publishing.md:185
msgid ""
"The most likely cause of this is simply that you last logged in before this "
"feature was added. We originally requested _no_ permissions from GitHub when "
"authenticating users, because we didn’t actually ever use the user’s token "
"for anything other than logging them in. However to query team membership on "
"your behalf, we now require [the `read:org` scope](https://developer.github."
"com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/)."
msgstr ""

#: src/reference/publishing.md:191
msgid ""
"You are free to deny us this scope, and everything that worked before teams "
"were introduced will keep working. However you will never be able to add a "
"team as an owner, or publish a crate as a team owner. If you ever attempt to "
"do this, you will get the error above. You may also see this error if you "
"ever try to publish a crate that you don’t own at all, but otherwise happens "
"to have a team."
msgstr ""

#: src/reference/publishing.md:197
msgid ""
"If you ever change your mind, or just aren’t sure if [crates.io](https://"
"crates.io/) has sufficient permission, you can always go to https://crates."
"io/login, which will prompt you for permission if [crates.io](https://crates."
"io/) doesn’t have all the scopes it would like to."
msgstr ""

#: src/reference/publishing.md:201
msgid ""
"An additional barrier to querying GitHub is that the organization may be "
"actively denying third party access. To check this, you can go to:"
msgstr ""

#: src/reference/publishing.md:204
msgid ""
"    https://github.com/organizations/:org/settings/oauth_application_policy\n"
"    "
msgstr ""

#: src/reference/publishing.md:206
msgid ""
"where `:org` is the name of the organization (e.g. rust-lang). You may see "
"something like:"
msgstr ""

#: src/reference/publishing.md:209
msgid "![Organization Access Control](images/org-level-acl.png)"
msgstr ""

#: src/reference/publishing.md:211
msgid ""
"Where you may choose to explicitly remove [crates.io](https://crates.io/) "
"from your organization’s blacklist, or simply press the “Remove "
"Restrictions” button to allow all third party applications to access this "
"data."
msgstr ""

#: src/reference/publishing.md:215
msgid ""
"Alternatively, when [crates.io](https://crates.io/) requested the `read:org` "
"scope, you could have explicitly whitelisted [crates.io](https://crates.io/) "
"querying the org in question by pressing the “Grant Access” button next to "
"its name:"
msgstr ""

#: src/reference/publishing.md:219
msgid "![Authentication Access Control](images/auth-level-acl.png)"
msgstr ""

#: src/reference/source-replacement.md:1
msgid "Source Replacement"
msgstr ""

#: src/reference/source-replacement.md:3
msgid ""
"This document is about replacing the crate index. You can read about "
"overriding dependencies in the [overriding dependencies](reference/"
"specifying-dependencies.html#overriding-dependencies) section of this "
"documentation."
msgstr ""

#: src/reference/source-replacement.md:7
msgid ""
"Cargo supports the ability to **replace one source with another** to express "
"strategies along the lines of mirrors or vendoring dependencies. "
"Configuration is currently done through the [`.cargo/config` configuration]"
"(reference/config.html) mechanism, like so:"
msgstr ""

#: src/reference/source-replacement.md:14
msgid ""
"```toml\n"
"# The `source` table is where all keys related to source-replacement\n"
"# are stored.\n"
"[source]\n"
"\n"
"# Under the `source` table are a number of other tables whose keys are a\n"
"# name for the relevant source. For example this section defines a new\n"
"# source, called `my-awesome-source`, which comes from a directory\n"
"# located at `vendor` relative to the directory containing this `.cargo/"
"config`\n"
"# file\n"
"[source.my-awesome-source]\n"
"directory = \"vendor\"\n"
"\n"
"# Git sources can optionally specify a branch/tag/rev as well\n"
"git = \"https://example.com/path/to/repo\"\n"
"# branch = \"master\"\n"
"# tag = \"v1.0.1\"\n"
"# rev = \"313f44e8\"\n"
"\n"
"# The crates.io default source for crates is available under the name\n"
"# \"crates-io\", and here we use the `replace-with` key to indicate that "
"it's\n"
"# replaced with our source above.\n"
"[source.crates-io]\n"
"replace-with = \"my-awesome-source\"\n"
"```"
msgstr ""

#: src/reference/source-replacement.md:40
msgid ""
"With this configuration Cargo attempts to look up all crates in the "
"directory \"vendor\" rather than querying the online registry at crates.io. "
"Using source replacement Cargo can express:"
msgstr ""

#: src/reference/source-replacement.md:44
msgid ""
"Vendoring - custom sources can be defined which represent crates on the "
"local filesystem. These sources are subsets of the source that they're "
"replacing and can be checked into projects if necessary."
msgstr ""

#: src/reference/source-replacement.md:48
msgid ""
"Mirroring - sources can be replaced with an equivalent version which acts as "
"a cache for crates.io itself."
msgstr ""

#: src/reference/source-replacement.md:51
msgid ""
"Cargo has a core assumption about source replacement that the source code is "
"exactly the same from both sources. In our above example Cargo assumes that "
"all of the crates coming from `my-awesome-source` are the exact same as the "
"copies from `crates-io`. Note that this also means that `my-awesome-source` "
"is not allowed to have crates which are not present in the `crates-io` "
"source."
msgstr ""

#: src/reference/source-replacement.md:57
msgid ""
"As a consequence, source replacement is not appropriate for situations such "
"as patching a dependency or a private registry. Cargo supports patching "
"dependencies through the usage of [the `[replace]` key](reference/manifest."
"html#the-replace-section), and private registry support is planned for a "
"future version of Cargo."
msgstr ""

#: src/reference/source-replacement.md:67
msgid ""
"Configuration of replacement sources is done through [`.cargo/config`]"
"(reference/config.html) and the full set of available keys are:"
msgstr ""

#: src/reference/source-replacement.md:70
msgid ""
"```toml\n"
"# Each source has its own table where the key is the name of the source\n"
"[source.the-source-name]\n"
"\n"
"# Indicate that `the-source-name` will be replaced with `another-source`,\n"
"# defined elsewhere\n"
"replace-with = \"another-source\"\n"
"\n"
"# Available kinds of sources that can be specified (described below)\n"
"registry = \"https://example.com/path/to/index\"\n"
"local-registry = \"path/to/registry\"\n"
"directory = \"path/to/vendor\"\n"
"```"
msgstr ""

#: src/reference/source-replacement.md:84
msgid ""
"The `crates-io` represents the crates.io online registry (default source of "
"crates) and can be replaced with:"
msgstr ""

#: src/reference/source-replacement.md:92
msgid "Registry Sources"
msgstr ""

#: src/reference/source-replacement.md:94
msgid ""
"A \"registry source\" is one that is the same as crates.io itself. That is, "
"it has an index served in a git repository which matches the format of the "
"[crates.io index](https://github.com/rust-lang/crates.io-index). That "
"repository then has configuration indicating where to download crates from."
msgstr ""

#: src/reference/source-replacement.md:99
msgid ""
"Currently there is not an already-available project for setting up a mirror "
"of crates.io. Stay tuned though!"
msgstr ""

#: src/reference/source-replacement.md:102
msgid "Local Registry Sources"
msgstr ""

#: src/reference/source-replacement.md:104
msgid ""
"A \"local registry source\" is intended to be a subset of another registry "
"source, but available on the local filesystem (aka vendoring). Local "
"registries are downloaded ahead of time, typically sync'd with a `Cargo."
"lock`, and are made up of a set of `*.crate` files and an index like the "
"normal registry is."
msgstr ""

#: src/reference/source-replacement.md:109
msgid ""
"The primary way to manage and crate local registry sources is through the "
"[`cargo-local-registry`](https://crates.io/crates/cargo-local-registry) "
"subcommand, available on crates.io and can be installed with `cargo install "
"cargo-local-registry`."
msgstr ""

#: src/reference/source-replacement.md:115
msgid ""
"Local registries are contained within one directory and contain a number of "
"`*.crate` files downloaded from crates.io as well as an `index` directory "
"with the same format as the crates.io-index project (populated with just "
"entries for the crates that are present)."
msgstr ""

#: src/reference/source-replacement.md:120
msgid "Directory Sources"
msgstr ""

#: src/reference/source-replacement.md:122
msgid ""
"A \"directory source\" is similar to a local registry source where it "
"contains a number of crates available on the local filesystem, suitable for "
"vendoring dependencies. Also like local registries, directory sources can "
"primarily be managed by an external subcommand, [`cargo-vendor`](https://"
"crates.io/crates/cargo-vendor), which can be installed with `cargo install "
"cargo-vendor`."
msgstr ""

#: src/reference/source-replacement.md:130
msgid ""
"Directory sources are distinct from local registries though in that they "
"contain the unpacked version of `*.crate` files, making it more suitable in "
"some situations to check everything into source control. A directory source "
"is just a directory containing a number of other directories which contain "
"the source code for crates (the unpacked version of `*.crate` files). "
"Currently no restriction is placed on the name of each directory."
msgstr ""

#: src/reference/source-replacement.md:137
msgid ""
"Each crate in a directory source also has an associated metadata file "
"indicating the checksum of each file in the crate to protect against "
"accidental modifications."
msgstr ""

#: src/reference/specifying-dependencies.md:1
msgid "Specifying Dependencies"
msgstr ""

#: src/reference/specifying-dependencies.md:3
msgid ""
"Your crates can depend on other libraries from [crates.io](https://crates."
"io/), `git` repositories, or subdirectories on your local file system. You "
"can also temporarily override the location of a dependency— for example, to "
"be able to test out a bug fix in the dependency that you are working on "
"locally. You can have different dependencies for different platforms, and "
"dependencies that are only used during development. Let's take a look at how "
"to do each of these."
msgstr ""

#: src/reference/specifying-dependencies.md:10
msgid "Specifying dependencies from crates.io"
msgstr ""

#: src/reference/specifying-dependencies.md:12
msgid ""
"Cargo is configured to look for dependencies on [crates.io](https://crates."
"io/) by default. Only the name and a version string are required in this "
"case. In [the cargo guide](guide/index.html), we specified a dependency on "
"the `time` crate:"
msgstr ""

#: src/reference/specifying-dependencies.md:21
msgid ""
"The string `\"0.1.12\"` is a [semver](https://github.com/steveklabnik/"
"semver#requirements) version requirement. Since this string does not have "
"any operators in it, it is interpreted the same way as if we had specified "
"`\"^0.1.12\"`, which is called a caret requirement."
msgstr ""

#: src/reference/specifying-dependencies.md:27
msgid "Caret requirements"
msgstr ""

#: src/reference/specifying-dependencies.md:29
msgid ""
"**Caret requirements** allow SemVer compatible updates to a specified "
"version. An update is allowed if the new version number does not modify the "
"left-most non-zero digit in the major, minor, patch grouping. In this case, "
"if we ran `cargo update -p time`, cargo should update us to version `0.1.13` "
"if it is the latest `0.1.z` release, but would not update us to `0.2.0`. If "
"instead we had specified the version string as `^1.0`, cargo should update "
"to `1.1` if it is the latest `1.y` release, but not `2.0`. The version `0.0."
"x` is not considered compatible with any other version."
msgstr ""

#: src/reference/specifying-dependencies.md:38
msgid ""
"Here are some more examples of caret requirements and the versions that "
"would be allowed with them:"
msgstr ""

#: src/reference/specifying-dependencies.md:52
msgid ""
"This compatibility convention is different from SemVer in the way it treats "
"versions before 1.0.0. While SemVer says there is no compatibility before "
"1.0.0, Cargo considers `0.x.y` to be compatible with `0.x.z`, where `y ≥ z` "
"and `x > 0`."
msgstr ""

#: src/reference/specifying-dependencies.md:57
msgid "Tilde requirements"
msgstr ""

#: src/reference/specifying-dependencies.md:59
msgid ""
"**Tilde requirements** specify a minimal version with some ability to "
"update. If you specify a major, minor, and patch version or only a major and "
"minor version, only patch-level changes are allowed. If you only specify a "
"major version, then minor- and patch-level changes are allowed."
msgstr ""

#: src/reference/specifying-dependencies.md:64
msgid "`~1.2.3` is an example of a tilde requirement."
msgstr ""

#: src/reference/specifying-dependencies.md:72
msgid "Wildcard requirements"
msgstr ""

#: src/reference/specifying-dependencies.md:74
msgid ""
"**Wildcard requirements** allow for any version where the wildcard is "
"positioned."
msgstr ""

#: src/reference/specifying-dependencies.md:77
msgid "`*`, `1.*` and `1.2.*` are examples of wildcard requirements."
msgstr ""

#: src/reference/specifying-dependencies.md:85
msgid "Inequality requirements"
msgstr ""

#: src/reference/specifying-dependencies.md:87
msgid ""
"**Inequality requirements** allow manually specifying a version range or an "
"exact version to depend on."
msgstr ""

#: src/reference/specifying-dependencies.md:90
msgid "Here are some examples of inequality requirements:"
msgstr ""

#: src/reference/specifying-dependencies.md:99
msgid "Multiple requirements"
msgstr ""

#: src/reference/specifying-dependencies.md:101
msgid ""
"Multiple version requirements can also be separated with a comma, e.g. `>= "
"1.2, < 1.5`."
msgstr ""

#: src/reference/specifying-dependencies.md:104
msgid "Specifying dependencies from `git` repositories"
msgstr ""

#: src/reference/specifying-dependencies.md:106
msgid ""
"To depend on a library located in a `git` repository, the minimum "
"information you need to specify is the location of the repository with the "
"`git` key:"
msgstr ""

#: src/reference/specifying-dependencies.md:109
msgid ""
"```toml\n"
"[dependencies]\n"
"rand = { git = \"https://github.com/rust-lang-nursery/rand\" }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:114
msgid ""
"Cargo will fetch the `git` repository at this location then look for a "
"`Cargo.toml` for the requested crate anywhere inside the `git` repository "
"(not necessarily at the root)."
msgstr ""

#: src/reference/specifying-dependencies.md:118
msgid ""
"Since we haven’t specified any other information, Cargo assumes that we "
"intend to use the latest commit on the `master` branch to build our project. "
"You can combine the `git` key with the `rev`, `tag`, or `branch` keys to "
"specify something else. Here's an example of specifying that you want to use "
"the latest commit on a branch named `next`:"
msgstr ""

#: src/reference/specifying-dependencies.md:124
msgid ""
"```toml\n"
"[dependencies]\n"
"rand = { git = \"https://github.com/rust-lang-nursery/rand\", branch = "
"\"next\" }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:129
msgid "Specifying path dependencies"
msgstr ""

#: src/reference/specifying-dependencies.md:131
msgid ""
"Over time, our `hello_world` project from [the guide](guide/index.html) has "
"grown significantly in size! It’s gotten to the point that we probably want "
"to split out a separate crate for others to use. To do this Cargo supports "
"**path dependencies** which are typically sub-crates that live within one "
"repository. Let’s start off by making a new crate inside of our "
"`hello_world` project:"
msgstr ""

#: src/reference/specifying-dependencies.md:142
msgid ""
"This will create a new folder `hello_utils` inside of which a `Cargo.toml` "
"and `src` folder are ready to be configured. In order to tell Cargo about "
"this, open up `hello_world/Cargo.toml` and add `hello_utils` to your "
"dependencies:"
msgstr ""

#: src/reference/specifying-dependencies.md:146
msgid ""
"```toml\n"
"[dependencies]\n"
"hello_utils = { path = \"hello_utils\" }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:151
msgid ""
"This tells Cargo that we depend on a crate called `hello_utils` which is "
"found in the `hello_utils` folder (relative to the `Cargo.toml` it’s written "
"in)."
msgstr ""

#: src/reference/specifying-dependencies.md:154
msgid ""
"And that’s it! The next `cargo build` will automatically build `hello_utils` "
"and all of its own dependencies, and others can also start using the crate "
"as well. However, crates that use dependencies specified with only a path "
"are not permitted on [crates.io](https://crates.io/). If we wanted to "
"publish our `hello_world` crate, we would need to publish a version of "
"`hello_utils` to [crates.io](https://crates.io) and specify its version in "
"the dependencies line as well:"
msgstr ""

#: src/reference/specifying-dependencies.md:161
msgid ""
"```toml\n"
"[dependencies]\n"
"hello_utils = { path = \"hello_utils\", version = \"0.1.0\" }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:166
msgid "Overriding dependencies"
msgstr ""

#: src/reference/specifying-dependencies.md:168
msgid ""
"There are a number of methods in Cargo to support overriding dependencies "
"and otherwise controlling the dependency graph. These options are typically, "
"though, only available at the workspace level and aren't propagated through "
"dependencies. In other words, \"applications\" have the ability to override "
"dependencies but \"libraries\" do not."
msgstr ""

#: src/reference/specifying-dependencies.md:174
msgid ""
"The desire to override a dependency or otherwise alter some dependencies can "
"arise through a number of scenarios. Most of them, however, boil down to the "
"ability to work with a crate before it's been published to crates.io. For "
"example:"
msgstr ""

#: src/reference/specifying-dependencies.md:179
msgid ""
"A crate you're working on is also used in a much larger application you're "
"working on, and you'd like to test a bug fix to the library inside of the "
"larger application."
msgstr ""

#: src/reference/specifying-dependencies.md:182
msgid ""
"An upstream crate you don't work on has a new feature or a bug fix on the "
"master branch of its git repository which you'd like to test out."
msgstr ""

#: src/reference/specifying-dependencies.md:184
msgid ""
"You're about to publish a new major version of your crate, but you'd like to "
"do integration testing across an entire project to ensure the new major "
"version works."
msgstr ""

#: src/reference/specifying-dependencies.md:187
msgid ""
"You've submitted a fix to an upstream crate for a bug you found, but you'd "
"like to immediately have your application start depending on the fixed "
"version of the crate to avoid blocking on the bug fix getting merged."
msgstr ""

#: src/reference/specifying-dependencies.md:191
msgid ""
"These scenarios are currently all solved with the [`[patch]` manifest "
"section](reference/manifest.html#the-patch-section). Historically some of "
"these scenarios have been solved with [the `[replace]` section](reference/"
"manifest.html#the-replace-section), but we'll document the `[patch]` section "
"here."
msgstr ""

#: src/reference/specifying-dependencies.md:199
msgid "Testing a bugfix"
msgstr ""

#: src/reference/specifying-dependencies.md:201
msgid ""
"Let's say you're working with the \\[`uuid`\\] crate but while you're "
"working on it you discover a bug. You are, however, quite enterprising so "
"you decide to also try out to fix the bug! Originally your manifest will "
"look like:"
msgstr ""

#: src/reference/specifying-dependencies.md:205
msgid "[`uuid`](https://crates.io/crates/uuid)"
msgstr ""

#: src/reference/specifying-dependencies.md:207
msgid ""
"```toml\n"
"[package]\n"
"name = \"my-library\"\n"
"version = \"0.1.0\"\n"
"authors = [\"...\"]\n"
"\n"
"[dependencies]\n"
"uuid = \"1.0\"\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:217
msgid ""
"First thing we'll do is to clone the [`uuid` repository](https://github.com/"
"rust-lang-nursery/uuid) locally via:"
msgstr ""

#: src/reference/specifying-dependencies.md:220
msgid ""
"```console\n"
"$ git clone https://github.com/rust-lang-nursery/uuid\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:224
msgid "Next we'll edit the manifest of `my-library` to contain:"
msgstr ""

#: src/reference/specifying-dependencies.md:226
msgid ""
"```toml\n"
"[patch.crates-io]\n"
"uuid = { path = \"../path/to/uuid\" }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:231
msgid ""
"Here we declare that we're _patching_ the source `crates-io` with a new "
"dependency. This will effectively add the local checked out version of "
"`uuid` to the crates.io registry for our local project."
msgstr ""

#: src/reference/specifying-dependencies.md:235
msgid ""
"Next up we need to ensure that our lock file is updated to use this new "
"version of `uuid` so our project uses the locally checked out copy instead "
"of one from crates.io. The way `[patch]` works is that it'll load the "
"dependency at `../path/to/uuid` and then whenever crates.io is queried for "
"versions of `uuid` it'll _also_ return the local version."
msgstr ""

#: src/reference/specifying-dependencies.md:241
msgid ""
"This means that the version number of the local checkout is significant and "
"will affect whether the patch is used. Our manifest declared `uuid = "
"\"1.0\"` which means we'll only resolve to `>= 1.0.0, < 2.0.0`, and Cargo's "
"greedy resolution algorithm also means that we'll resolve to the maximum "
"version within that range. Typically this doesn't matter as the version of "
"the git repository will already be greater or match the maximum version "
"published on crates.io, but it's important to keep this in mind!"
msgstr ""

#: src/reference/specifying-dependencies.md:249
msgid "In any case, typically all you need to do now is:"
msgstr ""

#: src/reference/specifying-dependencies.md:251
msgid ""
"```console\n"
"$ cargo build\n"
"   Compiling uuid v1.0.0 (file://.../uuid)\n"
"   Compiling my-library v0.1.0 (file://.../my-library)\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:258
msgid ""
"And that's it! You're now building with the local version of `uuid` (note "
"the `file://` in the build output). If you don't see the `file://` version "
"getting built then you may need to run `cargo update -p uuid --precise "
"$version` where `$version` is the version of the locally checked out copy of "
"`uuid`."
msgstr ""

#: src/reference/specifying-dependencies.md:263
msgid ""
"Once you've fixed the bug you originally found the next thing you'll want to "
"do is to likely submit that as a pull request to the `uuid` crate itself. "
"Once you've done this then you can also update the `[patch]` section. The "
"listing inside of `[patch]` is just like the `[dependencies]` section, so "
"once your pull request is merged you could change your `path` dependency to:"
msgstr ""

#: src/reference/specifying-dependencies.md:269
msgid ""
"```toml\n"
"[patch.crates-io]\n"
"uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:276
msgid "Working with an unpublished minor version"
msgstr ""

#: src/reference/specifying-dependencies.md:278
msgid ""
"Let's now shift gears a bit from bug fixes to adding features. While working "
"on `my-library` you discover that a whole new feature is needed in the "
"`uuid` crate. You've implemented this feature, tested it locally above with "
"`[patch]`, and submitted a pull request. Let's go over how you continue to "
"use and test it before it's actually published."
msgstr ""

#: src/reference/specifying-dependencies.md:284
msgid ""
"Let's also say that the current version of `uuid` on crates.io is `1.0.0`, "
"but since then the master branch of the git repository has updated to "
"`1.0.1`. This branch includes your new feature you submitted previously. To "
"use this repository we'll edit our `Cargo.toml` to look like"
msgstr ""

#: src/reference/specifying-dependencies.md:289
msgid ""
"```toml\n"
"[package]\n"
"name = \"my-library\"\n"
"version = \"0.1.0\"\n"
"authors = [\"...\"]\n"
"\n"
"[dependencies]\n"
"uuid = \"1.0.1\"\n"
"\n"
"[patch.crates-io]\n"
"uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:302
msgid ""
"Note that our local dependency on `uuid` has been updated to `1.0.1` as it's "
"what we'll actually require once the crate is published. This version "
"doesn't exist on crates.io, though, so we provide it with the `[patch]` "
"section of the manifest."
msgstr ""

#: src/reference/specifying-dependencies.md:307
msgid ""
"Now when our library is built it'll fetch `uuid` from the git repository and "
"resolve to 1.0.1 inside the repository instead of trying to download a "
"version from crates.io. Once 1.0.1 is published on crates.io the `[patch]` "
"section can be deleted."
msgstr ""

#: src/reference/specifying-dependencies.md:312
msgid ""
"It's also worth noting that `[patch]` applies _transitively_. Let's say you "
"use `my-library` in a larger project, such as:"
msgstr ""

#: src/reference/specifying-dependencies.md:315
msgid ""
"```toml\n"
"[package]\n"
"name = \"my-binary\"\n"
"version = \"0.1.0\"\n"
"authors = [\"...\"]\n"
"\n"
"[dependencies]\n"
"my-library = { git = 'https://example.com/git/my-library' }\n"
"uuid = \"1.0\"\n"
"\n"
"[patch.crates-io]\n"
"uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:329
msgid ""
"Remember that `[patch]` is applicable _transitively_ but can only be defined "
"at the _top level_ so we consumers of `my-library` have to repeat the "
"`[patch]` section if necessary. Here, though, the new `uuid` crate applies "
"to _both_ our dependency on `uuid` and the `my-library -> uuid` dependency. "
"The `uuid` crate will be resolved to one version for this entire crate "
"graph, 1.0.1, and it'll be pulled from the git repository."
msgstr ""

#: src/reference/specifying-dependencies.md:336
msgid "Overriding repository URL"
msgstr ""

#: src/reference/specifying-dependencies.md:338
msgid ""
"In case the dependency you want to override isn't loaded from `crates.io`, "
"you'll have to change a bit how you use `[patch]`:"
msgstr ""

#: src/reference/specifying-dependencies.md:340
msgid ""
"```toml\n"
"[patch.\"https://github.com/your/repository\"]\n"
"my-library = { path = \"../my-library/path\" }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:345
msgid "And that's it!"
msgstr ""

#: src/reference/specifying-dependencies.md:347
msgid "Prepublishing a breaking change"
msgstr ""

#: src/reference/specifying-dependencies.md:349
msgid ""
"As a final scenario, let's take a look at working with a new major version "
"of a crate, typically accompanied with breaking changes. Sticking with our "
"previous crates, this means that we're going to be creating version 2.0.0 of "
"the `uuid` crate. After we've submitted all changes upstream we can update "
"our manifest for `my-library` to look like:"
msgstr ""

#: src/reference/specifying-dependencies.md:355
msgid ""
"```toml\n"
"[dependencies]\n"
"uuid = \"2.0\"\n"
"\n"
"[patch.crates-io]\n"
"uuid = { git = \"https://github.com/rust-lang-nursery/uuid\", branch = "
"\"2.0.0\" }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:363
msgid ""
"And that's it! Like with the previous example the 2.0.0 version doesn't "
"actually exist on crates.io but we can still put it in through a git "
"dependency through the usage of the `[patch]` section. As a thought exercise "
"let's take another look at the `my-binary` manifest from above again as well:"
msgstr ""

#: src/reference/specifying-dependencies.md:368
msgid ""
"```toml\n"
"[package]\n"
"name = \"my-binary\"\n"
"version = \"0.1.0\"\n"
"authors = [\"...\"]\n"
"\n"
"[dependencies]\n"
"my-library = { git = 'https://example.com/git/my-library' }\n"
"uuid = \"1.0\"\n"
"\n"
"[patch.crates-io]\n"
"uuid = { git = 'https://github.com/rust-lang-nursery/uuid', version = "
"'2.0.0' }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:382
msgid ""
"Note that this will actually resolve to two versions of the `uuid` crate. "
"The `my-binary` crate will continue to use the 1.x.y series of the `uuid` "
"crate but the `my-library` crate will use the 2.0.0 version of `uuid`. This "
"will allow you to gradually roll out breaking changes to a crate through a "
"dependency graph without being force to update everything all at once."
msgstr ""

#: src/reference/specifying-dependencies.md:388
msgid "Overriding with local dependencies"
msgstr ""

#: src/reference/specifying-dependencies.md:390
msgid ""
"Sometimes you're only temporarily working on a crate and you don't want to "
"have to modify `Cargo.toml` like with the `[patch]` section above. For this "
"use case Cargo offers a much more limited version of overrides called **path "
"overrides**."
msgstr ""

#: src/reference/specifying-dependencies.md:395
msgid ""
"Path overrides are specified through `.cargo/config` instead of `Cargo."
"toml`, and you can find [more documentation about this configuration]"
"(reference/config.html). Inside of `.cargo/config` you'll specify a key "
"called `paths`:"
msgstr ""

#: src/reference/specifying-dependencies.md:401
msgid ""
"```toml\n"
"paths = [\"/path/to/uuid\"]\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:405
msgid ""
"This array should be filled with directories that contain a `Cargo.toml`. In "
"this instance, we’re just adding `uuid`, so it will be the only one that’s "
"overridden. This path can be either absolute or relative to the directory "
"that contains the `.cargo` folder."
msgstr ""

#: src/reference/specifying-dependencies.md:410
msgid ""
"Path overrides are more restricted than the `[patch]` section, however, in "
"that they cannot change the structure of the dependency graph. When a path "
"replacement is used then the previous set of dependencies must all match "
"exactly to the new `Cargo.toml` specification. For example this means that "
"path overrides cannot be used to test out adding a dependency to a crate, "
"instead `[patch]` must be used in that situation. As a result usage of a "
"path override is typically isolated to quick bug fixes rather than larger "
"changes."
msgstr ""

#: src/reference/specifying-dependencies.md:419
msgid ""
"Note: using a local configuration to override paths will only work for "
"crates that have been published to [crates.io](https://crates.io/). You "
"cannot use this feature to tell Cargo how to find local unpublished crates."
msgstr ""

#: src/reference/specifying-dependencies.md:423
msgid "Platform specific dependencies"
msgstr ""

#: src/reference/specifying-dependencies.md:426
msgid ""
"Platform-specific dependencies take the same format, but are listed under a "
"`target` section. Normally Rust-like `#[cfg]` syntax will be used to define "
"these sections:"
msgstr ""

#: src/reference/specifying-dependencies.md:430
msgid ""
"```toml\n"
"[target.'cfg(windows)'.dependencies]\n"
"winhttp = \"0.4.0\"\n"
"\n"
"[target.'cfg(unix)'.dependencies]\n"
"openssl = \"1.0.1\"\n"
"\n"
"[target.'cfg(target_arch = \"x86\")'.dependencies]\n"
"native = { path = \"native/i686\" }\n"
"\n"
"[target.'cfg(target_arch = \"x86_64\")'.dependencies]\n"
"native = { path = \"native/x86_64\" }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:444
msgid ""
"Like with Rust, the syntax here supports the `not`, `any`, and `all` "
"operators to combine various cfg name/value pairs. Note that the `cfg` "
"syntax has only been available since Cargo 0.9.0 (Rust 1.8.0)."
msgstr ""

#: src/reference/specifying-dependencies.md:448
msgid ""
"In addition to `#[cfg]` syntax, Cargo also supports listing out the full "
"target the dependencies would apply to:"
msgstr ""

#: src/reference/specifying-dependencies.md:451
msgid ""
"```toml\n"
"[target.x86_64-pc-windows-gnu.dependencies]\n"
"winhttp = \"0.4.0\"\n"
"\n"
"[target.i686-unknown-linux-gnu.dependencies]\n"
"openssl = \"1.0.1\"\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:459
msgid ""
"If you’re using a custom target specification, quote the full path and file "
"name:"
msgstr ""

#: src/reference/specifying-dependencies.md:462
msgid ""
"```toml\n"
"[target.\"x86_64/windows.json\".dependencies]\n"
"winhttp = \"0.4.0\"\n"
"\n"
"[target.\"i686/linux.json\".dependencies]\n"
"openssl = \"1.0.1\"\n"
"native = { path = \"native/i686\" }\n"
"\n"
"[target.\"x86_64/linux.json\".dependencies]\n"
"openssl = \"1.0.1\"\n"
"native = { path = \"native/x86_64\" }\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:475
msgid "Development dependencies"
msgstr ""

#: src/reference/specifying-dependencies.md:477
msgid ""
"You can add a `[dev-dependencies]` section to your `Cargo.toml` whose format "
"is equivalent to `[dependencies]`:"
msgstr ""

#: src/reference/specifying-dependencies.md:480
msgid ""
"```toml\n"
"[dev-dependencies]\n"
"tempdir = \"0.3\"\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:485
msgid ""
"Dev-dependencies are not used when compiling a package for building, but are "
"used for compiling tests, examples, and benchmarks."
msgstr ""

#: src/reference/specifying-dependencies.md:489
msgid ""
"These dependencies are _not_ propagated to other packages which depend on "
"this package."
msgstr ""

#: src/reference/specifying-dependencies.md:492
msgid ""
"You can also have target-specific development dependencies by using `dev-"
"dependencies` in the target section header instead of `dependencies`. For "
"example:"
msgstr ""

#: src/reference/specifying-dependencies.md:496
msgid ""
"```toml\n"
"[target.'cfg(unix)'.dev-dependencies]\n"
"mio = \"0.0.1\"\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:503
msgid "Build dependencies"
msgstr ""

#: src/reference/specifying-dependencies.md:505
msgid ""
"You can depend on other Cargo-based crates for use in your build scripts. "
"Dependencies are declared through the `build-dependencies` section of the "
"manifest:"
msgstr ""

#: src/reference/specifying-dependencies.md:509
msgid ""
"```toml\n"
"[build-dependencies]\n"
"cc = \"1.0.3\"\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:514
msgid ""
"The build script **does not** have access to the dependencies listed in the "
"`dependencies` or `dev-dependencies` section. Build dependencies will "
"likewise not be available to the package itself unless listed under the "
"`dependencies` section as well. A package itself and its build script are "
"built separately, so their dependencies need not coincide. Cargo is kept "
"simpler and cleaner by using independent dependencies for independent "
"purposes."
msgstr ""

#: src/reference/specifying-dependencies.md:522
msgid "Choosing features"
msgstr ""

#: src/reference/specifying-dependencies.md:524
msgid ""
"If a package you depend on offers conditional features, you can specify "
"which to use:"
msgstr ""

#: src/reference/specifying-dependencies.md:527
msgid ""
"```toml\n"
"[dependencies.awesome]\n"
"version = \"1.3.5\"\n"
"default-features = false # do not include the default features, and "
"optionally\n"
"                         # cherry-pick individual features\n"
"features = [\"secure-password\", \"civet\"]\n"
"```"
msgstr ""

#: src/reference/specifying-dependencies.md:535
msgid ""
"More information about features can be found in the [manifest documentation]"
"(reference/manifest.html#the-features-section)."
msgstr ""

#: src/reference/manifest.md:1
msgid "The Manifest Format"
msgstr ""

#: src/reference/manifest.md:3
msgid ""
"The `Cargo.toml` file for each package is called its _manifest_. Every "
"manifest file consists of one or more sections."
msgstr ""

#: src/reference/manifest.md:6
msgid "The `[package]` section"
msgstr ""

#: src/reference/manifest.md:8
msgid "The first section in a `Cargo.toml` is `[package]`."
msgstr ""

#: src/reference/manifest.md:10
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\" # the name of the package\n"
"version = \"0.1.0\"    # the current version, obeying semver\n"
"authors = [\"Alice <a@example.com>\", \"Bob <b@example.com>\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:17
msgid "All three of these fields are mandatory."
msgstr ""

#: src/reference/manifest.md:19
msgid "The `version` field"
msgstr ""

#: src/reference/manifest.md:21
msgid ""
"Cargo bakes in the concept of [Semantic Versioning](http://semver.org/), so "
"make sure you follow some basic rules:"
msgstr ""

#: src/reference/manifest.md:24
msgid ""
"Before you reach 1.0.0, anything goes, but if you make breaking changes, "
"increment the minor version. In Rust, breaking changes include adding fields "
"to structs or variants to enums."
msgstr ""

#: src/reference/manifest.md:27
msgid ""
"After 1.0.0, only make breaking changes when you increment the major "
"version. Don’t break the build."
msgstr ""

#: src/reference/manifest.md:29
msgid ""
"After 1.0.0, don’t add any new public API (no new `pub` anything) in tiny "
"versions. Always increment the minor version if you add any new `pub` "
"structs, traits, fields, types, functions, methods or anything else."
msgstr ""

#: src/reference/manifest.md:32
msgid ""
"Use version numbers with three numeric parts such as 1.0.0 rather than 1.0."
msgstr ""

#: src/reference/manifest.md:34
msgid "The `build` field (optional)"
msgstr ""

#: src/reference/manifest.md:36
msgid ""
"This field specifies a file in the project root which is a [build script]"
"(reference/build-scripts.html) for building native code. More information "
"can be found in the build script [guide](reference/build-scripts.html)."
msgstr ""

#: src/reference/manifest.md:48
msgid "The `links` field (optional)"
msgstr ""

#: src/reference/manifest.md:50
msgid ""
"This fields specifies the name of a native library that is being linked to. "
"More information can be found in the [`links`](reference/build-scripts."
"html#the-links-manifest-key) section of the build script guide."
msgstr ""

#: src/reference/manifest.md:63
msgid "The `documentation` field (optional)"
msgstr ""

#: src/reference/manifest.md:65
msgid ""
"This field specifies a URL to a website hosting the crate's documentation. "
"If no URL is specified in the manifest file, [crates.io](https://crates.io/) "
"will automatically link your crate to the corresponding [docs.rs](https://"
"docs.rs/) page."
msgstr ""

#: src/reference/manifest.md:69
msgid ""
"Documentation links from specific hosts are blacklisted. Hosts are added to "
"the blacklist if they are known to not be hosting documentation and are "
"possibly of malicious intent e.g. ad tracking networks. URLs from the "
"following hosts are blacklisted:"
msgstr ""

#: src/reference/manifest.md:74
msgid "rust-ci.org"
msgstr ""

#: src/reference/manifest.md:76
msgid ""
"Documentation URLs from blacklisted hosts will not appear on crates.io, and "
"may be replaced by docs.rs links."
msgstr ""

#: src/reference/manifest.md:82
msgid "The `exclude` and `include` fields (optional)"
msgstr ""

#: src/reference/manifest.md:84
msgid ""
"You can explicitly specify to Cargo that a set of [globs](http://doc.rust-"
"lang.org/glob/glob/struct.Pattern.html) should be ignored or included for "
"the purposes of packaging and rebuilding a package. The globs specified in "
"the `exclude` field identify a set of files that are not included when a "
"package is published as well as ignored for the purposes of detecting when "
"to rebuild a package, and the globs in `include` specify files that are "
"explicitly included."
msgstr ""

#: src/reference/manifest.md:91
msgid ""
"If a VCS is being used for a package, the `exclude` field will be seeded "
"with the VCS’ ignore settings (`.gitignore` for git for example)."
msgstr ""

#: src/reference/manifest.md:94
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"exclude = [\"build/**/*.o\", \"doc/**/*.html\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:100
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"include = [\"src/**/*\", \"Cargo.toml\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:106
msgid ""
"The options are mutually exclusive: setting `include` will override an "
"`exclude`. Note that `include` must be an exhaustive list of files as "
"otherwise necessary source files may not be included."
msgstr ""

#: src/reference/manifest.md:112
msgid "Migrating to `gitignore`\\-like pattern matching"
msgstr ""

#: src/reference/manifest.md:114
msgid ""
"The current interpretation of these configs is based on UNIX Globs, as "
"implemented in the [`glob` crate](https://crates.io/crates/glob). We want "
"Cargo's `include` and `exclude` configs to work as similar to `gitignore` as "
"possible. [The `gitignore` specification](https://git-scm.com/docs/"
"gitignore) is also based on Globs, but has a bunch of additional features "
"that enable easier pattern writing and more control. Therefore, we are "
"migrating the interpretation for the rules of these configs to use the "
"[`ignore` crate](https://crates.io/crates/ignore), and treat them each rule "
"as a single line in a `gitignore` file. See [the tracking issue](https://"
"github.com/rust-lang/cargo/issues/4268) for more details on the migration."
msgstr ""

#: src/reference/manifest.md:126
msgid "The `publish`  field (optional)"
msgstr ""

#: src/reference/manifest.md:128
msgid ""
"The `publish` field can be used to prevent a package from being published to "
"a package registry (like _crates.io_) by mistake."
msgstr ""

#: src/reference/manifest.md:137
msgid "The `workspace`  field (optional)"
msgstr ""

#: src/reference/manifest.md:139
msgid ""
"The `workspace` field can be used to configure the workspace that this "
"package will be a member of. If not specified this will be inferred as the "
"first Cargo.toml with `[workspace]` upwards in the filesystem."
msgstr ""

#: src/reference/manifest.md:143
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"workspace = \"path/to/workspace/root\"\n"
"```"
msgstr ""

#: src/reference/manifest.md:149
msgid ""
"For more information, see the documentation for the workspace table below."
msgstr ""

#: src/reference/manifest.md:151
msgid "Package metadata"
msgstr ""

#: src/reference/manifest.md:153
msgid ""
"There are a number of optional metadata fields also accepted under the "
"`[package]` section:"
msgstr ""

#: src/reference/manifest.md:156
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"\n"
"# A short blurb about the package. This is not rendered in any format when\n"
"# uploaded to crates.io (aka this is not markdown).\n"
"description = \"...\"\n"
"\n"
"# These URLs point to more information about the package. These are\n"
"# intended to be webviews of the relevant data, not necessarily compatible\n"
"# with VCS tools and the like.\n"
"documentation = \"...\"\n"
"homepage = \"...\"\n"
"repository = \"...\"\n"
"\n"
"# This points to a file under the package root (relative to this `Cargo."
"toml`).\n"
"# The contents of this file are stored and indexed in the registry.\n"
"# crates.io will render this file and place the result on the crate's page.\n"
"readme = \"...\"\n"
"\n"
"# This is a list of up to five keywords that describe this crate. Keywords\n"
"# are searchable on crates.io, and you may choose any words that would\n"
"# help someone find this crate.\n"
"keywords = [\"...\", \"...\"]\n"
"\n"
"# This is a list of up to five categories where this crate would fit.\n"
"# Categories are a fixed list available at crates.io/category_slugs, and\n"
"# they must match exactly.\n"
"categories = [\"...\", \"...\"]\n"
"\n"
"# This is an SPDX 2.1 license expression for this package.  Currently\n"
"# crates.io will validate the license provided against a whitelist of\n"
"# known license and exception identifiers from the SPDX license list\n"
"# 2.4.  Parentheses are not currently supported.\n"
"#\n"
"# Multiple licenses can be separated with a `/`, although that usage\n"
"# is deprecated.  Instead, use a license expression with AND and OR\n"
"# operators to get more explicit semantics.\n"
"license = \"...\"\n"
"\n"
"# If a project is using a nonstandard license, then this key may be "
"specified in\n"
"# lieu of the above key and must point to a file relative to this manifest\n"
"# (similar to the readme key).\n"
"license-file = \"...\"\n"
"\n"
"# Optional specification of badges to be displayed on crates.io.\n"
"#\n"
"# - The badges pertaining to build status that are currently available are\n"
"#   Appveyor, CircleCI, GitLab, and TravisCI.\n"
"# - Available badges pertaining to code test coverage are Codecov and\n"
"#   Coveralls.\n"
"# - There are also maintenance-related badges based on isitmaintained.com\n"
"#   which state the issue resolution time, percent of open issues, and "
"future\n"
"#   maintenance intentions.\n"
"#\n"
"# If a `repository` key is required, this refers to a repository in\n"
"# `user/repo` format.\n"
"[badges]\n"
"\n"
"# Appveyor: `repository` is required. `branch` is optional; default is "
"`master`\n"
"# `service` is optional; valid values are `github` (default), `bitbucket`, "
"and\n"
"# `gitlab`; `id` is optional; you can specify the appveyor project id if "
"you\n"
"# want to use that instead. `project_name` is optional; use when the "
"repository\n"
"# name differs from the appveyor project name.\n"
"appveyor = { repository = \"...\", branch = \"master\", service = "
"\"github\" }\n"
"\n"
"# Circle CI: `repository` is required. `branch` is optional; default is "
"`master`\n"
"circle-ci = { repository = \"...\", branch = \"master\" }\n"
"\n"
"# GitLab: `repository` is required. `branch` is optional; default is "
"`master`\n"
"gitlab = { repository = \"...\", branch = \"master\" }\n"
"\n"
"# Travis CI: `repository` in format \"<user>/<project>\" is required.\n"
"# `branch` is optional; default is `master`\n"
"travis-ci = { repository = \"...\", branch = \"master\" }\n"
"\n"
"# Codecov: `repository` is required. `branch` is optional; default is "
"`master`\n"
"# `service` is optional; valid values are `github` (default), `bitbucket`, "
"and\n"
"# `gitlab`.\n"
"codecov = { repository = \"...\", branch = \"master\", service = "
"\"github\" }\n"
"\n"
"# Coveralls: `repository` is required. `branch` is optional; default is "
"`master`\n"
"# `service` is optional; valid values are `github` (default) and "
"`bitbucket`.\n"
"coveralls = { repository = \"...\", branch = \"master\", service = "
"\"github\" }\n"
"\n"
"# Is it maintained resolution time: `repository` is required.\n"
"is-it-maintained-issue-resolution = { repository = \"...\" }\n"
"\n"
"# Is it maintained percentage of open issues: `repository` is required.\n"
"is-it-maintained-open-issues = { repository = \"...\" }\n"
"\n"
"# Maintenance: `status` is required. Available options are `actively-"
"developed`,\n"
"# `passively-maintained`, `as-is`, `experimental`, `looking-for-"
"maintainer`,\n"
"# `deprecated`, and the default `none`, which displays no badge on crates."
"io.\n"
"maintenance = { status = \"...\" }\n"
"```"
msgstr ""

#: src/reference/manifest.md:253
msgid ""
"The [crates.io](https://crates.io) registry will render the description, "
"display the license, link to the three URLs and categorize by the keywords. "
"These keys provide useful information to users of the registry and also "
"influence the search ranking of a crate. It is highly discouraged to omit "
"everything in a published crate."
msgstr ""

#: src/reference/manifest.md:259
msgid ""
"SPDX 2.1 license expressions are documented [here](https://spdx.org/spdx-"
"specification-21-web-version#h.jxpfx0ykyb60).  The current version of the "
"license list is available [here](https://spdx.org/licenses/), and version "
"2.4 is available [here](https://github.com/spdx/license-list-data/tree/v2.4)."
msgstr ""

#: src/reference/manifest.md:264
msgid "The `metadata` table (optional)"
msgstr ""

#: src/reference/manifest.md:266
msgid ""
"Cargo by default will warn about unused keys in `Cargo.toml` to assist in "
"detecting typos and such. The `package.metadata` table, however, is "
"completely ignored by Cargo and will not be warned about. This section can "
"be used for tools which would like to store project configuration in `Cargo."
"toml`. For example:"
msgstr ""

#: src/reference/manifest.md:272
msgid ""
"```toml\n"
"[package]\n"
"name = \"...\"\n"
"# ...\n"
"\n"
"# Metadata used when generating an Android APK, for example.\n"
"[package.metadata.android]\n"
"package-name = \"my-awesome-android-app\"\n"
"assets = \"path/to/static\"\n"
"```"
msgstr ""

#: src/reference/manifest.md:283
msgid "Dependency sections"
msgstr ""

#: src/reference/manifest.md:285
msgid ""
"See the [specifying dependencies page](reference/specifying-dependencies."
"html) for information on the `[dependencies]`, `[dev-dependencies]`, `[build-"
"dependencies]`, and target-specific `[target.*.dependencies]` sections."
msgstr ""

#: src/reference/manifest.md:289
msgid "The `[profile.*]` sections"
msgstr ""

#: src/reference/manifest.md:291
msgid ""
"Cargo supports custom configuration of how rustc is invoked through profiles "
"at the top level. Any manifest may declare a profile, but only the top level "
"project’s profiles are actually read. All dependencies’ profiles will be "
"overridden. This is done so the top-level project has control over how its "
"dependencies are compiled."
msgstr ""

#: src/reference/manifest.md:297
msgid ""
"There are four currently supported profile names, all of which have the same "
"configuration available to them. Listed below is the configuration "
"available, along with the defaults for each profile."
msgstr ""

#: src/reference/manifest.md:363
msgid "The `[features]` section"
msgstr ""

#: src/reference/manifest.md:365
msgid "Cargo supports features to allow expression of:"
msgstr ""

#: src/reference/manifest.md:367
msgid "conditional compilation options (usable through `cfg` attributes);"
msgstr ""

#: src/reference/manifest.md:368
msgid ""
"optional dependencies, which enhance a package, but are not required; and"
msgstr ""

#: src/reference/manifest.md:369
msgid ""
"clusters of optional dependencies, such as `postgres`, that would include "
"the `postgres` package, the `postgres-macros` package, and possibly other "
"packages (such as development-time mocking libraries, debugging tools, etc.)."
msgstr ""

#: src/reference/manifest.md:373
msgid ""
"A feature of a package is either an optional dependency, or a set of other "
"features. The format for specifying features is:"
msgstr ""

#: src/reference/manifest.md:376
msgid ""
"```toml\n"
"[package]\n"
"name = \"awesome\"\n"
"\n"
"[features]\n"
"# The default set of optional packages. Most people will want to use these\n"
"# packages, but they are strictly optional. Note that `session` is not a "
"package\n"
"# but rather another feature listed in this manifest.\n"
"default = [\"jquery\", \"uglifier\", \"session\"]\n"
"\n"
"# A feature with no dependencies is used mainly for conditional "
"compilation,\n"
"# like `#[cfg(feature = \"go-faster\")]`.\n"
"go-faster = []\n"
"\n"
"# The `secure-password` feature depends on the bcrypt package. This "
"aliasing\n"
"# will allow people to talk about the feature in a higher-level way and "
"allow\n"
"# this package to add more requirements to the feature in the future.\n"
"secure-password = [\"bcrypt\"]\n"
"\n"
"# Features can be used to reexport features of other packages. The "
"`session`\n"
"# feature of package `awesome` will ensure that the `session` feature of "
"the\n"
"# package `cookie` is also enabled.\n"
"session = [\"cookie/session\"]\n"
"\n"
"[dependencies]\n"
"# These packages are mandatory and form the core of this package’s "
"distribution.\n"
"cookie = \"1.2.0\"\n"
"oauth = \"1.1.0\"\n"
"route-recognizer = \"=2.1.0\"\n"
"\n"
"# A list of all of the optional dependencies, some of which are included in "
"the\n"
"# above `features`. They can be opted into by apps.\n"
"jquery = { version = \"1.0.2\", optional = true }\n"
"uglifier = { version = \"1.5.3\", optional = true }\n"
"bcrypt = { version = \"*\", optional = true }\n"
"civet = { version = \"*\", optional = true }\n"
"```"
msgstr ""

#: src/reference/manifest.md:414
msgid "To use the package `awesome`:"
msgstr ""

#: src/reference/manifest.md:424
msgid "Rules"
msgstr ""

#: src/reference/manifest.md:426
msgid "The usage of features is subject to a few rules:"
msgstr ""

#: src/reference/manifest.md:428
msgid ""
"Feature names must not conflict with other package names in the manifest. "
"This is because they are opted into via `features = [...]`, which only has a "
"single namespace."
msgstr ""

#: src/reference/manifest.md:431
msgid ""
"With the exception of the `default` feature, all features are opt-in. To opt "
"out of the default feature, use `default-features = false` and cherry-pick "
"individual features."
msgstr ""

#: src/reference/manifest.md:434
msgid "Feature groups are not allowed to cyclically depend on one another."
msgstr ""

#: src/reference/manifest.md:435
msgid "Dev-dependencies cannot be optional."
msgstr ""

#: src/reference/manifest.md:436
msgid "Features groups can only reference optional dependencies."
msgstr ""

#: src/reference/manifest.md:437
msgid ""
"When a feature is selected, Cargo will call `rustc` with `--cfg "
"feature=\"${feature_name}\"`. If a feature group is included, it and all of "
"its individual features will be included. This can be tested in code via "
"`#[cfg(feature = \"foo\")]`."
msgstr ""

#: src/reference/manifest.md:442
msgid ""
"Note that it is explicitly allowed for features to not actually activate any "
"optional dependencies. This allows packages to internally enable/disable "
"features without requiring a new dependency."
msgstr ""

#: src/reference/manifest.md:446
msgid "Usage in end products"
msgstr ""

#: src/reference/manifest.md:448
msgid ""
"One major use-case for this feature is specifying optional features in end-"
"products. For example, the Servo project may want to include optional "
"features that people can enable or disable when they build it."
msgstr ""

#: src/reference/manifest.md:452
msgid ""
"In that case, Servo will describe features in its `Cargo.toml` and they can "
"be enabled using command-line flags:"
msgstr ""

#: src/reference/manifest.md:455
msgid ""
"```console\n"
"$ cargo build --release --features \"shumway pdf\"\n"
"```"
msgstr ""

#: src/reference/manifest.md:459
msgid "Default features could be excluded using `--no-default-features`."
msgstr ""

#: src/reference/manifest.md:461
msgid "Usage in packages"
msgstr ""

#: src/reference/manifest.md:463
msgid ""
"In most cases, the concept of _optional dependency_ in a library is best "
"expressed as a separate package that the top-level application depends on."
msgstr ""

#: src/reference/manifest.md:466
msgid ""
"However, high-level packages, like Iron or Piston, may want the ability to "
"curate a number of packages for easy installation. The current Cargo system "
"allows them to curate a number of mandatory dependencies into a single "
"package for easy installation."
msgstr ""

#: src/reference/manifest.md:471
msgid ""
"In some cases, packages may want to provide additional curation for optional "
"dependencies:"
msgstr ""

#: src/reference/manifest.md:474
msgid ""
"grouping a number of low-level optional dependencies together into a single "
"high-level feature;"
msgstr ""

#: src/reference/manifest.md:476
msgid ""
"specifying packages that are recommended (or suggested) to be included by "
"users of the package; and"
msgstr ""

#: src/reference/manifest.md:478
msgid ""
"including a feature (like `secure-password` in the motivating example) that "
"will only work if an optional dependency is available, and would be "
"difficult to implement as a separate package (for example, it may be overly "
"difficult to design an IO package to be completely decoupled from OpenSSL, "
"with opt-in via the inclusion of a separate package)."
msgstr ""

#: src/reference/manifest.md:484
msgid ""
"In almost all cases, it is an antipattern to use these features outside of "
"high-level packages that are designed for curation. If a feature is "
"optional, it can almost certainly be expressed as a separate package."
msgstr ""

#: src/reference/manifest.md:488
msgid "The `[workspace]` section"
msgstr ""

#: src/reference/manifest.md:490
msgid ""
"Projects can define a workspace which is a set of crates that will all share "
"the same `Cargo.lock` and output directory. The `[workspace]` table can be "
"defined as:"
msgstr ""

#: src/reference/manifest.md:494
msgid ""
"```toml\n"
"[workspace]\n"
"\n"
"# Optional key, inferred from path dependencies if not present.\n"
"# Additional non-path dependencies that should be included must be given "
"here.\n"
"# In particular, for a virtual manifest, all members have to be listed.\n"
"members = [\"path/to/member1\", \"path/to/member2\", \"path/to/member3/*\"]\n"
"\n"
"# Optional key, empty if not present.\n"
"exclude = [\"path1\", \"path/to/dir2\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:506
msgid ""
"Workspaces were added to Cargo as part of [RFC 1525](https://github.com/rust-"
"lang/rfcs/blob/master/text/1525-cargo-workspace.md) and have a number of "
"properties:"
msgstr ""

#: src/reference/manifest.md:509
msgid ""
"A workspace can contain multiple crates where one of them is the _root "
"crate_."
msgstr ""

#: src/reference/manifest.md:510
msgid ""
"The _root crate_'s `Cargo.toml` contains the `[workspace]` table, but is not "
"required to have other configuration."
msgstr ""

#: src/reference/manifest.md:512
msgid ""
"Whenever any crate in the workspace is compiled, output is placed in the "
"_workspace root_. i.e. next to the _root crate_'s `Cargo.toml`."
msgstr ""

#: src/reference/manifest.md:514
msgid ""
"The lock file for all crates in the workspace resides in the _workspace "
"root_."
msgstr ""

#: src/reference/manifest.md:515
msgid ""
"The `[patch]`, `[replace]` and `[profile.*]` sections in `Cargo.toml` are "
"only recognized in the _root crate_'s manifest, and ignored in member "
"crates' manifests."
msgstr ""

#: src/reference/manifest.md:521
msgid ""
"The _root crate_ of a workspace, indicated by the presence of `[workspace]` "
"in its manifest, is responsible for defining the entire workspace. All "
"`path` dependencies residing in the workspace directory become members. You "
"can add additional packages to the workspace by listing them in the "
"`members` key. Note that members of the workspaces listed explicitly will "
"also have their path dependencies included in the workspace. Sometimes a "
"project may have a lot of workspace members and it can be onerous to keep up "
"to date. The path dependency can also use [globs](http://doc.rust-lang.org/"
"glob/glob/struct.Pattern.html) to match multiple paths. Finally, the "
"`exclude` key can be used to blacklist paths from being included in a "
"workspace. This can be useful if some path dependencies aren't desired to be "
"in the workspace at all."
msgstr ""

#: src/reference/manifest.md:533
msgid ""
"The `package.workspace` manifest key (described above) is used in member "
"crates to point at a workspace's root crate. If this key is omitted then it "
"is inferred to be the first crate whose manifest contains `[workspace]` "
"upwards in the filesystem."
msgstr ""

#: src/reference/manifest.md:538
msgid ""
"A crate may either specify `package.workspace` or specify `[workspace]`. "
"That is, a crate cannot both be a root crate in a workspace (contain "
"`[workspace]`) and also be a member crate of another workspace (contain "
"`package.workspace`)."
msgstr ""

#: src/reference/manifest.md:542
msgid ""
"Most of the time workspaces will not need to be dealt with as `cargo new` "
"and `cargo init` will handle workspace configuration automatically."
msgstr ""

#: src/reference/manifest.md:545
msgid "Virtual Manifest"
msgstr ""

#: src/reference/manifest.md:547
msgid ""
"In workspace manifests, if the `package` table is present, the workspace "
"root crate will be treated as a normal package, as well as a workspace. If "
"the `package` table is not present in a workspace manifest, it is called a "
"_virtual manifest_."
msgstr ""

#: src/reference/manifest.md:552
msgid "Package selection"
msgstr ""

#: src/reference/manifest.md:554
msgid ""
"In a workspace, package-related cargo commands like `cargo build` apply to "
"packages selected by `-p` / `--package` or `--all` command-line parameters. "
"When neither is specified, the optional `default-members` configuration is "
"used:"
msgstr ""

#: src/reference/manifest.md:558
msgid ""
"```toml\n"
"[workspace]\n"
"members = [\"path/to/member1\", \"path/to/member2\", \"path/to/member3/*\"]\n"
"default-members = [\"path/to/member2\", \"path/to/member3/foo\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:564
msgid "When specified, `default-members` must expand to a subset of `members`."
msgstr ""

#: src/reference/manifest.md:566
msgid ""
"When `default-members` is not specified, the default is the root manifest if "
"it is a package, or every member manifest (as if `--all` were specified on "
"the command-line) for virtual workspaces."
msgstr ""

#: src/reference/manifest.md:570
msgid "The project layout"
msgstr ""

#: src/reference/manifest.md:572
msgid ""
"If your project is an executable, name the main source file `src/main.rs`. "
"If it is a library, name the main source file `src/lib.rs`."
msgstr ""

#: src/reference/manifest.md:575
msgid ""
"Cargo will also treat any files located in `src/bin/*.rs` as executables. If "
"your executable consists of more than just one source file, you might also "
"use a directory inside `src/bin` containing a `main.rs` file which will be "
"treated as an executable with a name of the parent directory. Do note, "
"however, once you add a `[[bin]]` section ([see below](#configuring-a-"
"target)), Cargo will no longer automatically build files located in `src/bin/"
"*.rs`.  Instead you must create a `[[bin]]` section for each file you want "
"to build."
msgstr ""

#: src/reference/manifest.md:584
msgid ""
"Your project can optionally contain folders named `examples`, `tests`, and "
"`benches`, which Cargo will treat as containing examples, integration tests, "
"and benchmarks respectively. Analogous to `bin` targets, they may be "
"composed of single files or directories with a `main.rs` file."
msgstr ""

#: src/reference/manifest.md:611
msgid ""
"To structure your code after you've created the files and folders for your "
"project, you should remember to use Rust's module system, which you can read "
"about in [the book](https://doc.rust-lang.org/book/crates-and-modules.html)."
msgstr ""

#: src/reference/manifest.md:615
msgid "Examples"
msgstr ""

#: src/reference/manifest.md:617
msgid ""
"Files located under `examples` are example uses of the functionality "
"provided by the library. When compiled, they are placed in the `target/"
"examples` directory."
msgstr ""

#: src/reference/manifest.md:620
msgid ""
"They can compile either as executables (with a `main()` function) or "
"libraries and pull in the library by using `extern crate <library-name>`. "
"They are compiled when you run your tests to protect them from bitrotting."
msgstr ""

#: src/reference/manifest.md:624
msgid ""
"You can run individual executable examples with the command `cargo run --"
"example <example-name>`."
msgstr ""

#: src/reference/manifest.md:627
msgid ""
"Specify `crate-type` to make an example be compiled as a library (additional "
"information about crate types is available in [The Rust Reference](https://"
"doc.rust-lang.org/reference/linkage.html)):"
msgstr ""

#: src/reference/manifest.md:631
msgid ""
"```toml\n"
"[[example]]\n"
"name = \"foo\"\n"
"crate-type = [\"staticlib\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:637
msgid ""
"You can build individual library examples with the command `cargo build --"
"example <example-name>`."
msgstr ""

#: src/reference/manifest.md:642
msgid "When you run `cargo test`, Cargo will:"
msgstr ""

#: src/reference/manifest.md:644
msgid ""
"compile and run your library’s unit tests, which are in the files reachable "
"from `lib.rs` (naturally, any sections marked with `#[cfg(test)]` will be "
"considered at this stage);"
msgstr ""

#: src/reference/manifest.md:647
msgid ""
"compile and run your library’s documentation tests, which are embedded "
"inside of documentation blocks;"
msgstr ""

#: src/reference/manifest.md:649
msgid ""
"compile and run your library’s [integration tests](#integration-tests); and"
msgstr ""

#: src/reference/manifest.md:650
msgid "compile your library’s examples."
msgstr ""

#: src/reference/manifest.md:652
msgid "Integration tests"
msgstr ""

#: src/reference/manifest.md:654
msgid ""
"Each file in `tests/*.rs` is an integration test. When you run `cargo test`, "
"Cargo will compile each of these files as a separate crate. The crate can "
"link to your library by using `extern crate <library-name>`, like any other "
"code that depends on it."
msgstr ""

#: src/reference/manifest.md:659
msgid ""
"Cargo will not automatically compile files inside subdirectories of `tests`, "
"but an integration test can import modules from these directories as usual. "
"For example, if you want several integration tests to share some code, you "
"can put the shared code in `tests/common/mod.rs` and then put `mod common;` "
"in each of the test files."
msgstr ""

#: src/reference/manifest.md:665
msgid "Configuring a target"
msgstr ""

#: src/reference/manifest.md:667
msgid ""
"All of the  `[[bin]]`, `[lib]`, `[[bench]]`, `[[test]]`, and `[[example]]` "
"sections support similar configuration for specifying how a target should be "
"built. The double-bracket sections like `[[bin]]` are array-of-table of "
"[TOML](https://github.com/toml-lang/toml#array-of-tables), which means you "
"can write more than one `[[bin]]` section to make several executables in "
"your crate."
msgstr ""

#: src/reference/manifest.md:673
msgid ""
"The example below uses `[lib]`, but it also applies to all other sections as "
"well. All values listed are the defaults for that option unless otherwise "
"specified."
msgstr ""

#: src/reference/manifest.md:677
msgid ""
"```toml\n"
"[package]\n"
"# ...\n"
"\n"
"[lib]\n"
"# The name of a target is the name of the library that will be generated. "
"This\n"
"# is defaulted to the name of the package or project, with any dashes "
"replaced\n"
"# with underscores. (Rust `extern crate` declarations reference this name;\n"
"# therefore the value must be a valid Rust identifier to be usable.)\n"
"name = \"foo\"\n"
"\n"
"# This field points at where the crate is located, relative to the `Cargo."
"toml`.\n"
"path = \"src/lib.rs\"\n"
"\n"
"# A flag for enabling unit tests for this target. This is used by `cargo "
"test`.\n"
"test = true\n"
"\n"
"# A flag for enabling documentation tests for this target. This is only "
"relevant\n"
"# for libraries, it has no effect on other sections. This is used by\n"
"# `cargo test`.\n"
"doctest = true\n"
"\n"
"# A flag for enabling benchmarks for this target. This is used by `cargo "
"bench`.\n"
"bench = true\n"
"\n"
"# A flag for enabling documentation of this target. This is used by `cargo "
"doc`.\n"
"doc = true\n"
"\n"
"# If the target is meant to be a compiler plugin, this field must be set to "
"true\n"
"# for Cargo to correctly compile it and make it available for all "
"dependencies.\n"
"plugin = false\n"
"\n"
"# If the target is meant to be a \"macros 1.1\" procedural macro, this field "
"must\n"
"# be set to true.\n"
"proc-macro = false\n"
"\n"
"# If set to false, `cargo test` will omit the `--test` flag to rustc, which\n"
"# stops it from generating a test harness. This is useful when the binary "
"being\n"
"# built manages the test runner itself.\n"
"harness = true\n"
"```"
msgstr ""

#: src/reference/manifest.md:719
msgid ""
"The `[package]` also includes the optional `autobins`, `autoexamples`, "
"`autotests`, and `autobenches` keys to explicitly opt-in or opt-out of auto-"
"discovering specific target kinds."
msgstr ""

#: src/reference/manifest.md:723
msgid "The `required-features` field (optional)"
msgstr ""

#: src/reference/manifest.md:725
msgid ""
"The `required-features` field specifies which features the target needs in "
"order to be built. If any of the required features are not selected, the "
"target will be skipped. This is only relevant for the `[[bin]]`, "
"`[[bench]]`, `[[test]]`, and `[[example]]` sections, it has no effect on "
"`[lib]`."
msgstr ""

#: src/reference/manifest.md:730
msgid ""
"```toml\n"
"[features]\n"
"# ...\n"
"postgres = []\n"
"sqlite = []\n"
"tools = []\n"
"\n"
"[[bin]]\n"
"# ...\n"
"required-features = [\"postgres\", \"tools\"]\n"
"```"
msgstr ""

#: src/reference/manifest.md:742
msgid "Building dynamic or static libraries"
msgstr ""

#: src/reference/manifest.md:744
msgid ""
"If your project produces a library, you can specify which kind of library to "
"build by explicitly listing the library in your `Cargo.toml`:"
msgstr ""

#: src/reference/manifest.md:747
msgid ""
"```toml\n"
"# ...\n"
"\n"
"[lib]\n"
"name = \"...\"\n"
"crate-type = [\"dylib\"] # could be `staticlib` as well\n"
"```"
msgstr ""

#: src/reference/manifest.md:755
msgid ""
"The available options are `dylib`, `rlib`, `staticlib`, `cdylib`, and `proc-"
"macro`. You should only use this option in a project. Cargo will always "
"compile packages (dependencies) based on the requirements of the project "
"that includes them."
msgstr ""

#: src/reference/manifest.md:760
msgid ""
"You can read more about the different crate types in the [Rust Reference "
"Manual](https://doc.rust-lang.org/reference/linkage.html)"
msgstr ""

#: src/reference/manifest.md:763
msgid "The `[patch]` Section"
msgstr ""

#: src/reference/manifest.md:765 src/reference/manifest.md:809
msgid ""
"This section of Cargo.toml can be used to [override dependencies](reference/"
"specifying-dependencies.html#overriding-dependencies) with other copies. The "
"syntax is similar to the `[dependencies]` section:"
msgstr ""

#: src/reference/manifest.md:768
msgid ""
"```toml\n"
"[patch.crates-io]\n"
"foo = { git = 'https://github.com/example/foo' }\n"
"bar = { path = 'my/local/bar' }\n"
"\n"
"[dependencies.baz]\n"
"git = 'https://github.com/example/baz'\n"
"\n"
"[patch.'https://github.com/example/baz']\n"
"baz = { git = 'https://github.com/example/patched-baz', branch = 'my-"
"branch' }\n"
"```"
msgstr ""

#: src/reference/manifest.md:780
msgid ""
"The `[patch]` table is made of dependency-like sub-tables. Each key after "
"`[patch]` is a URL of the source that's being patched, or `crates-io` if "
"you're modifying the https://crates.io registry. In the example above "
"`crates-io` could be replaced with a git URL such as `https://github.com/"
"rust-lang-nursery/log`; the second `[patch]` section in the example uses "
"this to specify a source called `baz`."
msgstr ""

#: src/reference/manifest.md:787
msgid ""
"Each entry in these tables is a normal dependency specification, the same as "
"found in the `[dependencies]` section of the manifest. The dependencies "
"listed in the `[patch]` section are resolved and used to patch the source at "
"the URL specified. The above manifest snippet patches the `crates-io` source "
"(e.g. crates.io itself) with the `foo` crate and `bar` crate. It also "
"patches the `https://github.com/example/baz` source with a `my-branch` that "
"comes from elsewhere."
msgstr ""

#: src/reference/manifest.md:795
msgid ""
"Sources can be patched with versions of crates that do not exist, and they "
"can also be patched with versions of crates that already exist. If a source "
"is patched with a crate version that already exists in the source, then the "
"source's original crate is replaced."
msgstr ""

#: src/reference/manifest.md:800
msgid ""
"More information about overriding dependencies can be found in the "
"[overriding dependencies](reference/specifying-dependencies.html#overriding-"
"dependencies) section of the documentation and [RFC 1969](https://github.com/"
"rust-lang/rfcs/pull/1969) for the technical specification of this feature."
msgstr ""

#: src/reference/manifest.md:807
msgid "The `[replace]` Section"
msgstr ""

#: src/reference/manifest.md:812
msgid ""
"```toml\n"
"[replace]\n"
"\"foo:0.1.0\" = { git = 'https://github.com/example/foo' }\n"
"\"bar:1.0.2\" = { path = 'my/local/bar' }\n"
"```"
msgstr ""

#: src/reference/manifest.md:818
msgid ""
"Each key in the `[replace]` table is a [package id specification](reference/"
"pkgid-spec.html) which allows arbitrarily choosing a node in the dependency "
"graph to override. The value of each key is the same as the `[dependencies]` "
"syntax for specifying dependencies, except that you can't specify features. "
"Note that when a crate is overridden the copy it's overridden with must have "
"both the same name and version, but it can come from a different source (e."
"g. git or a local path)."
msgstr ""

#: src/reference/manifest.md:826
msgid ""
"More information about overriding dependencies can be found in the "
"[overriding dependencies](reference/specifying-dependencies.html#overriding-"
"dependencies) section of the documentation."
msgstr ""

#: src/reference/unstable.md:1
msgid "Unstable Features"
msgstr ""

#: src/reference/unstable.md:3
msgid ""
"Experimental Cargo features are only available on the nightly channel.  You "
"typically use one of the `-Z` flags to enable them.  Run `cargo -Z help` to "
"see a list of flags available."
msgstr ""

#: src/reference/unstable.md:7
msgid ""
"`-Z unstable-options` is a generic flag for enabling other unstable command-"
"line flags.  Options requiring this will be called out below."
msgstr ""

#: src/reference/unstable.md:10
msgid ""
"Some unstable features will require you to specify the `cargo-features` key "
"in `Cargo.toml`."
msgstr ""

#: src/reference/unstable.md:13
msgid "Alternate Registries"
msgstr ""

#: src/reference/unstable.md:14
msgid ""
"RFC: [\\#2141](https://github.com/rust-lang/rfcs/blob/master/text/2141-"
"alternative-registries.md)"
msgstr ""

#: src/reference/unstable.md:15
msgid ""
"Tracking Issue: [rust-lang/rust#44931](https://github.com/rust-lang/rust/"
"issues/44931)"
msgstr ""

#: src/reference/unstable.md:17
msgid "Alternate registries allow you to use registries other than crates.io."
msgstr ""

#: src/reference/unstable.md:19
msgid ""
"The name of a registry is defined in `.cargo/config` under the `registries` "
"table:"
msgstr ""

#: src/reference/unstable.md:22
msgid ""
"```toml\n"
"[registries]\n"
"my-registry = { index = \"https://my-intranet:8080/index\" }\n"
"```"
msgstr ""

#: src/reference/unstable.md:27
msgid ""
"Authentication information for alternate registries can be added to `.cargo/"
"credentials`:"
msgstr ""

#: src/reference/unstable.md:30
msgid ""
"```toml\n"
"[my-registry]\n"
"token = \"api-token\"\n"
"```"
msgstr ""

#: src/reference/unstable.md:35
msgid ""
"Inside `Cargo.toml` you can specify which registry a dependency comes from "
"using the `registry` key. First you need to include the appropriate `cargo-"
"features` at the top of the file:"
msgstr ""

#: src/reference/unstable.md:39
msgid ""
"```toml\n"
"cargo-features = [\"alternative-registries\"]\n"
"\n"
"[package]\n"
"...\n"
"\n"
"[dependencies]\n"
"other-create = { version = \"1.0\", registry = \"my-registry\"}\n"
"```"
msgstr ""

#: src/reference/unstable.md:49
msgid ""
"A `--registry` flag has been added to commands that interact with registries "
"such as `publish`, `login`, etc.  Example:"
msgstr ""

#: src/reference/unstable.md:56
msgid ""
"The `publish` field in `Cargo.toml` has been extended to accept a list of "
"registries that will restrict publishing only to those registries."
msgstr ""

#: src/reference/unstable.md:59
msgid ""
"```toml\n"
"[package]\n"
"...\n"
"publish = [\"my-registry\"]\n"
"```"
msgstr ""

#: src/reference/unstable.md:66
msgid "rename-dependency"
msgstr ""

#: src/reference/unstable.md:67
msgid ""
"Original Issue: [\\#1311](https://github.com/rust-lang/cargo/issues/1311)"
msgstr ""

#: src/reference/unstable.md:68
msgid "PR: [\\#4953](https://github.com/rust-lang/cargo/pull/4953)"
msgstr ""

#: src/reference/unstable.md:69
msgid ""
"Tracking Issue: [\\#5653](https://github.com/rust-lang/cargo/issues/5653)"
msgstr ""

#: src/reference/unstable.md:71
msgid ""
"The rename-dependency feature allows you to import a dependency with a "
"different name from the source.  This can be useful in a few scenarios:"
msgstr ""

#: src/reference/unstable.md:74
msgid "Depending on crates with the same name from different registries."
msgstr ""

#: src/reference/unstable.md:75
msgid "Depending on multiple versions of a crate."
msgstr ""

#: src/reference/unstable.md:76
msgid "Avoid needing `extern crate foo as bar` in Rust source."
msgstr ""

#: src/reference/unstable.md:78
msgid ""
"Just include the `package` key to specify the actual name of the dependency. "
"You must include `cargo-features` at the top of your `Cargo.toml`."
msgstr ""

#: src/reference/unstable.md:81
msgid ""
"```toml\n"
"cargo-features = [\"rename-dependency\"]\n"
"\n"
"[package]\n"
"name = \"mypackage\"\n"
"version = \"0.0.1\"\n"
"\n"
"[dependencies]\n"
"foo = \"0.1\"\n"
"bar = { version = \"0.1\", registry = \"custom\", package = \"foo\" }\n"
"baz = { git = \"https://github.com/example/project\", package = \"foo\" }\n"
"```"
msgstr ""

#: src/reference/unstable.md:94
msgid "In this example, three crates are now available in your Rust code:"
msgstr ""

#: src/reference/unstable.md:97
msgid "// crates.io\n"
msgstr ""

#: src/reference/unstable.md:98
msgid "// registry `custom`\n"
msgstr ""

#: src/reference/unstable.md:99
msgid "// git repository\n"
msgstr ""

#: src/reference/unstable.md:102
msgid "Note that if you have an optional dependency like:"
msgstr ""

#: src/reference/unstable.md:104
msgid ""
"```toml\n"
"[dependencies]\n"
"foo = { version = \"0.1\", package = 'bar', optional = true }\n"
"```"
msgstr ""

#: src/reference/unstable.md:109
msgid ""
"you're depending on the crate `bar` from crates.io, but your crate has a "
"`foo` feature instead of a `bar` feature. That is, names of features take "
"after the name of the dependency, not the package name, when renamed."
msgstr ""

#: src/reference/unstable.md:113
msgid ""
"Enabling transitive dependencies works similarly, for example we could add "
"the following to the above manifest:"
msgstr ""

#: src/reference/unstable.md:121
msgid "publish-lockfile"
msgstr ""

#: src/reference/unstable.md:122
msgid ""
"Original Issue: [\\#2263](https://github.com/rust-lang/cargo/issues/2263)"
msgstr ""

#: src/reference/unstable.md:123
msgid "PR: [\\#5093](https://github.com/rust-lang/cargo/pull/5093)"
msgstr ""

#: src/reference/unstable.md:124
msgid ""
"Tracking Issue: [\\#5654](https://github.com/rust-lang/cargo/issues/5654)"
msgstr ""

#: src/reference/unstable.md:126
msgid ""
"When creating a `.crate` file for distribution, Cargo has historically not "
"included the `Cargo.lock` file.  This can cause problems with using `cargo "
"install` with a binary.  You can specify that your package should include "
"the `Cargo.lock` file when using `cargo package` or `cargo publish` by "
"specifying the `publish-lockfile` key in `Cargo.toml`.  This also requires "
"the appropriate `cargo-features`:"
msgstr ""

#: src/reference/unstable.md:133
msgid ""
"```toml\n"
"cargo-features = [\"publish-lockfile\"]\n"
"\n"
"[package]\n"
"...\n"
"publish-lockfile = true\n"
"```"
msgstr ""

#: src/reference/unstable.md:142
msgid "Offline Mode"
msgstr ""

#: src/reference/unstable.md:143
msgid ""
"Original Issue: [\\#4686](https://github.com/rust-lang/cargo/issues/4686)"
msgstr ""

#: src/reference/unstable.md:144
msgid ""
"Tracking Issue: [\\#5655](https://github.com/rust-lang/cargo/issues/5655)"
msgstr ""

#: src/reference/unstable.md:146
msgid ""
"The `-Z offline` flag prevents Cargo from attempting to access the network "
"for any reason.  Typically Cargo will stop with an error if it wants to "
"access the network and it is not available."
msgstr ""

#: src/reference/unstable.md:150
msgid ""
"Beware that this may result in different dependency resolution than online "
"mode.  Cargo will restrict itself to crates that are available locally, even "
"if there might be a newer version as indicated in the local copy of the "
"index."
msgstr ""

#: src/reference/unstable.md:154
msgid "no-index-update"
msgstr ""

#: src/reference/unstable.md:155
msgid ""
"Original Issue: [\\#3479](https://github.com/rust-lang/cargo/issues/3479)"
msgstr ""

#: src/reference/unstable.md:157
msgid ""
"The `-Z no-index-update` flag ensures that Cargo does not attempt to update "
"the registry index.  This is intended for tools such as Crater that issue "
"many Cargo commands, and you want to avoid the network latency for updating "
"the index each time."
msgstr ""

#: src/reference/unstable.md:162
msgid "avoid-dev-deps"
msgstr ""

#: src/reference/unstable.md:163
msgid ""
"Original Issue: [\\#4988](https://github.com/rust-lang/cargo/issues/4988)"
msgstr ""

#: src/reference/unstable.md:164
msgid ""
"Stabilization Issue: [\\#5133](https://github.com/rust-lang/cargo/"
"issues/5133)"
msgstr ""

#: src/reference/unstable.md:166
msgid ""
"When running commands such as `cargo install` or `cargo build`, Cargo "
"currently requires dev-dependencies to be downloaded, even if they are not "
"used.  The `-Z avoid-dev-deps` flag allows Cargo to avoid downloading dev-"
"dependencies if they are not needed.  The `Cargo.lock` file will not be "
"generated if dev-dependencies are skipped."
msgstr ""

#: src/reference/unstable.md:172
msgid "minimal-versions"
msgstr ""

#: src/reference/unstable.md:173
msgid ""
"Original Issue: [\\#4100](https://github.com/rust-lang/cargo/issues/4100)"
msgstr ""

#: src/reference/unstable.md:174
msgid ""
"Tracking Issue: [\\#5657](https://github.com/rust-lang/cargo/issues/5657)"
msgstr ""

#: src/reference/unstable.md:176
msgid ""
"When a `Cargo.lock` file is generated, the `-Z minimal-versions` flag will "
"resolve the dependencies to the minimum semver version that will satisfy the "
"requirements (instead of the greatest version)."
msgstr ""

#: src/reference/unstable.md:180
msgid ""
"The intended use-case of this flag is to check, during continuous "
"integration, that the versions specified in Cargo.toml are a correct "
"reflection of the minimum versions that you are actually using. That is, if "
"Cargo.toml says `foo = \"1.0.0\"` that you don't accidentally depend on "
"features added only in `foo 1.5.0`."
msgstr ""

#: src/reference/unstable.md:186
msgid "out-dir"
msgstr ""

#: src/reference/unstable.md:187
msgid ""
"Original Issue: [\\#4875](https://github.com/rust-lang/cargo/issues/4875)"
msgstr ""

#: src/reference/unstable.md:189
msgid ""
"This feature allows you to specify the directory where artifacts will be "
"copied to after they are built.  Typically artifacts are only written to the "
"`target/release` or `target/debug` directories.  However, determining the "
"exact filename can be tricky since you need to parse JSON output. The `--out-"
"dir` flag makes it easier to predictably access the artifacts. Note that the "
"artifacts are copied, so the originals are still in the `target` directory.  "
"Example:"
msgstr ""

#: src/reference/unstable.md:202
msgid "Edition"
msgstr ""

#: src/reference/unstable.md:203
msgid ""
"Tracking Issue: [rust-lang/rust#44581](https://github.com/rust-lang/rust/"
"issues/44581)"
msgstr ""

#: src/reference/unstable.md:204
msgid ""
"RFC: [\\#2052](https://github.com/rust-lang/rfcs/blob/master/text/2052-"
"epochs.md)"
msgstr ""

#: src/reference/unstable.md:206
msgid ""
"You can opt in to a specific Rust Edition for your package with the "
"`edition` key in `Cargo.toml`.  If you don't specify the edition, it will "
"default to 2015.  You need to include the appropriate `cargo-features`."
msgstr ""

#: src/reference/unstable.md:210
msgid ""
"You can also specify `edition` on a per-target level, where it will "
"otherwise default to the package `edition`."
msgstr ""

#: src/reference/unstable.md:213
msgid ""
"```toml\n"
"cargo-features = [\"edition\"]\n"
"\n"
"[package]\n"
"...\n"
"edition = \"2018\"\n"
"\n"
"[[bin]]\n"
"...\n"
"edition = \"2015\"\n"
"```"
msgstr ""

#: src/reference/unstable.md:226
msgid "Profile Overrides"
msgstr ""

#: src/reference/unstable.md:227 src/reference/unstable.md:262
msgid ""
"Tracking Issue: [rust-lang/rust#48683](https://github.com/rust-lang/rust/"
"issues/48683)"
msgstr ""

#: src/reference/unstable.md:228 src/reference/unstable.md:263
msgid ""
"RFC: [\\#2282](https://github.com/rust-lang/rfcs/blob/master/text/2282-"
"profile-dependencies.md)"
msgstr ""

#: src/reference/unstable.md:230
msgid ""
"Profiles can be overridden for specific packages and custom build scripts. "
"The general format looks like this:"
msgstr ""

#: src/reference/unstable.md:233
msgid ""
"```toml\n"
"cargo-features = [\"profile-overrides\"]\n"
"\n"
"[package]\n"
"...\n"
"\n"
"[profile.dev]\n"
"opt-level = 0\n"
"debug = true\n"
"\n"
"# the `image` crate will be compiled with -Copt-level=3\n"
"[profile.dev.overrides.image]\n"
"opt-level = 3\n"
"\n"
"# All dependencies (but not this crate itself or any workspace member)\n"
"# will be compiled with -Copt-level=2 . This includes build dependencies.\n"
"[profile.dev.overrides.\"*\"]\n"
"opt-level = 2\n"
"\n"
"# Build scripts and their dependencies will be compiled with -Copt-level=3\n"
"# By default, build scripts use the same rules as the rest of the profile\n"
"[profile.dev.build-override]\n"
"opt-level = 3\n"
"```"
msgstr ""

#: src/reference/unstable.md:258
msgid "Overrides can only be specified for dev and release profiles."
msgstr ""

#: src/reference/unstable.md:261
msgid "Config Profiles"
msgstr ""

#: src/reference/unstable.md:265
msgid ""
"Profiles can be specified in `.cargo/config` files.  The `-Z config-profile` "
"command-line flag is required to use this feature.  The format is the same "
"as in a `Cargo.toml` manifest.  If found in multiple config files, settings "
"will be merged using the regular [config hierarchy](reference/config."
"html#hierarchical-structure). Config settings take precedence over manifest "
"settings."
msgstr ""

#: src/reference/unstable.md:281
msgid "Namespaced features"
msgstr ""

#: src/reference/unstable.md:282
msgid ""
"Original issue: [\\#1286](https://github.com/rust-lang/cargo/issues/1286)"
msgstr ""

#: src/reference/unstable.md:283
msgid ""
"Tracking Issue: [rust-lang/cargo#5565](https://github.com/rust-lang/cargo/"
"issues/5565)"
msgstr ""

#: src/reference/unstable.md:285
msgid ""
"Currently, it is not possible to have a feature and a dependency with the "
"same name in the manifest. If you set `namespaced-features` to `true`, the "
"namespaces for features and dependencies are separated. The effect of this "
"is that, in the feature requirements, dependencies have to be prefixed with "
"`crate:`. Like this:"
msgstr ""

#: src/reference/unstable.md:290
msgid ""
"```toml\n"
"[package]\n"
"namespaced-features = true\n"
"\n"
"[features]\n"
"bar = [\"crate:baz\", \"foo\"]\n"
"foo = []\n"
"\n"
"[dependencies]\n"
"baz = { version = \"0.1\", optional = true }\n"
"```"
msgstr ""

#: src/reference/unstable.md:302
msgid ""
"To prevent unnecessary boilerplate from having to explicitly declare "
"features for each optional dependency, implicit features get created for any "
"optional dependencies where a feature of the same name is not defined. "
"However, if a feature of the same name as a dependency is defined, that "
"feature must include the dependency as a requirement, as `foo = [\"crate:"
"foo\"]`."
msgstr ""

#: src/reference/unstable.md:309
msgid "Build-plan"
msgstr ""

#: src/reference/unstable.md:310
msgid ""
"Tracking Issue: [rust-lang/cargo#5579](https://github.com/rust-lang/cargo/"
"issues/5579)"
msgstr ""

#: src/reference/unstable.md:312
msgid ""
"The `--build-plan` argument for the `build` command will output JSON with "
"information about which commands would be run without actually executing "
"anything. This can be useful when integrating with another build tool. "
"Example:"
msgstr ""

#: src/reference/unstable.md:321
msgid "Compile progress"
msgstr ""

#: src/reference/unstable.md:322
msgid ""
"Tracking Issue: [rust-lang/cargo#2536](https://github.com/rust-lang/cargo/"
"issues/2536)"
msgstr ""

#: src/reference/unstable.md:324
msgid "The `-Z compile-progress` flag enables a progress bar while compiling."
msgstr ""

#: src/reference/unstable.md:337
msgid "default-run"
msgstr ""

#: src/reference/unstable.md:338
msgid ""
"Original issue: [\\#2200](https://github.com/rust-lang/cargo/issues/2200)"
msgstr ""

#: src/reference/unstable.md:340
msgid ""
"The `default-run` option in the `[project]` section of the manifest can be "
"used to specify a default binary picked by `cargo run`. For example, when "
"there is both `src/bin/a.rs` and `src/bin/b.rs`:"
msgstr ""

#: src/reference/unstable.md:344
msgid ""
"```toml\n"
"[project]\n"
"default-run = \"a\"\n"
"```"
msgstr ""

#: src/faq.md:1
msgid "Frequently Asked Questions"
msgstr ""

#: src/faq.md:3
msgid "Is the plan to use GitHub as a package repository?"
msgstr ""

#: src/faq.md:5
msgid ""
"No. The plan for Cargo is to use [crates.io](https://crates.io/), like npm "
"or Rubygems do with npmjs.org and rubygems.org."
msgstr ""

#: src/faq.md:8
msgid ""
"We plan to support git repositories as a source of packages forever, because "
"they can be used for early development and temporary patches, even when "
"people use the registry as the primary source of packages."
msgstr ""

#: src/faq.md:12
msgid "Why build crates.io rather than use GitHub as a registry?"
msgstr ""

#: src/faq.md:14
msgid ""
"We think that it’s very important to support multiple ways to download "
"packages, including downloading from GitHub and copying packages into your "
"project itself."
msgstr ""

#: src/faq.md:18
msgid ""
"That said, we think that [crates.io](https://crates.io/) offers a number of "
"important benefits, and will likely become the primary way that people "
"download packages in Cargo."
msgstr ""

#: src/faq.md:21
msgid ""
"For precedent, both Node.js’s [npm](https://www.npmjs.org) and Ruby’s "
"[bundler](https://bundler.io) support both a central registry model as well "
"as a Git-based model, and most packages are downloaded through the registry "
"in those ecosystems, with an important minority of packages making use of "
"git-based packages."
msgstr ""

#: src/faq.md:29
msgid ""
"Some of the advantages that make a central registry popular in other "
"languages include:"
msgstr ""

#: src/faq.md:32
msgid ""
"**Discoverability**. A central registry provides an easy place to look for "
"existing packages. Combined with tagging, this also makes it possible for a "
"registry to provide ecosystem-wide information, such as a list of the most "
"popular or most-depended-on packages."
msgstr ""

#: src/faq.md:36
msgid ""
"**Speed**. A central registry makes it possible to easily fetch just the "
"metadata for packages quickly and efficiently, and then to efficiently "
"download just the published package, and not other bloat that happens to "
"exist in the repository. This adds up to a significant improvement in the "
"speed of dependency resolution and fetching. As dependency graphs scale up, "
"downloading all of the git repositories bogs down fast. Also remember that "
"not everybody has a high-speed, low-latency Internet connection."
msgstr ""

#: src/faq.md:45
msgid "Will Cargo work with C code (or other languages)?"
msgstr ""

#: src/faq.md:47 src/faq.md:96
msgid "Yes!"
msgstr ""

#: src/faq.md:49
msgid ""
"Cargo handles compiling Rust code, but we know that many Rust projects link "
"against C code. We also know that there are decades of tooling built up "
"around compiling languages other than Rust."
msgstr ""

#: src/faq.md:53
msgid ""
"Our solution: Cargo allows a package to [specify a script](reference/build-"
"scripts.html) (written in Rust) to run before invoking `rustc`. Rust is "
"leveraged to implement platform-specific configuration and refactor out "
"common build functionality among packages."
msgstr ""

#: src/faq.md:58
msgid "Can Cargo be used inside of `make` (or `ninja`, or ...)"
msgstr ""

#: src/faq.md:60
msgid ""
"Indeed. While we intend Cargo to be useful as a standalone way to compile "
"Rust projects at the top-level, we know that some people will want to invoke "
"Cargo from other build tools."
msgstr ""

#: src/faq.md:64
msgid ""
"We have designed Cargo to work well in those contexts, paying attention to "
"things like error codes and machine-readable output modes. We still have "
"some work to do on those fronts, but using Cargo in the context of "
"conventional scripts is something we designed for from the beginning and "
"will continue to prioritize."
msgstr ""

#: src/faq.md:70
msgid "Does Cargo handle multi-platform projects or cross-compilation?"
msgstr ""

#: src/faq.md:72
msgid ""
"Rust itself provides facilities for configuring sections of code based on "
"the platform. Cargo also supports [platform-specific dependencies](reference/"
"specifying-dependencies.html#platform-specific-dependencies), and we plan to "
"support more per-platform configuration in `Cargo.toml` in the future."
msgstr ""

#: src/faq.md:79
msgid ""
"In the longer-term, we’re looking at ways to conveniently cross-compile "
"projects using Cargo."
msgstr ""

#: src/faq.md:82
msgid "Does Cargo support environments, like `production` or `test`?"
msgstr ""

#: src/faq.md:84
msgid ""
"We support environments through the use of [profiles](reference/manifest."
"html#the-profile-sections) to support:"
msgstr ""

#: src/faq.md:88
msgid ""
"environment-specific flags (like `-g --opt-level=0` for development and `--"
"opt-level=3` for production)."
msgstr ""

#: src/faq.md:90
msgid ""
"environment-specific dependencies (like `hamcrest` for test assertions)."
msgstr ""

#: src/faq.md:91
msgid "environment-specific `#[cfg]`"
msgstr ""

#: src/faq.md:92
msgid "a `cargo test` command"
msgstr ""

#: src/faq.md:94
msgid "Does Cargo work on Windows?"
msgstr ""

#: src/faq.md:98
msgid ""
"All commits to Cargo are required to pass the local test suite on Windows. "
"If, however, you find a Windows issue, we consider it a bug, so [please file "
"an issue](https://github.com/rust-lang/cargo/issues)."
msgstr ""

#: src/faq.md:104
msgid ""
"Why do binaries have `Cargo.lock` in version control, but not libraries?"
msgstr ""

#: src/faq.md:106
msgid ""
"The purpose of a `Cargo.lock` is to describe the state of the world at the "
"time of a successful build. It is then used to provide deterministic builds "
"across whatever machine is building the project by ensuring that the exact "
"same dependencies are being compiled."
msgstr ""

#: src/faq.md:111
msgid ""
"This property is most desirable from applications and projects which are at "
"the very end of the dependency chain (binaries). As a result, it is "
"recommended that all binaries check in their `Cargo.lock`."
msgstr ""

#: src/faq.md:115
msgid ""
"For libraries the situation is somewhat different. A library is not only "
"used by the library developers, but also any downstream consumers of the "
"library. Users dependent on the library will not inspect the library’s "
"`Cargo.lock` (even if it exists). This is precisely because a library should "
"**not** be deterministically recompiled for all users of the library."
msgstr ""

#: src/faq.md:121
msgid ""
"If a library ends up being used transitively by several dependencies, it’s "
"likely that just a single copy of the library is desired (based on semver "
"compatibility). If Cargo used all of the dependencies' `Cargo.lock` files, "
"then multiple copies of the library could be used, and perhaps even a "
"version conflict."
msgstr ""

#: src/faq.md:127
msgid ""
"In other words, libraries specify semver requirements for their dependencies "
"but cannot see the full picture. Only end products like binaries have a full "
"picture to decide what versions of dependencies should be used."
msgstr ""

#: src/faq.md:131
msgid "Can libraries use `*` as a version for their dependencies?"
msgstr ""

#: src/faq.md:133
msgid ""
"**As of January 22nd, 2016, [crates.io](https://crates.io/) rejects all "
"packages (not just libraries) with wildcard dependency constraints.**"
msgstr ""

#: src/faq.md:136
msgid ""
"While libraries _can_, strictly speaking, they should not. A version "
"requirement of `*` says “This will work with every version ever,” which is "
"never going to be true. Libraries should always specify the range that they "
"do work with, even if it’s something as general as “every 1.x.y version.”"
msgstr ""

#: src/faq.md:141
msgid "Why `Cargo.toml`?"
msgstr ""

#: src/faq.md:143
msgid ""
"As one of the most frequent interactions with Cargo, the question of why the "
"configuration file is named `Cargo.toml` arises from time to time. The "
"leading capital-`C` was chosen to ensure that the manifest was grouped with "
"other similar configuration files in directory listings. Sorting files often "
"puts capital letters before lowercase letters, ensuring files like "
"`Makefile` and `Cargo.toml` are placed together. The trailing `.toml` was "
"chosen to emphasize the fact that the file is in the [TOML configuration "
"format](https://github.com/toml-lang/toml)."
msgstr ""

#: src/faq.md:152
msgid ""
"Cargo does not allow other names such as `cargo.toml` or `Cargofile` to "
"emphasize the ease of how a Cargo repository can be identified. An option of "
"many possible names has historically led to confusion where one case was "
"handled but others were accidentally forgotten."
msgstr ""

#: src/faq.md:159
msgid "How can Cargo work offline?"
msgstr ""

#: src/faq.md:161
msgid ""
"Cargo is often used in situations with limited or no network access such as "
"airplanes, CI environments, or embedded in large production deployments. "
"Users are often surprised when Cargo attempts to fetch resources from the "
"network, and hence the request for Cargo to work offline comes up frequently."
msgstr ""

#: src/faq.md:166
msgid ""
"Cargo, at its heart, will not attempt to access the network unless told to "
"do so. That is, if no crates comes from crates.io, a git repository, or some "
"other network location, Cargo will never attempt to make a network "
"connection. As a result, if Cargo attempts to touch the network, then it's "
"because it needs to fetch a required resource."
msgstr ""

#: src/faq.md:172
msgid ""
"Cargo is also quite aggressive about caching information to minimize the "
"amount of network activity. It will guarantee, for example, that if `cargo "
"build` (or an equivalent) is run to completion then the next `cargo build` "
"is guaranteed to not touch the network so long as `Cargo.toml` has not been "
"modified in the meantime. This avoidance of the network boils down to a "
"`Cargo.lock` existing and a populated cache of the crates reflected in the "
"lock file. If either of these components are missing, then they're required "
"for the build to succeed and must be fetched remotely."
msgstr ""

#: src/faq.md:181
msgid ""
"As of Rust 1.11.0 Cargo understands a new flag, `--frozen`, which is an "
"assertion that it shouldn't touch the network. When passed, Cargo will "
"immediately return an error if it would otherwise attempt a network request. "
"The error should include contextual information about why the network "
"request is being made in the first place to help debug as well. Note that "
"this flag _does not change the behavior of Cargo_, it simply asserts that "
"Cargo shouldn't touch the network as a previous command has been run to "
"ensure that network activity shouldn't be necessary."
msgstr ""

#: src/faq.md:190
msgid ""
"For more information about vendoring, see documentation on [source "
"replacement](reference/source-replacement.html)."
msgstr ""

#: src/getting-started/index.md:1
msgid "Getting Started"
msgstr ""

#: src/getting-started/index.md:3
msgid ""
"To get started with Cargo, install Cargo (and Rust) and set up your first "
"crate."
msgstr ""

#: src/getting-started/index.md:5
msgid "[Installation](getting-started/installation.html)"
msgstr ""

#: src/getting-started/index.md:6
msgid "[First steps with Cargo](getting-started/first-steps.html)"
msgstr ""

#: src/getting-started/first-steps.md:1
msgid "First Steps with Cargo"
msgstr ""

#: src/getting-started/first-steps.md:9
msgid ""
"Cargo defaults to `--bin` to make a binary program. To make a library, we'd "
"pass `--lib`."
msgstr ""

#: src/getting-started/first-steps.md:25
msgid ""
"This is all we need to get started. First, let’s check out `Cargo.toml`:"
msgstr ""

#: src/getting-started/first-steps.md:59
msgid ""
"We can also use `cargo run` to compile and then run it, all in one step:"
msgstr ""

#: src/getting-started/first-steps.md:61
msgid ""
"```console\n"
"$ cargo run\n"
"     Fresh hello_world v0.1.0 (file:///path/to/project/hello_world)\n"
"   Running `target/hello_world`\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/getting-started/first-steps.md:68
msgid "Going further"
msgstr ""

#: src/getting-started/first-steps.md:70
msgid ""
"For more details on using Cargo, check out the [Cargo Guide](guide/index."
"html)"
msgstr ""

#: src/getting-started/installation.md:1
msgid "Installation"
msgstr ""

#: src/getting-started/installation.md:3
msgid "Install Rust and Cargo"
msgstr ""

#: src/getting-started/installation.md:5
msgid ""
"The easiest way to get Cargo is to install the current stable release of "
"[Rust](https://www.rust-lang.org/) by using `rustup`."
msgstr ""

#: src/getting-started/installation.md:8
msgid "On Linux and macOS systems, this is done as follows:"
msgstr ""

#: src/getting-started/installation.md:10
msgid ""
"```console\n"
"$ curl -sSf https://static.rust-lang.org/rustup.sh | sh\n"
"```"
msgstr ""

#: src/getting-started/installation.md:14
msgid ""
"It will download a script, and start the installation. If everything goes "
"well, you’ll see this appear:"
msgstr ""

#: src/getting-started/installation.md:21
msgid ""
"On Windows, download and run [rustup-init.exe](https://win.rustup.rs/). It "
"will start the installation in a console and present the above message on "
"success."
msgstr ""

#: src/getting-started/installation.md:24
msgid ""
"After this, you can use the `rustup` command to also install `beta` or "
"`nightly` channels for Rust and Cargo."
msgstr ""

#: src/getting-started/installation.md:27
msgid ""
"For other installation options and information, visit the [install](https://"
"www.rust-lang.org/install.html) page of the Rust website."
msgstr ""

#: src/getting-started/installation.md:30
msgid "Build and Install Cargo from Source"
msgstr ""

#: src/getting-started/installation.md:32
msgid ""
"Alternatively, you can [build Cargo from source](https://github.com/rust-"
"lang/cargo#compiling-from-source)."
msgstr ""

#: src/index.md:1
msgid "The Cargo Book"
msgstr ""

#: src/index.md:3
msgid "![Cargo Logo](images/Cargo-Logo-Small.png)"
msgstr ""

#: src/index.md:5
msgid ""
"Cargo is the [Rust](https://www.rust-lang.org/) _package manager_. Cargo "
"downloads your Rust project’s dependencies, compiles your project, makes "
"packages, and upload them to [crates.io](https://crates.io/), the Rust "
"community’s _package registry_. You can contribute to this book on [GitHub]"
"(https://github.com/rust-lang/cargo/tree/master/src/doc/src)."
msgstr ""

#: src/index.md:11
msgid "Sections"
msgstr ""

#: src/index.md:13
msgid "**[Getting Started](getting-started/index.html)**"
msgstr ""

#: src/index.md:17
msgid "**[Cargo Guide](guide/index.html)**"
msgstr ""

#: src/index.md:19
msgid ""
"The guide will give you all you need to know about how to use Cargo to "
"develop Rust projects."
msgstr ""

#: src/index.md:22
msgid "**[Cargo Reference](reference/index.html)**"
msgstr ""

#: src/index.md:26
msgid "**[Frequently Asked Questions](faq.html)**"
msgstr ""

#: src/SUMMARY.md:1
msgid "Summary"
msgstr ""

#: src/SUMMARY.md:3
msgid "Introduction"
msgstr ""

#: src/SUMMARY.md:12
msgid "Working on an Existing Project"
msgstr ""

#: src/SUMMARY.md:18
msgid "Build Cache"
msgstr ""

#: src/SUMMARY.md:29
msgid "External Tools"
msgstr ""

#: src/SUMMARY.md:32
msgid "FAQ"
msgstr ""
