msgid ""
msgstr ""
"Project-Id-Version: The Cargo Book\n"
"POT-Creation-Date: 2026-01-24T08:44:47Z\n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_TW\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: src/guide/cargo-toml-vs-cargo-lock.md:1
msgid "Cargo.toml vs Cargo.lock"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:3
msgid ""
"`Cargo.toml` and `Cargo.lock` serve two different purposes. Before we talk "
"about them, here’s a summary:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:6
msgid ""
"`Cargo.toml` is about describing your dependencies in a broad sense, and is "
"written by you."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:8
msgid ""
"`Cargo.lock` contains exact information about your dependencies. It is "
"maintained by Cargo and should not be manually edited."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:11
msgid ""
"If you’re building a non-end product, such as a rust library that other rust "
"[packages](../appendix/glossary.md#package \"\\\"package\\\" (glossary "
"entry)\") will depend on, put `Cargo.lock` in your `.gitignore`. If you’re "
"building an end product, which are executable like command-line tool or an "
"application, or a system library with crate-type of `staticlib` or `cdylib`, "
"check `Cargo.lock` into `git`. If you're curious about why that is, see "
"[\"Why do binaries have `Cargo.lock` in version control, but not libraries?"
"\" in the FAQ](../faq.md#why-do-binaries-have-cargolock-in-version-control-"
"but-not-libraries)."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:20
msgid "Let’s dig in a little bit more."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:22
msgid ""
"`Cargo.toml` is a [**manifest**](../appendix/glossary.md#manifest \"\\"
"\"manifest\\\" (glossary entry)\") file in which we can specify a bunch of "
"different metadata about our package. For example, we can say that we depend "
"on another package:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:26
#: src/guide/cargo-toml-vs-cargo-lock.md:61
msgid ""
"```toml\n"
"[package]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"regex = { git = \"https://github.com/rust-lang/regex.git\" }\n"
"```"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:35
msgid ""
"This package has a single dependency, on the `regex` library. We’ve stated "
"in this case that we’re relying on a particular Git repository that lives on "
"GitHub. Since we haven’t specified any other information, Cargo assumes that "
"we intend to use the latest commit on the `master` branch to build our "
"package."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:40
msgid ""
"Sound good? Well, there’s one problem: If you build this package today, and "
"then you send a copy to me, and I build this package tomorrow, something bad "
"could happen. There could be more commits to `regex` in the meantime, and my "
"build would include new commits while yours would not. Therefore, we would "
"get different builds. This would be bad because we want reproducible builds."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:46
msgid "We could fix this problem by putting a `rev` line in our `Cargo.toml`:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:48
msgid ""
"```toml\n"
"[dependencies]\n"
"regex = { git = \"https://github.com/rust-lang/regex.git\", rev = "
"\"9f9f693\" }\n"
"```"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:53
msgid ""
"Now our builds will be the same. But there’s a big drawback: now we have to "
"manually think about SHA-1s every time we want to update our library. This "
"is both tedious and error prone."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:57
msgid ""
"Enter the `Cargo.lock`. Because of its existence, we don’t need to manually "
"keep track of the exact revisions: Cargo will do it for us. When we have a "
"manifest like this:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:70
msgid ""
"Cargo will take the latest commit and write that information out into our "
"`Cargo.lock` when we build for the first time. That file will look like this:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:73
msgid ""
"```toml\n"
"[[package]]\n"
"name = \"hello_world\"\n"
"version = \"0.1.0\"\n"
"dependencies = [\n"
" \"regex 1.5.0 (git+https://github.com/rust-lang/regex."
"git#9f9f693768c584971a4d53bc3c586c33ed3a6831)\",\n"
"]\n"
"\n"
"[[package]]\n"
"name = \"regex\"\n"
"version = \"1.5.0\"\n"
"source = \"git+https://github.com/rust-lang/regex."
"git#9f9f693768c584971a4d53bc3c586c33ed3a6831\"\n"
"```"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:87
msgid ""
"You can see that there’s a lot more information here, including the exact "
"revision we used to build. Now when you give your package to someone else, "
"they’ll use the exact same SHA, even though we didn’t specify it in our "
"`Cargo.toml`."
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:92
msgid ""
"When we’re ready to opt in to a new version of the library, Cargo can re-"
"calculate the dependencies and update things for us:"
msgstr ""

#: src/guide/cargo-toml-vs-cargo-lock.md:100
msgid ""
"This will write out a new `Cargo.lock` with the new version information. "
"Note that the argument to `cargo update` is actually a [Package ID "
"Specification](../reference/pkgid-spec.md) and `regex` is just a short "
"specification."
msgstr ""
